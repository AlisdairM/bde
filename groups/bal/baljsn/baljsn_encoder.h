// baljsn_encoder.h                                                   -*-C++-*-
#ifndef INCLUDED_BALJSN_ENCODER
#define INCLUDED_BALJSN_ENCODER

#include <bsls_ident.h>
BSLS_IDENT("$Id: $")

//@PURPOSE: Provide a JSON encoder for 'bdlat'-compatible types.
//
//@CLASSES:
// baljsn::Encoder: JSON decoder for 'bdlat'-compliant types
//
//@SEE_ALSO: baljsn_decoder, baljsn_printutil
//
//@DESCRIPTION: This component provides a class, 'baljsn::Encoder', for
// encoding value-semantic objects in the JSON format.  In particular, the
// 'class' contains a parameterized 'encode' function that encodes an object
// into a specified stream.  There are two overloaded versions of this
// function:
//
//: o one that writes to a 'bsl::streambuf'
//: o one that writes to an 'bsl::ostream'
//
// This component can be used with types that support the 'bdlat' framework
// (see the 'bdlat' package for details), which is a compile-time interface for
// manipulating struct-like and union-like objects.  In particular, types
// generated by the 'bas_codegen.pl' tool, and other dynamic types, can be
// encoded using this 'class'.  The 'encode' function can be invoked on any
// object that satisfies the requirements of a sequence, choice, or array
// object as defined in the 'bdlat_sequencefunctions', 'bdlat_choicefunctions',
// and 'bdlat_arrayfunctions' components.
//
// Although the JSON format is easy to read and write and is very useful for
// debugging, it is relatively expensive to encode and decode and relatively
// bulky to transmit.  It is more efficient to use a binary encoding (such as
// BER) if the encoding format is under your control (see 'balber_berencoder').
//
// Refer to the details of the JSON encoding format supported by this encoder
// in the package documentation file (doc/baljsn.txt).
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Encoding a 'bas_codegen.pl'-Generated Object into JSON
///-----------------------------------------------------------------
// Consider that we want to exchange an employee's information between two
// processes.  To allow this information exchange we will define the XML schema
// representation for that class, use 'bas_codegen.pl' to create the 'Employee'
// 'class' for storing that information, populate an 'Employee' object, and
// encode that object using the 'baljsn' encoder.
//
// First, we will define the XML schema inside a file called 'employee.xsd':
//..
//  <?xml version='1.0' encoding='UTF-8'?>
//  <xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'
//             xmlns:test='http://bloomberg.com/schemas/test'
//             targetNamespace='http://bloomberg.com/schemas/test'
//             elementFormDefault='unqualified'>
//
//      <xs:complexType name='Address'>
//          <xs:sequence>
//              <xs:element name='street' type='xs:string'/>
//              <xs:element name='city'   type='xs:string'/>
//              <xs:element name='state'  type='xs:string'/>
//          </xs:sequence>
//      </xs:complexType>
//
//      <xs:complexType name='Employee'>
//          <xs:sequence>
//              <xs:element name='name'        type='xs:string'/>
//              <xs:element name='homeAddress' type='test:Address'/>
//              <xs:element name='age'         type='xs:int'/>
//          </xs:sequence>
//      </xs:complexType>
//
//      <xs:element name='Employee' type='test:Employee'/>
//
//  </xs:schema>
//..
// Then, we will use the 'bas_codegen.pl' tool, to generate the C++ classes for
// this schema.  The following command will generate the header and
// implementation files for the all the classes in the 'test_messages'
// components in the current directory:
//..
//  $ bas_codegen.pl -m msg -p test xsdfile.xsd
//..
// Next, we will populate a 'test::Employee' object:
//..
//  test::Employee employee;
//  employee.name()                 = "Bob";
//  employee.homeAddress().street() = "Lexington Ave";
//  employee.homeAddress().city()   = "New York City";
//  employee.homeAddress().state()  = "New York";
//  employee.age()                  = 21;
//..
// Then, we will create a 'baljsn::Encoder' object:
//..
//  baljsn::Encoder encoder;
//..
// Now, we will output this object in the JSON format by invoking the 'encode'
// method of the encoder.  We will also create a 'baljsn::EncoderOptions'
// object that allows us to specify that the encoding should be done in a
// pretty format, and what the initial indent level and spaces per level should
// be.  We will then pass that object to the 'encode' method:
//..
//  bsl::ostringstream os;
//
//  baljsn::EncoderOptions options;
//  options.setEncodingStyle(baljsn::EncoderOptions::e_PRETTY);
//  options.setInitialIndentLevel(1);
//  options.setSpacesPerLevel(4);
//
//  const int rc = encoder.encode(os, employee, options);
//  assert(!rc);
//  assert(os);
//..
// Finally, we will verify that the output is as expected:
//..
//  const char EXP_OUTPUT[] = "    {\n"
//                            "        \"name\" : \"Bob\",\n"
//                            "        \"homeAddress\" : {\n"
//                            "            \"street\" : \"Lexington Ave\",\n"
//                            "            \"city\" : \"New York City\",\n"
//                            "            \"state\" : \"New York\"\n"
//                            "        },\n"
//                            "        \"age\" : 21\n"
//                            "    }\n";
//
//  assert(EXP_OUTPUT == os.str());
//..

#include <balscm_version.h>

#include <baljsn_encoderoptions.h>
#include <baljsn_formatter.h>
#include <baljsn_printutil.h>

#include <bdlat_attributeinfo.h>
#include <bdlat_choicefunctions.h>
#include <bdlat_customizedtypefunctions.h>
#include <bdlat_enumfunctions.h>
#include <bdlat_formattingmode.h>
#include <bdlat_selectioninfo.h>
#include <bdlat_sequencefunctions.h>
#include <bdlat_typecategory.h>
#include <bdlat_valuetypefunctions.h>

#include <bdlb_print.h>

#include <bdlsb_memoutstreambuf.h>

#include <bsla_maybeunused.h>
#include <bsls_assert.h>
#include <bsls_types.h>

#include <bsl_cstddef.h>
#include <bsl_iostream.h>
#include <bsl_ostream.h>
#include <bsl_sstream.h>
#include <bsl_streambuf.h>
#include <bsl_string.h>
#include <bsl_string_view.h>
#include <bsl_vector.h>

namespace BloombergLP {
namespace baljsn {

                               // =============
                               // class Encoder
                               // =============

class Encoder {
    // This class provides a mechanism for encoding value-semantic objects in
    // the JSON format.  The 'encode' methods are function templates that will
    // encode any object that meets the requirements of a sequence, choice, or
    // array object as defined in the 'bdlat_sequencefunctions',
    // 'bdlat_choicefunctions', and 'bdlat_choicefunctions' components
    // respectively.  These generic frameworks provide a common compile-time
    // interface for accessing struct-like and union-like objects.  In
    // particular, the types generated by 'bas_codegen.pl' provide the
    // necessary interface and can be encoded using this component.

    // DATA
    bsl::ostringstream d_logStream;  // stream used for logging

    // NOT IMPLEMENTED
    Encoder(const Encoder&);

    // PRIVATE MANIPULATORS
    bsl::ostream& logStream();
        // Return the stream for logging.

  public:
    // CREATORS
    explicit Encoder(bslma::Allocator *basicAllocator = 0);
        // Create a encoder object.  Optionally specify a 'basicAllocator' used
        // to supply memory.  If 'basicAllocator' is 0, the currently installed
        // default allocator is used.

    //! ~Encoder() = default;
        // Destroy this object.

    // MANIPULATORS
    template <class TYPE>
    int encode(bsl::streambuf        *streamBuf,
               const TYPE&            value,
               const EncoderOptions&  options);
    template <class TYPE>
    int encode(bsl::streambuf        *streamBuf,
               const TYPE&            value,
               const EncoderOptions  *options);
        // Encode the specified 'value', of (template parameter) 'TYPE', in the
        // JSON format using the specified 'options' and output
        // it onto the specified 'streamBuf'.  Specifying a nullptr 'options'
        // is equivalent to passing a default-constructed DecoderOptions in
        // 'options'.  'TYPE' shall be a 'bdlat'-compatible sequence, choice,
        // or array type, or a 'bdlat'-compatible dynamic type referring to one
        // of those types.  Return 0 on success, and a non-zero value
        // otherwise.

    template <class TYPE>
    int encode(bsl::ostream&         stream,
               const TYPE&           value,
               const EncoderOptions& options);
    template <class TYPE>
    int encode(bsl::ostream&         stream,
               const TYPE&           value,
               const EncoderOptions *options);
        // Encode the specified 'value', of (template parameter) 'TYPE', in the
        // JSON format using the specified 'options' and output
        // it onto the specified 'stream'.  Specifying a nullptr 'options' is
        // equivalent to passing a default-constructed DecoderOptions in
        // 'options'.  'TYPE' shall be a 'bdlat'-compatible choice, or array
        // type, or a 'bdlat'-compatible dynamic type referring to one of those
        // types.  Return 0 on success, and a non-zero value otherwise.

    template <class TYPE>
    int encode(bsl::streambuf *streamBuf, const TYPE& value);
        // Encode the specified 'value' of (template parameter) 'TYPE' into the
        // specified 'streamBuf'.  Return 0 on success, and a non-zero value
        // otherwise.
        //
        // DEPRECATED: Use the 'encode' function passed a reference to a
        // non-modifiable 'EncoderOptions' object instead.

    template <class TYPE>
    int encode(bsl::ostream& stream, const TYPE& value);
        // Encode the specified 'value' of (template parameter) 'TYPE' into the
        // specified 'stream'.  Return 0 on success, and a non-zero value
        // otherwise.  Note that 'stream' will be invalidated if the encoding
        // failed.
        //
        // DEPRECATED: Use the 'encode' function passed a reference to a
        // non-modifiable 'EncoderOptions' object instead.

    // ACCESSORS
    bsl::string loggedMessages() const;
        // Return a string containing any error, warning, or trace messages
        // that were logged during the last call to the 'encode' method.  The
        // log is reset each time 'encode' is called.
};

                        // =============================
                        // struct Encoder_EncodeImplUtil
                        // =============================

struct Encoder_EncodeImplUtil {
    // This component-private utility 'struct' provides a suite of functions
    // that encode 'bdlat' types in the JSON format.

    // TYPES
    typedef Encoder_EncodeImplUtil ThisUtil;
        // 'ThisUtil' is a convenience alias for this utility 'struct'.

    typedef int FormattingMode;
        // 'FormattingMode' is an alias to the type of an 'int'-valued
        // 'bdlat_FormattingMode' bit-field.  A 'FormattingMode' value is not
        // valid unless it is equal to an enumerator of 'bdlat_FormattingMode'
        // or a valid bitwise-or of two or more such enumerators.  See the
        // component-level documentation of {'bdlat_formattingmode'} for a
        // description of the set of valid formatting-mode values.

    // CLASS METHODS

                              // Document Encoding

    static void openDocument(bsl::ostream          *outputStream,
                             const EncoderOptions&  options);
        // Print the sequence of characters that designate the start of a JSON
        // document to the specified 'outputStream' according to the specified
        // encoding 'options'.  See the component-level documentation of
        // {'baljsn_encoderoptions'} for a description of the effects, if any,
        // of each option in the 'options' on the start of a JSON document.

    static void closeDocument(bsl::ostream          *outputStream,
                              const EncoderOptions&  options);
        // Print the sequence of characters that designate the end of a JSON
        // document to the specified 'outputStream' according to the specified
        // encoding 'options'.  See the component-level documentation of
        // {'baljsn_encoderoptions'} for a description of the effects, if any,
        // of each option in the 'options' on the end of a JSON document.

                               // Value Encoding

    template <class TYPE>
    static int encode(bsl::ostream          *jsonStream,
                      const TYPE&            value,
                      const EncoderOptions&  options = EncoderOptions());
        // Encode the JSON representation of the specified 'value' to the
        // specified 'jsonStream'.  Optionally specify 'options' to configure
        // aspects of the JSON representation of the 'value'.  If 'options' is
        // not specified, the default 'EncoderOptions' value is used.  Return 0
        // on success, and a non-zero value otherwise.  The behavior is
        // undefined unless the specified 'TYPE' satisfies both the static and
        // dynamic requirements of one 'bdlat' type-category concept.  See the
        // component-level documentation of {'baljsn_encoderoptions'} for a
        // description of the effects, if any, of each option in the 'options'
        // on the JSON representation of the 'value'.  See the package-level
        // documentation of {'bdlat'} for a description of the available
        // type-category concepts.

    template <class TYPE>
    static int encode(
                     bsl::ostream          *logStream,
                     bsl::ostream          *jsonStream,
                     const TYPE&            value,
                     const EncoderOptions&  options = EncoderOptions());
        // Encode the JSON representation of the specified 'value' to the
        // specified 'jsonStream'.  If this operation is not successful, load
        // an unspecified, human-readable description of the error condition to
        // the specified 'logStream'.  Optionally specify 'options' to
        // configure aspects of the JSON representation of the 'value'.  If
        // 'options' is not specified, the default 'EncoderOptions' value is
        // used.  Return 0 on success, and a non-zero value otherwise.  The
        // behavior is undefined unless the specified 'TYPE' satisfies both the
        // static and dynamic requirements of one 'bdlat' type-category
        // concept.  See the component-level documentation of
        // {'baljsn_encoderoptions'} for a description of the effects, if any,
        // of each option in the 'options' on the JSON representation of the
        // 'value'.  See the package-level documentation of {'bdlat'} for an
        // introduction to the requirements of 'bdlat' type-category concepts.

    template <class TYPE>
    static int encode(bool                  *isValueEmpty,
                      Formatter             *formatter,
                      bsl::ostream          *logStream,
                      const TYPE&            value,
                      FormattingMode         formattingMode,
                      const EncoderOptions&  options,
                      bool                   isFirstMember);
        // Encode the JSON representation of the specified 'value' to the
        // specified JSON 'formatter', according to the specified
        // 'formattingMode'.  If the representation contains no text, load the
        // value 'true' into 'isValueEmpty' and the value 'false' otherwise.
        // If the specified 'isFirstMember' option is 'true', then the
        // representation of the value contains no leading sequence delimiter,
        // and does contain such a delimiter if the remaining representation is
        // non-empty otherwise.  Use the specified 'options' to configure
        // aspects of the JSON representation of the 'value'.  If this
        // operation is not successful, load an unspecified, human-readable
        // description of the error condition to the specified 'logStream'.
        // Return 0 on success, and a non-zero value otherwise.  The behavior
        // is undefined unless the specified 'TYPE' satisfies both the static
        // and dynamic requirements of one of the 'bdlat' type-category
        // concepts.  See the component-level documentation of
        // {'baljsn_encoderoptions'} for a description of the effects, if any,
        // of each option in the 'options' on the JSON representation of the
        // 'value'.  See the package-level documentation of {'bdlat'} for an
        // introduction to the requirements of 'bdlat' type-category concepts.

                                 // Validation

    template <class TYPE>
    static int validate(bsl::ostream               *logStream,
                        const TYPE&                 value,
                        bdlat_TypeCategory::Choice  category);
    template <class TYPE, class CATEGORY>
    static int validate(bsl::ostream *logStream,
                        const TYPE&   value,
                        CATEGORY      category);
        // Determine if the specified 'value' having the specified 'bdlat'
        // 'category' satisfies the requirements for encoding using this
        // component.  If the 'value' meets the encoding requirements, return
        // 0, otherwise load an unspecified, human-readable description of the
        // requirements that are not satisfied by the 'value' and return a
        // non-zero value.  For values satisfying the 'bdlat' 'Choice'
        // type-category concept, the value of the  'selectionId' attribute
        // must not be undefined.  For values satisfying the requirements of
        // other 'bdlat' type-category concepts, there are no further
        // requirements for encoding using this component.  See the
        // package-level documentation of {'bdlat'} for an introduction to the
        // requirements of 'bdlat' type-category concepts.

    template <class TYPE>
    static int validateChoice(bsl::ostream *logStream, const TYPE& value);
        // Determine if the specified 'value' satisfies the requirements for
        // encoding using this component.  If the 'value' meets the encoding
        // requirements, return 0, otherwise load an unspecified,
        // human-readable description of the requirements that are not
        // satisfied by the 'value' to the specified 'logStream' and return a
        // non-zero value.  The 'value' is required to not have an undefined
        // 'selectionId'.

             // Encoding Values That Have Specific Type Categories

    static int encodeCharArray(Formatter                *formatter,
                               const bsl::vector<char>&  value,
                               const EncoderOptions&     options);
        // Encode the JSON representation of the specified 'value' to the
        // specified JSON 'formatter'.  Use the specified 'options' to
        // configure aspects of the JSON representation of the 'value'.  Return
        // 0 on success, and a non-zero value otherwise.

    template <class TYPE>
    static int encodeSimpleValue(Formatter             *formatter,
                                 const TYPE&            value,
                                 const EncoderOptions&  options);
        // Encode the JSON representation of the specified 'value' to the
        // specified JSON 'formatter'.  Use the specified 'options' to
        // configure aspects of the JSON representation of the 'value'.  Return
        // 0 on success, and a non-zero value otherwise.  The behavior is
        // undefined unless the specified 'TYPE' satisfies both the static and
        // dynamic requirements of the 'Simple' 'bdlat' type-category concept.
        // See the component-level documentation of {'baljsn_encoderoptions'}
        // for a description of the effects, if any, of each option in the
        // 'options' on the JSON representation of the 'value'.  See the
        // package-level documentation of {'bdlat'} for an introduction to the
        // requirements of 'bdlat' type-category concepts.

                       // Encoding Prefixes and Suffixes

    static void encodeObjectPrefix(bool           *isPrefixEmpty,
                                   Formatter      *formatter,
                                   FormattingMode  formattingMode);
        // If the specified 'formattingMode' does not have the
        // 'bdlat_FormattingMode::e_UNTAGGED' bit set, encode a "left brace"
        // JSON token to the specified 'formatter', and encoding nothing to the
        // 'formatter' otherwise.  If this operation encodes a token to the
        // formatter, load the value 'false' to the specified 'isPrefixEmpty',
        // and the value 'true' otherwise.

    static void encodeObjectSuffix(bool           *isSuffixEmpty,
                                   Formatter      *formatter,
                                   FormattingMode  formattingMode);
        // If the specified 'formattingMode' does not have the
        // 'bdlat_FormattingMode::e_UNTAGGED' bit set, encode a "right brace"
        // JSON token to the specified 'formatter', and encoding nothing to the
        // 'formatter' otherwise.  If this operation encodes a token to the
        // 'formatter', load the value 'false' to the specified
        // 'isSuffixEmpty', and the value 'true' otherwise.

                 // Encoding Arrays That Have Specific Shapes

    static void encodeEmptyArray(Formatter *formatter);
        // Encode the representation of the empty-array JSON value to the
        // specified 'formatter'.

    template <class TYPE>
    static int encodeNonEmptyArray(Formatter             *formatter,
                                   bsl::ostream          *logStream,
                                   const TYPE&            value,
                                   const EncoderOptions&  options);
        // Encode the JSON representation of the specified 'value' to the
        // specified JSON 'formatter'.  Use the specified 'options' to
        // configure aspects of the JSON representation of the 'value'.  If
        // this operation is not successful, load an unspecified,
        // human-readable description of the error condition to the specified
        // 'logStream'.  Return 0 on success, and a non-zero value otherwise.
        // The behavior is undefined unless the 'value' is non-empty and the
        // specified 'TYPE' satisfies both the static and dynamic requirements
        // of the 'Array' 'bdlat' type-category concept.  See the
        // component-level documentation of {'baljsn_encoderoptions'} for a
        // description of the effects, if any, of each option in the 'options'
        // on the JSON representation of the 'selection'.  See the
        // package-level documentation of {'bdlat'} for an introduction to the
        // requirements of 'bdlat' type-category concepts.

                        // Encoding Generalized Members

    static int encodeMember(bool                      *isMemberEmpty,
                            Formatter                 *formatter,
                            bsl::ostream              *logStream,
                            const bsl::string_view&    memberName,
                            const bsl::vector<char>&   member,
                            FormattingMode             formattingMode,
                            const EncoderOptions&      options,
                            bool                       isFirstMember,
                            bdlat_TypeCategory::Array  category);
    template <class TYPE>
    static int encodeMember(bool                      *isMemberEmpty,
                            Formatter                 *formatter,
                            bsl::ostream              *logStream,
                            const bsl::string_view&    memberName,
                            const TYPE&                member,
                            FormattingMode             formattingMode,
                            const EncoderOptions&      options,
                            bool                       isFirstMember,
                            bdlat_TypeCategory::Array  category);
    template <class TYPE, class OTHER_CATEGORY>
    static int encodeMember(bool                     *isMemberEmpty,
                            Formatter                *formatter,
                            bsl::ostream             *logStream,
                            const bsl::string_view&   memberName,
                            const TYPE&               member,
                            FormattingMode            formattingMode,
                            const EncoderOptions&     options,
                            bool                      isFirstMember,
                            OTHER_CATEGORY            category);
        // Encode the JSON representation of the specified object 'member'
        // having the specified 'memberName' to the specified JSON 'formatter',
        // according to the specified 'formattingMode'.  If the representation
        // contains no text, load the value 'true' to 'isMemberEmpty' and the
        // value 'false' otherwise.  If the specified 'isFirstMember' option is
        // 'true', then the representation of the member contains no leading
        // sequence delimiter, and does contain such a delimiter otherwise.
        // Use the specified 'options' to configure aspects of the JSON
        // representation of the 'member'.  If this operation is not
        // successful, load an unspecified, human-readable description of the
        // error condition to the specified 'logStream'.  Return 0 on success,
        // and a non-zero value otherwise.  The behavior is undefined unless
        // the specified 'TYPE' satisfies both the static and dynamic
        // requirements of the specified 'category' 'bdlat' type-category
        // concept.  See the component-level documentation of
        // {'baljsn_encoderoptions'} for a description of the effects, if any,
        // of each option in the 'options' on the JSON representation of the
        // 'selection'.  See the package-level documentation of {'bdlat'} for
        // an introduction to the requirements of 'bdlat' type-category
        // concepts.

    static int encodeMemberPrefix(Formatter                *formatter,
                                  bsl::ostream             *logStream,
                                  const bsl::string_view&   memberName,
                                  bool                      isFirstMember);
    static int encodeMemberPrefix(Formatter                *formatter,
                                  bsl::ostream             *logStream,
                                  const bsl::string_view&   memberName,
                                  FormattingMode            formattingMode,
                                  bool                      isFirstMember);
    static int encodeMemberPrefix(bool                     *isPrefixEmpty,
                                  Formatter                *formatter,
                                  bsl::ostream             *logStream,
                                  const bsl::string_view&   memberName,
                                  FormattingMode            formattingMode,
                                  bool                      isFirstMember);
        // If the specified 'isFirstMember' flag is 'false', encode a "comma"
        // JSON token to the specified 'formatter', and do not encode a "comma"
        // JSON token otherwise.  If the specified 'formattingMode' does not
        // have the 'bdlat_FormattingMode::e_UNTAGGED' bit set, encode a JSON
        // "string" token having the specified 'memberName' contents, and
        // encode a JSON "colon" token after the string, and do not encode
        // these tokens otherwise.  If this operation is not successful, load
        // an unspecified, human-readable description of the error condition to
        // the specified 'logStream'.  Optionally specify 'isPrefixEmpty'.  If
        // this operation encodes a token to the formatter, load the value
        // 'false' to 'isPrefixEmpty' if specified, and the value 'true'
        // otherwise.  Return 0 on success, and a non-zero value otherwise.
};

                        // ===========================
                        // struct Encoder_ValueVisitor
                        // ===========================

class Encoder_ValueVisitor {
    // this component-private class provides a function object used to encode
    // values that satisfy one of the 'bdlat' type-category concepts.
    //
    // This class's constructor closes over the 'formatter', 'logStream',
    // and 'options'  parameters that are shared between all encoding
    // operations provided in this component.  The function-call operator of
    // this class provides an overload set that accepts an object that
    // satisfies one of the 'bdlat' type-category concepts, and a
    // 'bdlat_TypeCategory' tag type that corresponds to the object's 'bdlat'
    // type category.  Each function-call-operator overload encodes a JSON
    // representation of the specified value to the 'formatter' supplied on
    // construction.

  public:
    // TYPES
    typedef int FormattingMode;
        // 'FormattingMode' is an alias to the type of an 'int'-valued
        // 'bdlat_FormattingMode' bit-field.  A 'FormattingMode' value is not
        // valid unless it is equal to an enumerator of 'bdlat_FormattingMode'
        // or a valid bitwise-or of two or more such enumerators.  See the
        // component-level documentation of {'bdlat_formattingmode'} for a
        // description of the set of valid formatting-mode values.

  private:
    // DATA
    Formatter            *d_formatter_p;
        // wrapper around the output stream that determines the whitespace to
        // emit around each JSON token

    bsl::ostream         *d_logStream_p;
        // human-readable descriptions of all encountered error conditions

    const EncoderOptions *d_options_p;
        // options set by the caller of the encoding operation that controls
        // some aspects of the token sequence to emit

  public:
    // CREATORS
    Encoder_ValueVisitor(Formatter             *formatter,
                         bsl::ostream          *logStream,
                         const EncoderOptions&  options);
        // Construct an 'Encoder_ValueVisitor' object having the specified
        // 'formatter', 'logStream', and 'options' attributes.

    int operator()(bool                      *isNextObjectFirst,
                   const bsl::vector<char>&   value,
                   FormattingMode             formattingMode,
                   bool                       isFirstSubObject,
                   bdlat_TypeCategory::Array  category) const;
    template <class TYPE>
    int operator()(bool                      *isNextObjectFirst,
                   const TYPE&                value,
                   FormattingMode             formattingMode,
                   bool                       isFirstSubObject,
                   bdlat_TypeCategory::Array  category) const;
    template <class TYPE>
    int operator()(bool                       *isNextObjectFirst,
                   const TYPE&                 value,
                   FormattingMode              formattingMode,
                   bool                        isFirstSubObject,
                   bdlat_TypeCategory::Choice  category) const;
    template <class TYPE>
    int operator()(bool                               *isNextObjectFirst,
                   const TYPE&                         value,
                   FormattingMode                      formattingMode,
                   bool                                isFirstSubObject,
                   bdlat_TypeCategory::CustomizedType  category) const;
    template <class TYPE>
    int operator()(bool                            *isNextObjectFirst,
                   const TYPE&                      value,
                   FormattingMode                   formattingMode,
                   bool                             isFirstSubObject,
                   bdlat_TypeCategory::Enumeration  category) const;
    template <class TYPE>
    int operator()(bool                              *isNextObjectFirst,
                   const TYPE&                        value,
                   FormattingMode                     formattingMode,
                   bool                               isFirstSubObject,
                   bdlat_TypeCategory::NullableValue  category) const;
    template <class TYPE>
    int operator()(bool                         *isNextObjectFirst,
                   const TYPE&                   value,
                   FormattingMode                formattingMode,
                   bool                          isFirstSubObject,
                   bdlat_TypeCategory::Sequence  category) const;
    template <class TYPE>
    int operator()(bool                       *isNextObjectFirst,
                   const TYPE&                 value,
                   FormattingMode              formattingMode,
                   bool                        isFirstSubObject,
                   bdlat_TypeCategory::Simple  category) const;
        // Encode the JSON representation of the specified 'value' to the JSON
        // 'formatter' attribute of this object, according to the specified
        // 'formattingMode'.  If the representation contains no text and the
        // specified 'isFirstSubObject' is 'true', load the value 'true' into
        // the specified 'isNextObjectFirst', and the value 'false' otherwise.
        // If 'isFirstSubObject' is 'true', then the representation of the
        // value contains no leading sequence delimiter, and does contain such
        // a delimiter otherwise.  The 'options' attribute of this object
        // configures aspects of the JSON representation of the 'value'.  If
        // this operation is not successful, load an unspecified,
        // human-readable description of the error condition to the 'logStream'
        // attribute of this object.  Return 0 on success, and a non-zero value
        // otherwise.  The behavior is undefined unless the specified 'TYPE'
        // satisfies both the static and dynamic requirements of the specified
        // 'category' 'bdlat' type-category concept.  See the component-level
        // documentation of {'baljsn_encoderoptions'} for a description of the
        // effects, if any, of each option in the 'options' on the JSON
        // representation of the 'value'.  See the package-level documentation
        // of {'bdlat'} for an introduction to the requirements of 'bdlat'
        // type-category concepts.

    template <class TYPE>
    int operator()(bool           *,
                   const TYPE&,
                   FormattingMode,
                   bool,
                   bslmf::Nil) const;
        // The behavior of this function is undefined.
};

                        // ============================
                        // class Encoder_ElementVisitor
                        // ============================

class Encoder_ElementVisitor {
    // This component-private class provides a function object that closes over
    // the 'formatter', 'logStream', and 'options' parameters that are shared
    // between all encoding operations provided in this component.  The
    // function-call operator of this class provides an overload set that
    // accepts an "element" object that satisfies one of the 'bdlat'
    // type-category concepts, and an optional 'bdlat_TypeCategory' tag type
    // that corresponds to the element's 'bdlat' type category.  Each
    // function-call-operator overload encodes a JSON representation of the
    // specified selection to the 'formatter' supplied on construction.

    // DATA
    Formatter            *d_formatter_p;
        // wrapper around the output stream that determines the whitespace to
        // emit around each JSON token

    bsl::ostream         *d_logStream_p;
        // human-readable descriptions of all encountered error conditions

    const EncoderOptions *d_options_p;
        // options set by the caller of the encoding operation that controls
        // some aspects of the token sequence to emit

  public:
    // CREATORS
    Encoder_ElementVisitor(Formatter             *formatter,
                           bsl::ostream          *logStream,
                           const EncoderOptions&  options);
        // Construct an 'Encoder_ValueVisitor' object having the specified
        // 'formatter', 'logStream', and 'options' attributes.

    // ACCESSORS
    template <class INFO>
    int operator()(bool                      *isNextElementFirst,
                   const bsl::vector<char>&   element,
                   bool                       isFirstElement,
                   bdlat_TypeCategory::Array  category) const;
    template <class TYPE>
    int operator()(bool                      *isNextElementFirst,
                   const TYPE&                element,
                   bool                       isFirstElement,
                   bdlat_TypeCategory::Array  category) const;
    template <class TYPE>
    int operator()(bool                       *isNextElementFirst,
                   const TYPE&                 element,
                   bool                        isFirstElement,
                   bdlat_TypeCategory::Choice  category) const;
    template <class TYPE>
    int operator()(bool                               *isNextElementFirst,
                   const TYPE&                         element,
                   bool                                isFirstElement,
                   bdlat_TypeCategory::CustomizedType  category) const;
    template <class TYPE>
    int operator()(bool                            *isNextElementFirst,
                   const TYPE&                      element,
                   bool                             isFirstElement,
                   bdlat_TypeCategory::Enumeration  category) const;
    template <class TYPE>
    int operator()(bool                              *isNextElementFirst,
                   const TYPE&                        element,
                   bool                               isFirstElement,
                   bdlat_TypeCategory::NullableValue  category) const;
    template <class TYPE>
    int operator()(bool                         *isNextElementFirst,
                   const TYPE&                   element,
                   bool                          isFirstElement,
                   bdlat_TypeCategory::Sequence  category) const;
    template <class TYPE>
    int operator()(bool                       *isNextElementFirst,
                   const TYPE&                 element,
                   bool                        isFirstElement,
                   bdlat_TypeCategory::Simple  category) const;
        // Encode the JSON representation of the specified 'value' to the JSON
        // 'formatter' attribute of this object, according to the specified
        // 'formattingMode'.  If the representation contains no text and the
        // specified 'isFirstElement' is 'true', load the value 'true' into
        // the specified 'isNextElementFirst', and the value 'false' otherwise.
        // If 'isFirstElement' is 'true', then the representation of the
        // value contains no leading sequence delimiter, and does contain such
        // a delimiter otherwise.  The 'options' attribute of this object
        // configures aspects of the JSON representation of the 'value'.  If
        // this operation is not successful, load an unspecified,
        // human-readable description of the error condition to the 'logStream'
        // attribute of this object.  Return 0 on success, and a non-zero value
        // otherwise.  The behavior is undefined unless the specified 'TYPE'
        // satisfies both the static and dynamic requirements of the specified
        // 'category' 'bdlat' type-category concept.  See the component-level
        // documentation of {'baljsn_encoderoptions'} for a description of the
        // effects, if any, of each option in the 'options' on the JSON
        // representation of the 'value'.  See the package-level documentation
        // of {'bdlat'} for an introduction to the requirements of 'bdlat'
        // type-category concepts.

    template <class TYPE>
    int operator()(bool *, const TYPE&, bool, bslmf::Nil) const;
        // The behavior of this function is undefined.
};

                       // ==============================
                       // class Encoder_SelectionVisitor
                       // ==============================

class Encoder_SelectionVisitor {
    // This component-private class provides a function object that closes over
    // the 'formatter', 'logStream', and 'options' parameters that are shared
    // between all encoding operations provided in this component.  The
    // function-call operator of this class provides an overload set that
    // accepts a "selection" object that satisfies one of the 'bdlat'
    // type-category concepts, and an optional 'bdlat_TypeCategory' tag type
    // that corresponds to the selections's 'bdlat' type category.  Each
    // function-call-operator overload encodes a JSON representation of the
    // specified selection to the 'formatter' supplied on construction.

  public:
    // TYPES
    typedef int FormattingMode;
        // 'FormattingMode' is an alias to the type of an 'int'-valued
        // 'bdlat_FormattingMode' bit-field.  A 'FormattingMode' value is not
        // valid unless it is equal to an enumerator of 'bdlat_FormattingMode'
        // or a valid bitwise-or of two or more such enumerators.  See the
        // component-level documentation of {'bdlat_formattingmode'} for a
        // description of the set of valid formatting-mode values.

  private:
    // DATA
    Formatter            *d_formatter_p;
        // wrapper around the output stream that determines the whitespace to
        // emit around each JSON token

    bsl::ostream         *d_logStream_p;
        // human-readable descriptions of all encountered error conditions

    const EncoderOptions *d_options_p;
        // options set by the caller of the encoding operation that controls
        // some aspects of the token sequence to emit

  public:
    // CREATORS
    Encoder_SelectionVisitor(Formatter             *formatter,
                             bsl::ostream          *logStream,
                             const EncoderOptions&  options);
        // Construct an 'Encoder_SelectionVisitor' object having the specified
        // 'formatter', 'logStream', and 'options' attributes.

    // ACCESSORS
    template <class TYPE, class SELECTION_INFO>
    int operator()(bool                               *isNextObjectFirst,
                   const TYPE&                         selection,
                   const SELECTION_INFO&               selectionInfo,
                   bool                                isFirstSubObject,
                   bdlat_TypeCategory::CustomizedType  category) const;
    template <class TYPE, class SELECTION_INFO, class CATEGORY>
    int operator()(bool                  *isNextObjectFirst,
                   const TYPE&            selection,
                   const SELECTION_INFO&  selectionInfo,
                   bool                   isFirstSubObject,
                   CATEGORY               category) const;
        // Encode the JSON representation of the specified 'selection', having
        // the name equal to the 'name' attribute of the specified
        // 'selectionInfo' to the JSON 'formatter' attribute of this object,
        // according to the specified 'formattingMode'.  If the representation
        // contains no text and 'isFirstSubObject' is 'true', load the value
        // 'true' into the specified 'isNextObjectFirst', and the value 'false'
        // otherwise.  If 'isFirstSubObject' is 'true', then the representation
        // of the selection contains no leading sequence delimiter, and does
        // contain such a delimiter otherwise.  The 'options' attribute of this
        // object configures aspects of the JSON representation of the
        // 'selection'.  If this operation is not successful, load an
        // unspecified, human-readable description of the error condition to
        // the 'logStream' attribute of this object.  Return 0 on success, and
        // a non-zero value otherwise.  The behavior is undefined unless the
        // 'selection' satisfies both the static and dynamic requirements of
        // the 'bdlat' type-category concept corresponding to the specified
        // 'category'.  See the component-level documentation of
        // {'baljsn_encoderoptions'} for a description of the effects, if any,
        // of each option in the 'options' on the JSON representation of the
        // 'selection'.  See the package-level documentation of {'bdlat'} for
        // an introduction to the requirements of 'bdlat' type-category
        // concepts.

    template <class TYPE, class SELECTION_INFO>
    int operator()(bool                  *,
                   const TYPE&,
                   const SELECTION_INFO&,
                   bool,
                   bslmf::Nil) const;
        // The behavior of this function is undefined.
};

                       // ==============================
                       // class Encoder_AttributeVisitor
                       // ==============================

class Encoder_AttributeVisitor {
    // This component-private class provides a function object that closes over
    // the 'formatter', 'logStream', and 'options'  parameters that are shared
    // between all encoding operations provided in this component.  The
    // function-call operator of this class provides an overload set that
    // accepts an "attribute" object that satisfies one of the 'bdlat'
    // type-category concepts, and an optional 'bdlat_TypeCategory' tag type
    // that corresponds to the attribute's 'bdlat' type category.  Each
    // function-call-operator overload encodes a JSON representation of the
    // specified attribute to the 'formatter' supplied on construction.

  public:
    // TYPES
    typedef int FormattingMode;
        // 'FormattingMode' is an alias to the type of an 'int'-valued
        // 'bdlat_FormattingMode' bit-field.  A 'FormattingMode' value is not
        // valid unless it is equal to an enumerator of 'bdlat_FormattingMode'
        // or a valid bitwise-or of two or more such enumerators.  See the
        // component-level documentation of {'bdlat_formattingmode'} for a
        // description of the set of valid formatting-mode values.

  private:
    // DATA
    Formatter            *d_formatter_p;
        // wrapper around the output stream that determines the whitespace to
        // emit around each JSON token

    bsl::ostream         *d_logStream_p;
        // human-readable descriptions of all encountered error conditions

    const EncoderOptions *d_options_p;
        // options set by the caller of the encoding operation that controls
        // some aspects of the token sequence to emit

  public:
    // CREATORS
    Encoder_AttributeVisitor(Formatter             *formatter,
                             bsl::ostream          *logStream,
                             const EncoderOptions&  options);
        // Construct an 'Encoder_AttributeVisitor' object having the specified
        // 'formatter', 'logStream', and 'options' attributes.

    // ACCESSORS
    template <class ATTRIBUTE_INFO>
    int operator()(bool                      *isNextAttributeFirst,
                   const bsl::vector<char>&   attribute,
                   const ATTRIBUTE_INFO&      attributeInfo,
                   bool                       isFirstAttribute,
                   bdlat_TypeCategory::Array  category) const;
    template <class TYPE, class ATTRIBUTE_INFO>
    int operator()(bool                      *isNextAttributeFirst,
                   const TYPE&                attribute,
                   const ATTRIBUTE_INFO&      attributeInfo,
                   bool                       isFirstAttribute,
                   bdlat_TypeCategory::Array  category) const;
    template <class TYPE, class ATTRIBUTE_INFO>
    int operator()(bool                               *isNextAttributeFirst,
                   const TYPE&                         attribute,
                   const ATTRIBUTE_INFO&               attributeInfo,
                   bool                                isFirstAttribute,
                   bdlat_TypeCategory::CustomizedType  category) const;
    template <class TYPE, class ATTRIBUTE_INFO>
    int operator()(bool                              *isNextAttributeFirst,
                   const TYPE&                        attribute,
                   const ATTRIBUTE_INFO&              attributeInfo,
                   bool                               isFirstAttribute,
                   bdlat_TypeCategory::NullableValue  category) const;
    template <class TYPE, class ATTRIBUTE_INFO, class CATEGORY>
    int operator()(bool                  *isNextAttributeFirst,
                   const TYPE&            attribute,
                   const ATTRIBUTE_INFO&  attributeInfo,
                   bool                   isFirstAttribute,
                   CATEGORY               category) const;
        // Encode the JSON representation of the specified 'attribute', having
        // the name equal to the 'name' of the specified 'attributeInfo', to
        // the JSON 'formatter' attribute of this object according to the
        // specified 'formattingMode'.  If the representation contains no text
        // and the specified 'isFirstAttribute' is 'true', load the value
        // 'true' into the specified 'isNextAttributeFirst' , and the value
        // 'false' otherwise.  If 'isFirstAttribute' is 'true', then the
        // representation of the attribute contains no leading sequence
        // delimiter, and does contain such a delimiter otherwise.  The
        // 'options' attribute of this object configures aspects of the JSON
        // representation of the 'attribute'.  If this operation is not
        // successful, load an unspecified, human-readable description of the
        // error condition to the 'logStream' attribute of this object.  Return
        // 0 on success, and a non-zero value otherwise.  The behavior is
        // undefined unless the 'attribute' satisfies both the static and
        // dynamic requirements of the 'bdlat' type-category concept
        // corresponding to the specified 'category'.  See the component-level
        // documentation of {'baljsn_encoderoptions'} for a description of the
        // effects, if any, of each option in the 'options' on the JSON
        // representation of the 'attribute'.  See the package-level
        // documentation of {'bdlat'} for an introduction to the requirements
        // of 'bdlat' type-category concepts.

    template <class TYPE, class ATTRIBUTE_INFO>
    int operator()(bool                  *,
                   const TYPE&,
                   const ATTRIBUTE_INFO&,
                   bool,
                   bslmf::Nil) const;
        // The behavior of this function is undefined.
};

                      // ===============================
                      // struct Encoder_TypeCategoryUtil
                      // ===============================

struct Encoder_TypeCategoryUtil {
    // This component-private struct provides a namespace for utilty functions
    // for inspecting 'bdlat'-compatible objects by their type category.

    // CLASS METHODS
    template <class OUTPUT, class TYPE, class FUNCTION, class INFO_1>
    static int transformByCategory(OUTPUT          *output,
                                   const TYPE&      object,
                                   const FUNCTION&  function,
                                   const INFO_1&    info1);
        // Invoke the specified 'function' with the specified 'output',
        // 'object', 'info1', and the type category tag for the specified
        // 'object'.  Return the result of the invocation of 'function'.  This
        // function template requires that the specified 'OUTPUT' type is a
        // value-semantic type, the specified 'TYPE' type is
        // 'bdlat'-compatible, and the specified 'FUNCTION' type is invocable
        // as if it had the following signature:
        //..
        //  int function(OUTPUT        *output,
        //               const TYPE&    object,
        //               const INFO_1&  info1,
        //               TYPE_CATEGORY  category);
        //      // Compute a value based on the specified 'object', 'info1',
        //      // and 'category', and load the value to the object addressed
        //      // by the specified 'output'.  Return 0 on success, and a
        //      // non-zero value otherwise.  In the event of failure, the
        //      // 'output' is left in a valid but unspecified state.
        //..
        // where 'TYPE_CATEGORY' is the 'bdlat' category tag type for 'TYPE'.

    template <class OUTPUT,
              class TYPE,
              class FUNCTION,
              class INFO_1,
              class INFO_2>
    static int transformByCategory(OUTPUT          *output,
                                   const TYPE&      object,
                                   const FUNCTION&  function,
                                   const INFO_1&    info1,
                                   const INFO_2&    info2);
        // Invoke the specified 'function' with the specified 'output',
        // 'object', 'info1', 'info2', and the type category tag for the
        // specified 'object'.  Return the result of the invocation of
        // 'function'.  This function template requires that the specified
        // 'OUTPUT' type is a value-semantic type, the specified 'TYPE' type is
        // 'bdlat'-compatible, and the specified 'FUNCTION' type is invocable
        // as if it had the following signature:
        //..
        //  int function(OUTPUT        *output,
        //               const TYPE&    object,
        //               const INFO_1&  info1,
        //               const INFO_2&  info2,
        //               TYPE_CATEGORY  category);
        //      // Compute a value based on the specified 'object', 'info1',
        //      // 'info2', and 'category', and load the value to the object
        //      // addressed by the specified 'output'.  Return 0 on success,
        //      // and a non-zero value otherwise.  In the event of failure,
        //      // the 'output' is left in a valid but unspecified state.  This
        //      // operation requires that the specified 'TYPE_CATEGORY' is a
        //      // 'bdlat' type-category tag type.
        //..
        // where 'TYPE_CATEGORY' is the 'bdlat' category tag type for 'TYPE'.
};

                          // ========================
                          // struct Encoder_ArrayUtil
                          // ========================

struct Encoder_ArrayUtil {
    // This component-private struct provides a namespace for utility functions
    // for inspecting 'bdlat' "array" objects by their type category.

    // CLASS METHODS
    template <class TYPE, class ACCESSOR>
    static int accessElementByCategory(const TYPE& array,
                                       ACCESSOR&   accessor,
                                       int         index);
        // Invoke the specified 'accessor' with the non-modifiable element at
        // the specified 'index' of the specified 'array', and the type
        // category tag for the element.  The behavior is undefined unless '0
        // <= index' and 'index < bdlat_arraySize(array)'.  Return the result
        // of the invocation of 'accessor'.  This function template requires
        // that the specified 'TYPE' is a 'bdlat' "array" type and the
        // specified 'ACCESSOR' type is invocable as if it had the following
        // signature:
        //..
        //  int accessor(const ELEMENT_TYPE& element,
        //               TYPE_CATEGORY       category);
        //      // Perform an action using the specified 'element' and
        //      // 'category'.  Return 0 on success, and a non-zero value
        //      // otherwise.  This operation requires that the specified
        //      // 'ELEMENT_TYPE' is a 'bdlat'-compatible type and the
        //      // specified 'TYPE_CATEGORY' is a 'bdlat' type-category tag
        //      // type.
        //..
        // where 'TYPE_CATEGORY' is the 'bdlat' category tag type for the
        // element type of 'TYPE'.

    template <class OUTPUT, class TYPE, class FUNCTION, class INFO_1>
    static int transformElementByCategory(OUTPUT          *output,
                                          const TYPE&      array,
                                          const FUNCTION&  function,
                                          const INFO_1&    info1,
                                          int              index);
        // Invoke the specified 'function' with the specified 'output', the
        // non-modifiable element at the specified 'index' of the specified
        // 'array', the specified 'info1', and the type category tag for the
        // element.  Return the result of the invocation of 'function'.  This
        // function template requires that the specified 'OUTPUT' type is a
        // value-semantic type, the specified 'TYPE' type is
        // 'bdlat' "array" type, and the specified 'FUNCTION' type is invocable
        // as if it had the following signature:
        //..
        //  int function(OUTPUT        *output,
        //               const TYPE&    object,
        //               const INFO_1&  info1,
        //               TYPE_CATEGORY  category);
        //      // Compute a value based on the specified 'object', 'info1',
        //      // and 'category', and load the value to the object addressed
        //      // by the specified 'output'.  Return 0 on success, and a
        //      // non-zero value otherwise.  In the event of failure, the
        //      // 'output' is left in a valid but unspecified state.
        //..
        // where 'TYPE_CATEGORY' is the 'bdlat' category tag type for the
        // element.

    template <class OUTPUT, class TYPE, class FUNCTION>
    static int foldElementsByCategory(OUTPUT          *output,
                                      const TYPE&      array,
                                      const FUNCTION&  function,
                                      const OUTPUT&    initial);
        // Invoke the specified 'function' sequentially on each element of the
        // specified 'array', supplying 'function' with the specified 'output'
        // pointer, the element, and the value loaded to 'output' on the
        // previous invocation (or 'initial' when on the first element), and
        // the type category tag for the element, until such invocation returns
        // a non-zero value.  Return the value from the last invocation of
        // 'function'.  This function template requires that the specified
        // 'TYPE' is a 'bdlat' "array" type, the specified 'OUTPUT' is a
        // value-semantic type, and the specified 'FUNCTION' type is invocable
        // as if it had the following signature:
        //..
        //  int function(OUTPUT              *output,
        //               const ELEMENT_TYPE&  element,
        //               const OUTPUT&        currentFoldValue,
        //               TYPE_CATEGORY        category);
        //      // Compute a value based on the specified 'element',
        //      // 'currentFoldValue', and 'category', and load the value to
        //      // the specified 'output'.  Return 0 on success, and a non-zero
        //      // value otherwise.  In the event of failure, the 'output' is
        //      // left in a valid but unspecified state.  This operation
        //      // requires that the specified 'TYPE_CATEGORY' is a 'bdlat'
        //      // type-category tag type.
        //..
        // where 'TYPE_CATEGORY' is the 'bdlat' category tag type for the
        // element.
};

                         // =========================
                         // struct Encoder_ChoiceUtil
                         // =========================

struct Encoder_ChoiceUtil {
    // This component-private struct provides a namespace for utility functions
    // for inspecting 'bdlat' "choice" objects by their type category.

    // CLASS METHODS
    template <class TYPE, class ACCESSOR>
    static int accessSelectionByCategory(const TYPE& choice,
                                         ACCESSOR&   accessor);
        // Invoke the specified 'accessor' with the selection of the specified
        // 'choice', the selection info of the 'choice', and the type category
        // tag for the selection of the 'choice'.  Return the result of the
        // invocation of 'accessor'.  This function template requires that the
        // specified 'TYPE' is a 'bdlat' "choice" type and the specified
        // 'ACCESSOR' type is invocable as if it had the following signature:
        //..
        //  int accessor(const SELECTION_TYPE& selection,
        //               const SELECTION_INFO& selectionInfo,
        //               TYPE_CATEGORY         category);
        //      // Perform an action using the specified 'selection',
        //      // 'selectionInfo', and 'category'.  Return 0 on success, and a
        //      // non-zero value otherwise.  This operation requires that the
        //      // specified 'SELECTION_TYPE' is a 'bdlat'-compatible type and
        //      // the specified 'TYPE_CATEGORY' is a 'bdlat' type-category tag
        //      // type.
        //..
        // where 'TYPE_CATEGORY' is the 'bdlat' category tag type for the
        // element type of 'TYPE'.

    template <class OUTPUT, class TYPE, class FUNCTION, class INFO_1>
    static int transformSelectionByCategory(OUTPUT          *output,
                                            const TYPE&      choice,
                                            const FUNCTION&  function,
                                            const INFO_1&    info1);
        // Invoke the specified 'function' with the specified 'output', the
        // selection of the specified 'choice', the selection info of the
        // 'choice', the specified 'info1', and the type category tag for the
        // selection of the 'choice'.  Return the result of the invocation of
        // 'function'.  This function template requires that the specified
        // 'OUTPUT' type is a value-semantic type, the specified 'TYPE' is a
        // 'bdlat' "choice" type, and the specified 'FUNCTION' type is
        // invocable as if it had the following signature:
        //..
        //  int function(OUTPUT                *output,
        //               const SELECTION&       selection,
        //               const SELECTION_INFO&  selectionInfo
        //               const INFO_1&          info1,
        //               TYPE_CATEGORY          category);
        //      // Compute a value based on the specified 'selection',
        //      // 'selectionInfo', 'info1', and 'category', and load the value
        //      // to the specified 'output'.  Return 0 on success, and a
        //      // non-zero value otherwise.  In the event of failure, the
        //      // 'output' is left in a valid but unspecified state.  This
        //      // operation requires that the specified 'TYPE_CATEGORY' is a
        //      // 'bdlat' type-category tag type.
        //..
        // where 'TYPE_CATEGORY' is the 'bdlat' category tag type for the
        // element type of 'TYPE'.

};

                      // ================================
                      // struct Encoder_NullableValueUtil
                      // ================================

struct Encoder_NullableValueUtil {
    // This component-private struct provides a namespace for utility functions
    // for inspecting 'bdlat' "nullable value" objects by their type category.

    // CLASS METHODS
    template <class TYPE, class ACCESSOR>
    static int accessValueByCategory(const TYPE& nullableValue,
                                     ACCESSOR&   accessor);
        // Invoke the specified 'accessor' with the value stored in the
        // specified 'nullableValue' and the type category tag for the value
        // stored in 'nullableValue'.  Return the result of the invocation
        // of 'accessor'.  This function template requires that the specified
        // 'TYPE' is a 'bdlat' "nullable value" type and the specified
        // 'ACCESSOR' type is invocable as if it had the following signature:
        //..
        //  int accessor(const VALUE_TYPE& value,
        //               TYPE_CATEGORY     category);
        //      // Perform an action using the specified 'value' and
        //      // 'category'.  Return 0 on success, and a non-zero value
        //      // otherwise.  This operation requires that the specified
        //      // 'TYPE_CATEGORY' is a 'bdlat' type-category tag type.
        //..
        // where 'TYPE_CATEGORY' is the 'bdlat' category tag type for the
        // underlying value type of 'TYPE'.  The behavior is undefined if
        // 'nullableValue' contains the null value.

    template <class OUTPUT, class TYPE, class FUNCTION, class INFO_1>
    static int transformValueByCategory(OUTPUT          *output,
                                        const TYPE&      nullableValue,
                                        const FUNCTION&  function,
                                        const INFO_1&    info1);
        // Invoke the specified 'function' with the specified 'output', the
        // value stored in the specified 'nullableValue', the specified
        // 'info_1', and the type category tag for the value stored in
        // 'nullableValue'.  Return the result of the invocation of 'function'.
        // This function template requires that the specified 'OUTPUT" type is
        // a value-semantic type, the specified 'TYPE' is a 'bdlat' "nullable
        // value" type, and the specified 'FUNCTION' type is invocable as if it
        // had the following signature:
        //..
        //  int function(OUTPUT            *output,
        //               const VALUE_TYPE&  value,
        //               const INFO&        info,
        //               TYPE_CATEGORY      category);
        //      // Compute a value based on the specified 'value', 'info', and
        //      // 'category', and load the value to the specified 'output'.
        //      // Return 0 on success, and a non-zero value otherwise.  In the
        //      // event of failure, the 'output' is left in a valid but
        //      // unspecified state.  This operation requires that the
        //      // specified 'TYPE_CATEGORY' is a 'bdlat' type-category tag
        //      // type.
        //..
        // where 'TYPE_CATEGORY' is the 'bdlat' category tag type for the
        // underlying value type of 'TYPE'.  The behavior is undefined if
        // 'nullableValue' contains the null value.

    template <class OUTPUT,
              class TYPE,
              class FUNCTION,
              class INFO_1,
              class INFO_2>
    static int transformValueByCategory(OUTPUT          *output,
                                        const TYPE&      nullableValue,
                                        const FUNCTION&  function,
                                        const INFO_1&    info1,
                                        const INFO_2&    info2);
        // Invoke the specified 'function' with the specified 'output',
        // the value stored in the specified 'nullableValue', the specified
        // 'info_1', 'info_2', and the type category tag for the value stored
        // in 'nullableValue'.  Return the result of the invocation of
        // 'function'.  This function template requires that the specified
        // 'OUTPUT' type is a value-semantic type, the specified 'TYPE' is a
        // 'bdlat' "nullable value" type, and the specified 'FUNCTION' type is
        // invocable as if it had the following signature:
        //..
        //  int function(OUTPUT            *output,
        //               const VALUE_TYPE&  value,
        //               const INFO_1&      info,
        //               const INFO_2&      info2,
        //               TYPE_CATEGORY      category);
        //      // Compute a value based on the specified 'value', 'info_1',
        //      // 'info_2', and 'category', and load the value to the
        //      // specified 'output'.  Return 0 on success, and a non-zero
        //      // value otherwise.  In the event of failure, the 'output' is
        //      // left in a valid but unspecified state.  This operation
        //      // requires that the specified 'TYPE_CATEGORY' is a 'bdlat'
        //      // type-category tag type.
        //..
        // where 'TYPE_CATEGORY' is the 'bdlat' category tag type for the
        // underlying value type of 'TYPE'.  The behavior is undefined if
        // 'nullableValue' contains the null value.

};

                        // ===========================
                        // struct Encoder_SequenceUtil
                        // ===========================

struct Encoder_SequenceUtil {
    // This component-private struct provides a namespace for utility functions
    // for inspecting 'bdlat' "sequence" objects by their type category.

    // CLASS METHODS
    template <class TYPE, class ACCESSOR>
    static int accessAttributesByCategory(const TYPE& sequence,
                                          ACCESSOR&   accessor);
        // Invoke the specified 'accessor' sequentially on each attribute of
        // the specified 'sequence', supplying 'accessor' with the attribute,
        // the corresponding attribute information structure, and type category
        // tag for the attribute.  Return the result of the invocation of
        // 'accessor'.  This function template requires that the specified
        // 'TYPE' is a 'bdlat' "sequence" type and the specified 'ACCESSOR'
        // type is invocable as if it had the following signature:
        //..
        //  int accessor(const ATTRIBUTE_TYPE& attribute,
        //               const ATTRIBUTE_INFO& attributeInfo,
        //               TYPE_CATEGORY         category);
        //      // Perform an action using the specified 'attribute',
        //      // 'attributeInfo', and 'category'.  Return 0 on success, and
        //      // a non-zero value otherwise.  This operation requires that
        //      // the specified 'TYPE_CATEGORY" is a 'bdlat' type-category
        //      // tag type.
        //..
        // where 'TYPE_CATEGORY' is the 'bdlat' category tag type for each
        // corresponding attribute type of 'TYPE'.

    template <class OUTPUT, class TYPE, class FUNCTION>
    static int foldAttributesByCategory(OUTPUT          *output,
                                        const TYPE&      sequence,
                                        const FUNCTION&  function,
                                        const OUTPUT&    initial);
        // Invoke the specified 'function' sequentially on each attribute of
        // the specified 'sequence', supplying 'function' with the specified
        // 'output' pointer, the attribute, the corresponding attribute
        // information structure, the value loaded to 'output' on the previous
        // invocation (or 'initial' when on the first attribute), and the type
        // category tag for the attribute, until such invocation returns a
        // non-zero value.  Return the value from the last invocation of
        // 'function'.  This function template requires that the specified
        // 'TYPE' is a 'bdlat' "sequence" type, the specified 'OUTPUT' is a
        // value-semantic type, and the specified 'FUNCTION' type is invocable
        // as if it had the following siganture:
        //..
        //  int function(OUTPUT                *output,
        //               const ATTRIBUTE_TYPE&  attribute,
        //               const ATTRIBUTE_INFO&  attributeInfo,
        //               const OUTPUT&          currentFoldValue,
        //               TYPE_CATEGORY          category);
        //      // Compute a value based on the specified 'attribute',
        //      // 'attributeInfo', 'currentFoldValue', and 'category', and
        //      // load the value to the specified 'output'.  Return 0 on
        //      // success, and a non-zero value otherwise.  In the event of
        //      // failure, the 'output' is left in a valid but unspecified
        //      // state.  This operation requires that the specified
        //      // 'TYPE_CATEGORY' is a 'bdlat' type-category tag type.
        //..
        // where 'TYPE_CATEGORY' is the 'bdlat' category tag type for each
        // corresponding attribute type of 'TYPE'.
};

            // ===================================================
            // class Encoder_AccessSubObjectByCategoryCb<ACCESSOR>
            // ===================================================

template <class ACCESSOR>
class Encoder_AccessSubObjectByCategoryCb {
    // This component-private class template provides a function-object type
    // that invokes an "accessor" function with a 'bdlat'-compatible value
    // and its 'bdlat' category tag.

    // DATA
    ACCESSOR *d_accessor_p;

  public:
    // CREATORS
    explicit Encoder_AccessSubObjectByCategoryCb(ACCESSOR *accessor);
        // Create an 'Encoder_AccessSubObjectByCategoryCb' object holding the
        // specified 'accessor'.

    // ACCESSORS
    template <class VALUE>
    int operator()(const VALUE& value) const;
        // Invoke the 'accessor' held by this object, supplying the specified
        // 'value' and its 'bdlat' category tag.  Return the result of the
        // invocation.
};

     // =================================================================
     // class Encoder_AccessPropertyByCategoryCb<ACCESSOR, PROPERTY_INFO>
     // =================================================================

template <class ACCESSOR>
class Encoder_AccessPropertyByCategoryCb {
    // This component-private class template provides a function-object type
    // that invokes an "accessor" function with a 'bdlat'-compatible value,
    // a property info 'struct' (e.g., 'bdlat_AttributeInfo' or
    // 'bdlat_SelectionInfo'), and the 'bdlat' category tag of the value.

    // DATA
    ACCESSOR *d_accessor_p;

  public:
    // CREATORS
    explicit Encoder_AccessPropertyByCategoryCb(ACCESSOR *accessor);
        // Create an 'Encoder_AccessPropertyByCategoryCb' object holding the
        // specified 'accessor'.

    // ACCESSORS
    template <class VALUE, class PROPERTY_INFO>
    int operator()(const VALUE&         value,
                   const PROPERTY_INFO& propertyInfo) const;
        // Invoke the 'accessor' held by this object, supplying the specified
        // 'value', its attribute info 'struct', and its 'bdlat' category tag.
        // Return the result of the invocation.
};

    // ====================================================================
    // class Encoder_AccessPropertyByCategoryCbImp<ACCESSOR, PROPERTY_INFO>
    // ====================================================================

template <class ACCESSOR, class PROPERTY_INFO>
class Encoder_AccessPropertyByCategoryCbImp {
    // This component-private class template provides an implementation detail
    // of 'Encoder_AccessPropertyByCategoryCbImp'.

    // DATA
    ACCESSOR            *d_accessor_p;
    const PROPERTY_INFO *d_propertyInfo_p;

  public:
    // CREATORS
    Encoder_AccessPropertyByCategoryCbImp(ACCESSOR            *accessor,
                                          const PROPERTY_INFO *propertyInfo);
        // Create an 'Encoder_AccessPropertyByCategoryCbImp' object holding the
        // specified 'accessor' and 'propertyInfo'.

    // ACCESSORS
    template <class VALUE, class CATEGORY>
    int operator()(const VALUE& value, CATEGORY category) const;
        // Invoke the 'accessor' held by this object, supplying the specified
        // 'value', the 'propertyInfo' held by this object, and the specified
        // 'category'.  Return the result of the invocation.
};

   // =====================================================================
   // class Encoder_TransformByCategoryCb<OUTPUT, FUNCTION, INFO_1, INFO_2>
   // =====================================================================

template <class OUTPUT,
          class FUNCTION,
          class INFO_1 = bslmf::Nil,
          class INFO_2 = bslmf::Nil>
class Encoder_TransformByCategoryCb {
    // This component-private class template provides a function-object type
    // that invokes a function with a 'bdlat'-compatible value, 2 arbitrary
    // "info" arguments, and the 'bdlat' category tag of the value.  The
    // 'function's first argument must be an output argument through which its
    // (non-status code) result is returned.

    // DATA
    OUTPUT         *d_output_p;
    const FUNCTION *d_function_p;
    const INFO_1   *d_info1_p;
    const INFO_2   *d_info2_p;

  public:
    // CREATORS
    Encoder_TransformByCategoryCb(OUTPUT         *output,
                                  const FUNCTION *function,
                                  const INFO_1   *info1,
                                  const INFO_2   *info2);
        // Create an 'Encoder_TransformByCategoryCb' object holding the
        // specified 'output', 'function', 'info1', and 'info2'.

    // ACCESSORS
    template <class VALUE, class CATEGORY>
    int operator()(const VALUE& value, CATEGORY category) const;
        // Invoke the 'accessor' held by this object, supplying the 'output'
        // pointer held by this object, the specified 'value', the 'info1' and
        // 'info2' held by this object, and the specified 'category'.  Return
        // the result of the invocation.
};

       // =============================================================
       // class Encoder_TransformByCategoryCb<OUTPUT, FUNCTION, INFO_1>
       // =============================================================

template <class OUTPUT, class FUNCTION, class INFO_1>
class Encoder_TransformByCategoryCb<OUTPUT, FUNCTION, INFO_1, bslmf::Nil> {
    // This component-private class template provides a function-object type
    // that invokes a function with a 'bdlat'-compatible value, an arbitrary
    // "info" argument, and the 'bdlat' category tag of the value.  The
    // 'function's first argument must be an output argument through which its
    // (non-status code) result is returned.

    // DATA
    OUTPUT         *d_output_p;
    const FUNCTION *d_function_p;
    const INFO_1   *d_info1_p;

  public:
    // CREATORS
    Encoder_TransformByCategoryCb(OUTPUT         *output,
                                  const FUNCTION *function,
                                  const INFO_1   *info1);
        // Create an 'Encoder_TransformByCategoryCb' object holding the
        // specified 'output', 'function', and 'info1'.

    // ACCESSORS
    template <class VALUE, class CATEGORY>
    int operator()(const VALUE& value, CATEGORY category) const;
        // Invoke the 'accessor' held by this object, supplying the 'output'
        // pointer held by this object, the specified 'value', the 'info1'
        // held by this object, and the specified 'category'.  Return the
        // result of the invocation.
};

           // =====================================================
           // class Encoder_TransformByCategoryCb<OUTPUT, FUNCTION>
           // =====================================================

template <class OUTPUT, class FUNCTION>
class Encoder_TransformByCategoryCb<OUTPUT, FUNCTION, bslmf::Nil, bslmf::Nil> {
    // This component-private class template provides a function-object type
    // that invokes a function with a 'bdlat'-compatible value, an arbitrary
    // "info" argument, and the 'bdlat' category tag of the value.  The
    // 'function's first argument must be an output argument through which its
    // (non-status code) result is returned.

    // DATA
    OUTPUT         *d_output_p;
    const FUNCTION *d_function_p;

  public:
    // CREATORS
    Encoder_TransformByCategoryCb(OUTPUT         *output,
                                  const FUNCTION *function);
        // Create an 'Encoder_TransformByCategoryCb' object holding the
        // specified 'output', and 'function'.

    // ACCESSORS
    template <class VALUE, class CATEGORY>
    int operator()(const VALUE& value, CATEGORY category) const;
        // Invoke the 'accessor' held by this object, supplying the 'output'
        // pointer held by this object, the specified 'value', and the
        // specified 'category'.  Return the result of the invocation.
};

// ===========================================================================
// class Encoder_TransformPropertyByCategoryCb<OUTPUT, FUNCTION, PROP, INFO_1>
// ===========================================================================

template <class OUTPUT, class FUNCTION, class INFO_1 = bslmf::Nil>
class Encoder_TransformPropertyByCategoryCb {
    // This component-private class template provides a function-object type
    // that invokes a function with a pointer to an output argument, a
    // 'bdlat'-compatible value, a property info 'struct' (e.g.,
    // 'bdlat_AttributeInfo' or 'bdlat_SelectionInfo'), an arbitrary "info"
    // argument, and the 'bdlat' category tag of the value.

    // DATA
    OUTPUT         *d_output_p;
    const FUNCTION *d_function_p;
    const INFO_1   *d_info1_p;

  public:
    // CREATORS
    Encoder_TransformPropertyByCategoryCb(OUTPUT         *output,
                                          const FUNCTION *function,
                                          const INFO_1   *info1);
        // Create an 'Encoder_TransformPropertyByCategoryCb' object holding the
        // specified 'output', 'function', and 'info1'.

    // ACCESSORS
    template <class VALUE, class PROPERTY_INFO, class CATEGORY>
    int operator()(const VALUE&         value,
                   const PROPERTY_INFO& propertyInfo,
                   CATEGORY             category) const;
        // Invoke the 'function' held by this object, supplying the 'output'
        // pointer held by this object, the specified 'value' and
        // 'propertyInfo', the 'info1' held by this object, and the specified
        // 'category'.  Return the result of the invocation.
};

    // ===================================================================
    // class Encoder_TransformPropertyByCategoryCb<OUTPUT, FUNCTION, PROP>
    // ===================================================================

template <class OUTPUT, class FUNCTION>
class Encoder_TransformPropertyByCategoryCb<OUTPUT, FUNCTION, bslmf::Nil> {
    // This component-private class template provides a function-object type
    // that invokes a function with a pointer to an output argument, a
    // 'bdlat'-compatible value, a property info 'struct' (e.g.,
    // 'bdlat_AttributeInfo' or 'bdlat_SelectionInfo'), and the 'bdlat'
    // category tag of the value.

    // DATA
    OUTPUT         *d_output_p;
    const FUNCTION *d_function_p;

  public:
    // CREATORS
    Encoder_TransformPropertyByCategoryCb(OUTPUT         *output,
                                          const FUNCTION *function);
        // Create an 'Encoder_TransformPropertyByCategoryCb' object holding the
        // specified 'output' and 'function'.

    // ACCESSORS
    template <class VALUE, class PROPERTY_INFO, class CATEGORY>
    int operator()(const VALUE&         value,
                   const PROPERTY_INFO& propertyInfo,
                   CATEGORY             category) const;
        // Invoke the 'function' held by this object, supplying the 'output'
        // pointer held by this object, the specified 'value' and
        // 'propertyInfo', and the specified 'category'.  Return the result of
        // the invocation.
};

   // ======================================================================
   // class Encoder_TransformSubObjectByCategoryCb<OUT, FUN, INFO_1, INFO_2>
   // ======================================================================

template <class OUTPUT,
          class FUNCTION,
          class INFO_1 = bslmf::Nil,
          class INFO_2 = bslmf::Nil>
class Encoder_TransformSubObjectByCategoryCb {
    // This component-private class template provides a function-object type
    // that invokes a function with a pointer to an output argument, a
    // 'bdlat'-compatible value, 2 arbitrary "info" arguments, and the 'bdlat'
    // category tag of the value.

    // DATA
    OUTPUT         *d_output_p;
    const FUNCTION *d_function_p;
    const INFO_1   *d_info1_p;
    const INFO_2   *d_info2_p;

  public:
    // CREATORS
    Encoder_TransformSubObjectByCategoryCb(OUTPUT         *output,
                                           const FUNCTION *function,
                                           const INFO_1   *info1,
                                           const INFO_2   *info2);
        // Create an 'Encoder_TransformPropertyByCategoryCb' object holding the
        // specified 'output', 'function', 'info1', and 'info2'.

    // ACCESSORS
    template <class VALUE, class CATEGORY>
    int operator()(const VALUE& value, CATEGORY category) const;
        // Invoke the 'function' held by this object, supplying the 'output'
        // pointer held by this object, the specified 'value', the 'info1' and
        // 'info2' held by this object, and the specified 'category'.  Return
        // the result of the invocation.
};

    // ====================================================================
    // class Encoder_TransformSubObjectByCategoryCb<OUTPUT, FUNCTION, INFO>
    // ====================================================================

template <class OUTPUT, class FUNCTION, class INFO_1>
class Encoder_TransformSubObjectByCategoryCb<OUTPUT,
                                             FUNCTION,
                                             INFO_1,
                                             bslmf::Nil> {
    // This component-private class template provides a function-object type
    // that invokes a function with a pointer to an output argument, a
    // 'bdlat'-compatible value, an arbitrary "info" argument, and the 'bdlat'
    // category tag of the value.

    // DATA
    OUTPUT         *d_output_p;
    const FUNCTION *d_function_p;
    const INFO_1   *d_info1_p;

  public:
    // CREATORS
    Encoder_TransformSubObjectByCategoryCb(OUTPUT         *output,
                                           const FUNCTION *function,
                                           const INFO_1   *info1);
        // Create an 'Encoder_TransformPropertyByCategoryCb' object holding the
        // specified 'output', 'function', and 'info1'.

    // ACCESSORS
    template <class VALUE, class CATEGORY>
    int operator()(const VALUE& value, CATEGORY category) const;
        // Invoke the 'function' held by this object, supplying the 'output'
        // pointer held by this object, the specified 'value', the 'info1' and
        // 'info2' held by this object, and the specified 'category'.  Return
        // the result of the invocation.
};

       // ==============================================================
       // class Encoder_TransformSubObjectByCategoryCb<OUTPUT, FUNCTION>
       // ==============================================================

template <class OUTPUT, class FUNCTION>
class Encoder_TransformSubObjectByCategoryCb<OUTPUT, FUNCTION, bslmf::Nil> {
    // This component-private class template provides a function-object type
    // that invokes a function with a pointer to an output argument, a
    // 'bdlat'-compatible value, and the 'bdlat' category tag of the value.

    // DATA
    OUTPUT         *d_output_p;
    const FUNCTION *d_function_p;

  public:
    // CREATORS
    Encoder_TransformSubObjectByCategoryCb(OUTPUT         *output,
                                           const FUNCTION *function);
        // Create an 'Encoder_TransformPropertyByCategoryCb' object holding the
        // specified 'output' and 'function'.

    // ACCESSORS
    template <class VALUE, class CATEGORY>
    int operator()(const VALUE& value, CATEGORY category) const;
        // Invoke the 'function' held by this object, supplying the 'output'
        // pointer held by this object, the specified 'value', and the
        // specified 'category'.  Return the result of the invocation.
};

        // ============================================================
        // class Encoder_FoldAttributesByCategoryCb<OUTPUT, FUNCTION>
        // ============================================================

template <class OUTPUT, class FUNCTION>
class Encoder_FoldAttributesByCategoryCb {
    // This component-private class template provides a function-object type
    // that performs a single iteration of the
    // 'Encoder_SequenceUtil::foldAttributesByCategory' algorithm.

    // DATA
    OUTPUT         *d_output_p;
    const FUNCTION *d_function_p;
    OUTPUT          d_accumulator;

  public:
    // CREATORS
    Encoder_FoldAttributesByCategoryCb(OUTPUT         *output,
                                         const FUNCTION *function,
                                         const OUTPUT&   initial);
        // Create an 'Encoder_FoldAttributesByCategoryCb' object holding the
        // specified 'output', and 'function', and an "accumulator" having a
        // copy of the value of the specified 'initial' object.

    // MANIPULATORS
    template <class VALUE, class ATTRIBUTE_INFO, class CATEGORY>
    int operator()(const VALUE&          attribute,
                   const ATTRIBUTE_INFO& attributeInfo,
                   CATEGORY              category);
        // Invoke the 'function' held by this object, supplying the 'output'
        // pointer held by this object, the specified 'attribute' and
        // 'attributeInfo', the current value of the "accumulator" of this
        // object, and the specified 'category'.  After the invocation, set the
        // "accumulator" of this object to the value loaded to 'output'.
        // Return the result of the invocation.
};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                               // -------------
                               // class Encoder
                               // -------------

// PRIVATE MANIPULATORS
inline
bsl::ostream& Encoder::logStream()
{
    return d_logStream;
}

// CREATORS
inline
Encoder::Encoder(bslma::Allocator *basicAllocator)
: d_logStream(basicAllocator)
{
}

// MANIPULATORS
template <class TYPE>
inline
int Encoder::encode(bsl::streambuf *streamBuf, const TYPE& value)
{
    const EncoderOptions options;
    return encode(streamBuf, value, options);
}

template <class TYPE>
inline
int Encoder::encode(bsl::ostream& stream, const TYPE& value)
{
    const EncoderOptions options;
    return encode(stream, value, options);
}

template <class TYPE>
int Encoder::encode(bsl::streambuf        *streamBuf,
                    const TYPE&            value,
                    const EncoderOptions&  options)
{
    BSLS_ASSERT(streamBuf);

    d_logStream.clear();
    d_logStream.str("");

    bdlat_TypeCategory::Value category =
                                    bdlat_TypeCategoryFunctions::select(value);
    if (bdlat_TypeCategory::e_SEQUENCE_CATEGORY != category
     && bdlat_TypeCategory::e_CHOICE_CATEGORY != category
     && bdlat_TypeCategory::e_ARRAY_CATEGORY != category) {
        logStream()
            << "Encoded object must be a Sequence, Choice, or Array type."
            << bsl::endl;
        return -1;                                                    // RETURN
    }

    bsl::ostream outputStream(streamBuf);
    Encoder_EncodeImplUtil::openDocument(&outputStream, options);

    const int rc = Encoder_EncodeImplUtil::encode(
        &d_logStream, &outputStream, value, options);
    if (0 != rc) {
        streamBuf->pubsync();
        return rc;                                                    // RETURN
    }

    Encoder_EncodeImplUtil::closeDocument(&outputStream, options);

    if (!outputStream) {
        logStream()
            << "An error occurred when writing to the supplied output stream"
               " or stream buffer."
            << bsl::endl;
        streamBuf->pubsync();
        return -1;                                                    // RETURN
    }

    streamBuf->pubsync();

    return 0;
}

template <class TYPE>
int Encoder::encode(bsl::streambuf        *streamBuf,
                    const TYPE&            value,
                    const EncoderOptions  *options)
{
    EncoderOptions localOpts;
    return encode(streamBuf, value, options ? *options : localOpts);
}

template <class TYPE>
int Encoder::encode(bsl::ostream&         stream,
                    const TYPE&           value,
                    const EncoderOptions& options)
{
    if (!stream.good()) {
        logStream() << "Invalid stream." << bsl::endl;
        return -1;                                                    // RETURN
    }

    const int rc = this->encode(stream.rdbuf(), value, options);
    if (rc) {
        stream.setstate(bsl::ios_base::failbit);
        return rc;                                                    // RETURN
    }

    return 0;
}

template <class TYPE>
inline
int Encoder::encode(bsl::ostream&         stream,
                    const TYPE&           value,
                    const EncoderOptions *options)
{
    EncoderOptions localOpts;
    return encode(stream, value, options ? *options : localOpts);
}

// ACCESSORS
inline
bsl::string Encoder::loggedMessages() const
{
    return d_logStream.str();
}

                        // -----------------------------
                        // struct Encoder_EncodeImplUtil
                        // -----------------------------

// CLASS METHODS

                         // Document Encoding Functions

inline
void Encoder_EncodeImplUtil::openDocument(bsl::ostream *outputStream,
                                      const EncoderOptions& options)
{
    if (baljsn::EncoderOptions::e_PRETTY ==
                                         options.encodingStyle()) {
        bdlb::Print::indent(*outputStream,
                            options.initialIndentLevel(),
                            options.spacesPerLevel());
    }
}

inline
void Encoder_EncodeImplUtil::closeDocument(bsl::ostream *outputStream,
                                       const baljsn::EncoderOptions& options)
{
    if (baljsn::EncoderOptions::e_PRETTY ==
                                         options.encodingStyle()) {
        (*outputStream) << '\n';
    }
}

                               // Value Encoding

template <class TYPE>
inline
int Encoder_EncodeImplUtil::encode(bsl::ostream          *jsonStream,
                                   const TYPE&            value,
                                   const EncoderOptions&  options)
{
    bdlsb::MemOutStreamBuf logStreamBuf;
    bsl::ostream           logStream(&logStreamBuf);

    return encode(&logStream, jsonStream, value, options);
}

template <class TYPE>
inline
int Encoder_EncodeImplUtil::encode(bsl::ostream          *logStream,
                                   bsl::ostream          *jsonStream,
                                   const TYPE&            value,
                                   const EncoderOptions&  options)
{
    static const FormattingMode s_MODE = bdlat_FormattingMode::e_DEFAULT;
    static const bool           s_FIRST_MEMBER_FLAG = false;

    baljsn::Formatter formatter(*jsonStream,
                                baljsn::EncoderOptions::e_PRETTY ==
                                    options.encodingStyle(),
                                options.initialIndentLevel(),
                                options.spacesPerLevel());

    bool isValueEmpty = false;

    int rc = encode(&isValueEmpty,
                    &formatter,
                    logStream,
                    value,
                    s_MODE,
                    options,
                    s_FIRST_MEMBER_FLAG);

    if (0 != formatter.nestingDepth()) {
        *logStream << "Encoding failed leaving an unclosed element (rc = "
                   << rc << ")\n";
    }

    return rc;
}

template <class TYPE>
int Encoder_EncodeImplUtil::encode(bool                  *isValueEmpty,
                                   Formatter             *formatter,
                                   bsl::ostream          *logStream,
                                   const TYPE&            value,
                                   FormattingMode         formattingMode,
                                   const EncoderOptions&  options,
                                   bool                   isFirstMember)
{
    Encoder_ValueVisitor visitor(formatter, logStream, options);
    return Encoder_TypeCategoryUtil::transformByCategory(
        isValueEmpty, value, visitor, formattingMode, isFirstMember);
}

                                 // Validation

template <class TYPE>
int Encoder_EncodeImplUtil::validate(bsl::ostream               *logStream,
                                     const TYPE&                 value,
                                     bdlat_TypeCategory::Choice)
{
    return validateChoice(logStream, value);
}

template <class TYPE, class CATEGORY>
inline
int Encoder_EncodeImplUtil::validate(bsl::ostream *, const TYPE&, CATEGORY)
{
    return 0;
}

template <class TYPE>
int Encoder_EncodeImplUtil::validateChoice(bsl::ostream *logStream,
                                           const TYPE&   value)
{
    if (bdlat_ChoiceFunctions::k_UNDEFINED_SELECTION_ID ==
        bdlat_ChoiceFunctions::selectionId(value)) {
        (*logStream) << "Undefined selection for Choice object" << bsl::endl;
        return -1;                                                    // RETURN
    }

    return 0;
}


             // Encoding Values That Have Specific Type Categories

template <class TYPE>
inline
int Encoder_EncodeImplUtil::encodeSimpleValue(Formatter             *formatter,
                                              const TYPE&            value,
                                              const EncoderOptions&  options)
{
    return formatter->putValue(value, &options);
}

                    // Encoding Value Prefixes and Suffixes

inline
void Encoder_EncodeImplUtil::encodeObjectPrefix(
                                               bool           *isPrefixEmpty,
                                               Formatter      *formatter,
                                               FormattingMode  formattingMode)
{
    if (bdlat_FormattingMode::e_UNTAGGED & formattingMode) {
        *isPrefixEmpty = true;
        return;                                                       // RETURN
    }

    formatter->openObject();

    *isPrefixEmpty = false;
}

inline
void Encoder_EncodeImplUtil::encodeObjectSuffix(bool           *isSuffixEmpty,
                                                Formatter      *formatter,
                                                FormattingMode  formattingMode)
{
    if (bdlat_FormattingMode::e_UNTAGGED & formattingMode) {
        *isSuffixEmpty = true;
        return;                                                       // RETURN
    }

    formatter->closeObject();

    *isSuffixEmpty = false;
}

                  // Encoding Arrays That Have Specific Shapes

inline
void Encoder_EncodeImplUtil::encodeEmptyArray(Formatter *formatter)
{
    formatter->openArray(true);
    formatter->closeArray(true);
}

template <class TYPE>
int Encoder_EncodeImplUtil::encodeNonEmptyArray(
                                         Formatter             *formatter,
                                         bsl::ostream          *logStream,
                                         const TYPE&            value,
                                         const EncoderOptions&  options)
{
    const int size = static_cast<int>(bdlat_ArrayFunctions::size(value));
    BSLS_ASSERT(0 < size);

    formatter->openArray();

    bool isArrayEmpty = false;
    Encoder_ElementVisitor visitor(formatter, logStream, options);

    int rc = Encoder_ArrayUtil::foldElementsByCategory(&isArrayEmpty,
                                                         value,
                                                         visitor,
                                                         true);
    if (0 != rc) {
        return rc;                                                    // RETURN
    }

    formatter->closeArray();

    return 0;
}

                        // Encoding Generalized Members

template <class TYPE>
int Encoder_EncodeImplUtil::encodeMember(
                                     bool                      *isMemberEmpty,
                                     Formatter                 *formatter,
                                     bsl::ostream              *logStream,
                                     const bsl::string_view&    memberName,
                                     const TYPE&                member,
                                     FormattingMode             formattingMode,
                                     const EncoderOptions&      options,
                                     bool                       isFirstMember,
                                     bdlat_TypeCategory::Array  category)
    ///Implementation Note
    ///- - - - - - - - - -
    // This function purposefully ignores the 'EncodeEmptyArrays' option in the
    // specified 'options' and always encodes the value of the specified
    // 'member' array.  The caller is responsible for checking the value of
    // this option and deciding whether to obey the option or not.  Callers
    // that encode array-valued attributes of sequences must always obey the
    // option.  Callers that encode array-valued selections of choices must
    // never obey the option, and must always encode the array value.
{
    int rc = ThisUtil::validate(logStream, member, category);
    if (0 != rc) {
        return rc;                                                    // RETURN
    }

    rc = ThisUtil::encodeMemberPrefix(
        formatter, logStream, memberName, formattingMode, isFirstMember);
    if (0 != rc) {
        return rc;                                                    // RETURN
    }

    if (bdlat_ArrayFunctions::size(member) == 0) {
        ThisUtil::encodeEmptyArray(formatter);

        *isMemberEmpty = false;
        return 0;                                                     // RETURN
    }

    rc = ThisUtil::encodeNonEmptyArray(formatter, logStream, member, options);
    if (0 != rc) {
        (*logStream) << "Unable to encode value of element "
                     << "named: '" << memberName << "'." << bsl::endl;
        return rc;                                                    // RETURN
    }

    *isMemberEmpty = false;
    return 0;
}

template <class TYPE, class OTHER_CATEGORY>
int Encoder_EncodeImplUtil::encodeMember(
                                       bool                    *isMemberEmpty,
                                       Formatter               *formatter,
                                       bsl::ostream            *logStream,
                                       const bsl::string_view&  memberName,
                                       const TYPE&              member,
                                       FormattingMode           formattingMode,
                                       const EncoderOptions&    options,
                                       bool                     isFirstMember,
                                       OTHER_CATEGORY           category)
{
    int rc = ThisUtil::validate(logStream, member, category);
    if (0 != rc) {
        return rc;                                                    // RETURN
    }

    bool isPrefixEmpty = false;
    rc = ThisUtil::encodeMemberPrefix(&isPrefixEmpty,
                                      formatter,
                                      logStream,
                                      memberName,
                                      formattingMode,
                                      isFirstMember);
    if (0 != rc) {
        return rc;                                                    // RETURN
    }

    bool isValueEmpty = false;
    rc = ThisUtil::encode(&isValueEmpty,
                          formatter,
                          logStream,
                          member,
                          formattingMode,
                          options,
                          !isPrefixEmpty || isFirstMember);
    if (0 != rc) {
        (*logStream) << "Unable to encode value of element "
                     << "named: '" << memberName << "'."
                     << bsl::endl;
        return rc;                                                    // RETURN
    }

    BSLS_ASSERT(!isValueEmpty || isPrefixEmpty);
        // If the value is empty then the prefix is empty.  Otherwise, this
        // function would produce invalid JSON because it would emit a member
        // name token and a colon token, but no member value.

    *isMemberEmpty = isFirstMember && isValueEmpty;
    return 0;
}

inline
int Encoder_EncodeImplUtil::encodeMemberPrefix(
                                       Formatter                *formatter,
                                       bsl::ostream             *logStream,
                                       const bsl::string_view&   memberName,
                                       bool                      isFirstMember)
{
    if (!isFirstMember) {
        formatter->closeMember();
    }

    int rc = formatter->openMember(memberName);
    if (0 != rc) {
        (*logStream) << "Unable to encode element name: '" << memberName
                     << "'." << bsl::endl;
        return rc;                                                    // RETURN
    }

    return 0;
}

inline
int Encoder_EncodeImplUtil::encodeMemberPrefix(
                                       Formatter               *formatter,
                                       bsl::ostream            *logStream,
                                       const bsl::string_view&  memberName,
                                       FormattingMode           formattingMode,
                                       bool                     isFirstMember)
{
    if (bdlat_FormattingMode::e_UNTAGGED & formattingMode) {
        return 0;                                                     // RETURN
    }

    return ThisUtil::encodeMemberPrefix(
        formatter, logStream, memberName, isFirstMember);
}

inline
int Encoder_EncodeImplUtil::encodeMemberPrefix(
                                       bool                    *isPrefixEmpty,
                                       Formatter               *formatter,
                                       bsl::ostream            *logStream,
                                       const bsl::string_view&  memberName,
                                       FormattingMode           formattingMode,
                                       bool                     isFirstMember)
{
    if (bdlat_FormattingMode::e_UNTAGGED & formattingMode) {
        *isPrefixEmpty = true;
        return 0;                                                     // RETURN
    }

    int rc = ThisUtil::encodeMemberPrefix(
        formatter, logStream, memberName, isFirstMember);
    if (0 != rc) {
        return rc;                                                    // RETURN
    }

    *isPrefixEmpty = false;
    return 0;
}

                        // ---------------------------
                        // struct Encoder_ValueVisitor
                        // ---------------------------

// CREATORS
inline
Encoder_ValueVisitor::Encoder_ValueVisitor(Formatter             *formatter,
                                           bsl::ostream          *logStream,
                                           const EncoderOptions&  options)
: d_formatter_p(formatter)
, d_logStream_p(logStream)
, d_options_p(&options)
{
}

// ACCESSORS
inline
int Encoder_ValueVisitor::operator()(
                              bool                      *isNextObjectFirst,
                              const bsl::vector<char>&   value,
                              FormattingMode             ,
                              bool                       ,
                              bdlat_TypeCategory::Array) const
{
    *isNextObjectFirst = false;
    return Encoder_EncodeImplUtil::encodeCharArray(
        d_formatter_p, value, *d_options_p);
}

template <class TYPE>
inline
int Encoder_ValueVisitor::operator()(
                              bool                      *isNextObjectFirst,
                              const TYPE&                value,
                              FormattingMode             ,
                              bool                       ,
                              bdlat_TypeCategory::Array) const
{
    const bool arrayIsEmpty = (0 == bdlat_ArrayFunctions::size(value));

    if (arrayIsEmpty && !d_options_p->encodeEmptyArrays()) {
        *isNextObjectFirst = true;
        return 0;                                                     // RETURN
    }

    if (arrayIsEmpty && d_options_p->encodeEmptyArrays()) {
        Encoder_EncodeImplUtil::encodeEmptyArray(d_formatter_p);
        *isNextObjectFirst = false;
        return 0;                                                     // RETURN
    }

    int rc = Encoder_EncodeImplUtil::encodeNonEmptyArray(
        d_formatter_p, d_logStream_p, value, *d_options_p);
    if (0 != rc) {
        return rc;                                                    // RETURN
    }

    *isNextObjectFirst = false;
    return 0;
}

template <class TYPE>
inline
int Encoder_ValueVisitor::operator()(
                             bool                       *isNextObjectFirst,
                             const TYPE&                 value,
                             FormattingMode              formattingMode,
                             bool                        isFirstSubObject,
                             bdlat_TypeCategory::Choice) const
{
    int rc = Encoder_EncodeImplUtil::validateChoice(d_logStream_p, value);
    if (0 != rc) {
        return rc;                                                    // RETURN
    }

    bool isPrefixEmpty = false;
    Encoder_EncodeImplUtil::encodeObjectPrefix(
        &isPrefixEmpty, d_formatter_p, formattingMode);

    bool                     isSelectionEmpty = false;
    Encoder_SelectionVisitor visitor(
        d_formatter_p, d_logStream_p, *d_options_p);
    rc = Encoder_ChoiceUtil::transformSelectionByCategory(
        &isSelectionEmpty, value, visitor, !isPrefixEmpty || isFirstSubObject);
    if (0 != rc) {
        return rc;                                                    // RETURN
    }

    bool isSuffixEmpty = false;
    Encoder_EncodeImplUtil::encodeObjectSuffix(
        &isSuffixEmpty, d_formatter_p, formattingMode);

    *isNextObjectFirst =
        isPrefixEmpty && isSelectionEmpty && isSuffixEmpty;
    return 0;
}

template <class TYPE>
inline
int Encoder_ValueVisitor::operator()(
                     bool                               *isNextObjectFirst,
                     const TYPE&                         value,
                     FormattingMode                      formattingMode,
                     bool                                isFirstSubObject,
                     bdlat_TypeCategory::CustomizedType) const
{
    return Encoder_EncodeImplUtil::encode(
        isNextObjectFirst,
        d_formatter_p,
        d_logStream_p,
        bdlat_CustomizedTypeFunctions::convertToBaseType(value),
        formattingMode,
        *d_options_p,
        isFirstSubObject);
}

template <class TYPE>
inline
int Encoder_ValueVisitor::operator()(
                        bool                            *isNextObjectFirst,
                        const TYPE&                      value,
                        FormattingMode                   ,
                        bool                             ,
                        bdlat_TypeCategory::Enumeration) const
{
    bsl::string valueString;
    bdlat_EnumFunctions::toString(&valueString, value);

    *isNextObjectFirst = false;
    return Encoder_EncodeImplUtil::encodeSimpleValue(
        d_formatter_p, valueString, *d_options_p);
}

template <class TYPE>
inline
int Encoder_ValueVisitor::operator()(
                      bool                              *isNextObjectFirst,
                      const TYPE&                        value,
                      FormattingMode                     formattingMode,
                      bool                               isFirstSubObject,
                      bdlat_TypeCategory::NullableValue) const
{
    if (bdlat_NullableValueFunctions::isNull(value)) {
        d_formatter_p->putNullValue();
        *isNextObjectFirst = false;
        return 0;                                                     // RETURN
    }

    Encoder_ValueVisitor visitor(d_formatter_p, d_logStream_p, *d_options_p);
    return Encoder_NullableValueUtil::transformValueByCategory(
        isNextObjectFirst,
        value,
        visitor,
        formattingMode,
        isFirstSubObject);
}

template <class TYPE>
inline
int Encoder_ValueVisitor::operator()(
                           bool                         *isNextObjectFirst,
                           const TYPE&                   value,
                           FormattingMode                formattingMode,
                           bool                          isFirstSubObject,
                           bdlat_TypeCategory::Sequence) const
{
    bool isPrefixEmpty = false;
    Encoder_EncodeImplUtil::encodeObjectPrefix(
        &isPrefixEmpty, d_formatter_p, formattingMode);

    Encoder_AttributeVisitor visitor(d_formatter_p,
                                     d_logStream_p,
                                     *d_options_p);

    bool isAttributeEmpty = false;

    int rc = Encoder_SequenceUtil::foldAttributesByCategory(
        &isAttributeEmpty, value, visitor, !isPrefixEmpty || isFirstSubObject);
    if (0 != rc) {
        return rc;                                                    // RETURN
    }

    bool isSuffixEmpty = false;
    Encoder_EncodeImplUtil::encodeObjectSuffix(
        &isSuffixEmpty, d_formatter_p, formattingMode);

    *isNextObjectFirst =
        isPrefixEmpty && isAttributeEmpty && isSuffixEmpty;
    return 0;
}

template <class TYPE>
inline
int Encoder_ValueVisitor::operator()(
                             bool                       *isNextObjectFirst,
                             const TYPE&                 value,
                             FormattingMode              ,
                             bool                        ,
                             bdlat_TypeCategory::Simple) const
{
    *isNextObjectFirst = false;
    return Encoder_EncodeImplUtil::encodeSimpleValue(
        d_formatter_p, value, *d_options_p);
}

template <class TYPE>
inline
int Encoder_ValueVisitor::operator()(bool           *,
                                     const TYPE&,
                                     FormattingMode,
                                     bool,
                                     bslmf::Nil) const
{
    BSLS_ASSERT_OPT(!"Unreachable");
    return -1;
}

                        // ----------------------------
                        // class Encoder_ElementVisitor
                        // ----------------------------

// CREATORS
inline
Encoder_ElementVisitor::Encoder_ElementVisitor(
                                          Formatter             *formatter,
                                          bsl::ostream          *logStream,
                                          const EncoderOptions&  options)
: d_formatter_p(formatter)
, d_logStream_p(logStream)
, d_options_p(&options)
{
}

// ACCESSORS
template <class INFO>
int Encoder_ElementVisitor::operator()(
                              bool                      *isNextObjectFirst,
                              const bsl::vector<char>&   element,
                              bool                       isFirstElement,
                              bdlat_TypeCategory::Array) const
{
    if (!isFirstElement) {
        d_formatter_p->addArrayElementSeparator();
    }

    int rc = Encoder_EncodeImplUtil::encodeCharArray(d_formatter_p,
                                                     element,
                                                     *d_options_p);
    if (0 != rc) {
        return rc;                                                    // RETURN
    }

    *isNextObjectFirst = false;
    return 0;
}

template <class TYPE>
int Encoder_ElementVisitor::operator()(
                              bool                      *isNextElementFirst,
                              const TYPE&                element,
                              bool                       isFirstElement,
                              bdlat_TypeCategory::Array) const
{
    const bool arrayIsEmpty = (0 == bdlat_ArrayFunctions::size(element));

    if (arrayIsEmpty && !d_options_p->encodeEmptyArrays()) {
        *isNextElementFirst = isFirstElement;
        return 0;                                                     // RETURN
    }

    if (!isFirstElement) {
        d_formatter_p->addArrayElementSeparator();
    }

    if (arrayIsEmpty && d_options_p->encodeEmptyArrays()) {
        Encoder_EncodeImplUtil::encodeEmptyArray(d_formatter_p);
        *isNextElementFirst = false;
        return 0;                                                     // RETURN
    }

    int rc = Encoder_EncodeImplUtil::encodeNonEmptyArray(
        d_formatter_p, d_logStream_p, element, *d_options_p);
    if (0 != rc) {
        return rc;                                                    // RETURN
    }

    *isNextElementFirst = false;
    return 0;
}

template <class TYPE>
int Encoder_ElementVisitor::operator()(
                             bool                       *isNextElementFirst,
                             const TYPE&                 element,
                             bool                        isFirstElement,
                             bdlat_TypeCategory::Choice) const
{
    int rc = Encoder_EncodeImplUtil::validateChoice(d_logStream_p, element);
    if (0 != rc) {
        return rc;                                                    // RETURN
    }

    if (!isFirstElement) {
        d_formatter_p->addArrayElementSeparator();
    }

    d_formatter_p->openObject();

    bool                     selectionIsEmpty = false;
    Encoder_SelectionVisitor visitor(
        d_formatter_p, d_logStream_p, *d_options_p);
    rc = Encoder_ChoiceUtil::transformSelectionByCategory(
        &selectionIsEmpty, element, visitor, true);
    if (0 != rc) {
        return rc;                                                    // RETURN
    }

    d_formatter_p->closeObject();

    *isNextElementFirst = false;
    return 0;
}

template <class TYPE>
int Encoder_ElementVisitor::operator()(
                     bool                               *isNextElementFirst,
                     const TYPE&                         element,
                     bool                                isFirstElement,
                     bdlat_TypeCategory::CustomizedType) const
{

    return Encoder_TypeCategoryUtil::transformByCategory(
        isNextElementFirst,
        bdlat_CustomizedTypeFunctions::convertToBaseType(element),
        *this,
        isFirstElement);
}

template <class TYPE>
int Encoder_ElementVisitor::operator()(
                        bool                            *isNextElementFirst,
                        const TYPE&                      element,
                        bool                             isFirstElement,
                        bdlat_TypeCategory::Enumeration) const
{
    if (!isFirstElement) {
        d_formatter_p->addArrayElementSeparator();
    }

    bsl::string valueString;
    bdlat_EnumFunctions::toString(&valueString, element);

    *isNextElementFirst = false;
    return Encoder_EncodeImplUtil::encodeSimpleValue(
        d_formatter_p, valueString, *d_options_p);
}

template <class TYPE>
int Encoder_ElementVisitor::operator()(
                      bool                              *isNextElementFirst,
                      const TYPE&                        element,
                      bool                               isFirstElement,
                      bdlat_TypeCategory::NullableValue) const
{
    const bool elementIsNull = bdlat_NullableValueFunctions::isNull(element);

    if (elementIsNull) {
        if (!isFirstElement) {
            d_formatter_p->addArrayElementSeparator();
        }

        d_formatter_p->putNullValue();
        *isNextElementFirst = false;
        return 0;                                                     // RETURN
    }

    return Encoder_NullableValueUtil::transformValueByCategory(
        isNextElementFirst, element, *this, isFirstElement);
}

template <class TYPE>
int Encoder_ElementVisitor::operator()(
                           bool                         *isNextElementFirst,
                           const TYPE&                   element,
                           bool                          isFirstElement,
                           bdlat_TypeCategory::Sequence) const
{
    if (!isFirstElement) {
        d_formatter_p->addArrayElementSeparator();
    }

    d_formatter_p->openObject();


    Encoder_AttributeVisitor visitor(d_formatter_p,
                                     d_logStream_p,
                                     *d_options_p);

    static const bool k_ATTRIBUTE_IS_FIRST = true;
    bool areAttributesEmpty = false;

    int rc = Encoder_SequenceUtil::foldAttributesByCategory(
        &areAttributesEmpty, element, visitor, k_ATTRIBUTE_IS_FIRST);
    if (0 != rc) {
        return rc;                                                    // RETURN
    }

    d_formatter_p->closeObject();

    *isNextElementFirst = false;
    return 0;
}

template <class TYPE>
int Encoder_ElementVisitor::operator()(
                             bool                       *isNextElementFirst,
                             const TYPE&                 element,
                             bool                        isFirstElement,
                             bdlat_TypeCategory::Simple) const
{
    if (!isFirstElement) {
        d_formatter_p->addArrayElementSeparator();
    }

    *isNextElementFirst = false;
    return Encoder_EncodeImplUtil::encodeSimpleValue(
        d_formatter_p, element, *d_options_p);
}

template <class TYPE>
int Encoder_ElementVisitor::operator()(bool        *,
                                       const TYPE&,
                                       bool,
                                       bslmf::Nil) const
{
    BSLS_ASSERT_OPT(!"Unreachable");
    return -1;
}

                       // ------------------------------
                       // class Encoder_SelectionVisitor
                       // ------------------------------

// CREATORS
inline
Encoder_SelectionVisitor::Encoder_SelectionVisitor(
                                      Formatter                *formatter,
                                      bsl::ostream             *logStream,
                                      const EncoderOptions&     options)
: d_formatter_p(formatter)
, d_logStream_p(logStream)
, d_options_p(&options)
{
}

// ACCESSORS
template <class TYPE, class SELECTION_INFO>
inline
int Encoder_SelectionVisitor::operator()(
                         bool                               *isNextObjectFirst,
                         const TYPE&                         selection,
                         const SELECTION_INFO&               selectionInfo,
                         bool                                isFirstSubObject,
                         bdlat_TypeCategory::CustomizedType) const
{
    return Encoder_TypeCategoryUtil::transformByCategory(
        isNextObjectFirst,
        bdlat_CustomizedTypeFunctions::convertToBaseType(selection),
        *this,
        selectionInfo,
        isFirstSubObject);
}

template <class TYPE, class SELECTION_INFO, class CATEGORY>
inline
int Encoder_SelectionVisitor::operator()(
                                      bool                  *isNextObjectFirst,
                                      const TYPE&            selection,
                                      const SELECTION_INFO&  selectionInfo,
                                      bool                   isFirstSubObject,
                                      CATEGORY               category) const
{
    return Encoder_EncodeImplUtil::encodeMember(isNextObjectFirst,
                                                d_formatter_p,
                                                d_logStream_p,
                                                selectionInfo.name(),
                                                selection,
                                                selectionInfo.formattingMode(),
                                                *d_options_p,
                                                isFirstSubObject,
                                                category);
}

template <class TYPE, class SELECTION_INFO>
inline
int Encoder_SelectionVisitor::operator()(bool        *,
                                         const TYPE&,
                                         const SELECTION_INFO&,
                                         bool,
                                         bslmf::Nil) const
{
    BSLS_ASSERT_OPT(!"Reachable");
    return -1;
}

                       // ------------------------------
                       // class Encoder_AttributeVisitor
                       // ------------------------------

// CREATORS
inline
Encoder_AttributeVisitor::Encoder_AttributeVisitor(
                                              Formatter             *formatter,
                                              bsl::ostream          *logStream,
                                              const EncoderOptions&  options)
: d_formatter_p(formatter)
, d_logStream_p(logStream)
, d_options_p(&options)
{
}

// ACCESSORS
template <class ATTRIBUTE_INFO>
inline
int Encoder_AttributeVisitor::operator()(
                               bool                      *isNextAttributeFirst,
                               const bsl::vector<char>&   attribute,
                               const ATTRIBUTE_INFO&      info,
                               bool                       isFirstAttribute,
                               bdlat_TypeCategory::Array  category) const
{
    return Encoder_EncodeImplUtil::encodeMember(isNextAttributeFirst,
                                                d_formatter_p,
                                                d_logStream_p,
                                                info.name(),
                                                attribute,
                                                info.formattingMode(),
                                                *d_options_p,
                                                isFirstAttribute,
                                                category);
}

template <class TYPE, class ATTRIBUTE_INFO>
inline
int Encoder_AttributeVisitor::operator()(
                               bool                      *isNextAttributeFirst,
                               const TYPE&                attribute,
                               const ATTRIBUTE_INFO&      attributeInfo,
                               bool                       isFirstAttribute,
                               bdlat_TypeCategory::Array  category) const
{
    const bool isArrayEmpty = (0 == bdlat_ArrayFunctions::size(attribute));

    if (!d_options_p->encodeEmptyArrays() && isArrayEmpty) {
        *isNextAttributeFirst = isFirstAttribute;
        return 0;                                                     // RETURN
    }

    return Encoder_EncodeImplUtil::encodeMember(isNextAttributeFirst,
                                                d_formatter_p,
                                                d_logStream_p,
                                                attributeInfo.name(),
                                                attribute,
                                                attributeInfo.formattingMode(),
                                                *d_options_p,
                                                isFirstAttribute,
                                                category);
}

template <class TYPE, class ATTRIBUTE_INFO>
inline
int Encoder_AttributeVisitor::operator()(
                      bool                               *isNextAttributeFirst,
                      const TYPE&                         attribute,
                      const ATTRIBUTE_INFO&               attributeInfo,
                      bool                                isAttributeFirst,
                      bdlat_TypeCategory::CustomizedType) const
{
    return Encoder_TypeCategoryUtil::transformByCategory(
        isNextAttributeFirst,
        bdlat_CustomizedTypeFunctions::convertToBaseType(attribute),
        *this,
        attributeInfo,
        isAttributeFirst);
}

template <class TYPE, class ATTRIBUTE_INFO>
inline
int Encoder_AttributeVisitor::operator()(
                       bool                              *isNextAttributeFirst,
                       const TYPE&                        attribute,
                       const ATTRIBUTE_INFO&              attributeInfo,
                       bool                               isAttributeFirst,
                       bdlat_TypeCategory::NullableValue  category) const
{
    if (bdlat_NullableValueFunctions::isNull(attribute) &&
        !d_options_p->encodeNullElements()) {
        *isNextAttributeFirst = isAttributeFirst;
        return 0;                                                     // RETURN
    }

    if (bdlat_NullableValueFunctions::isNull(attribute) &&
        (bdlat_FormattingMode::e_UNTAGGED & attributeInfo.formattingMode())) {
        (*d_logStream_p)
            << "Cannot encode a null choice or sequence and "
            << "generate valid json.\n";
        return -1;                                                    // RETURN
    }

    return Encoder_EncodeImplUtil::encodeMember(isNextAttributeFirst,
                                                d_formatter_p,
                                                d_logStream_p,
                                                attributeInfo.name(),
                                                attribute,
                                                attributeInfo.formattingMode(),
                                                *d_options_p,
                                                isAttributeFirst,
                                                category);
}

template <class TYPE, class ATTRIBUTE_INFO, class CATEGORY>
inline
int Encoder_AttributeVisitor::operator()(
                                   bool                  *isNextAttributeFirst,
                                   const TYPE&            attribute,
                                   const ATTRIBUTE_INFO&  attributeInfo,
                                   bool                   isFirstAttribute,
                                   CATEGORY               category) const
{
    return Encoder_EncodeImplUtil::encodeMember(isNextAttributeFirst,
                                                d_formatter_p,
                                                d_logStream_p,
                                                attributeInfo.name(),
                                                attribute,
                                                attributeInfo.formattingMode(),
                                                *d_options_p,
                                                isFirstAttribute,
                                                category);
}

template <class TYPE, class ATTRIBUTE_INFO>
inline
int Encoder_AttributeVisitor::operator()(bool        *,
                                         const TYPE&,
                                         const ATTRIBUTE_INFO&,
                                         bool,
                                         bslmf::Nil) const
{
    BSLS_ASSERT_OPT(!"Unreachable");
    return -1;
}

                      // -------------------------------
                      // struct Encoder_TypeCategoryUtil
                      // -------------------------------

// CLASS METHODS
template <class OUTPUT, class TYPE, class FUNCTION, class INFO_1>
int Encoder_TypeCategoryUtil::transformByCategory(OUTPUT          *output,
                                                  const TYPE&      object,
                                                  const FUNCTION&  function,
                                                  const INFO_1&    info1)
{
    Encoder_TransformByCategoryCb<OUTPUT, FUNCTION, INFO_1> adapter(
        output, &function, &info1);
    return bdlat_TypeCategoryUtil::accessByCategory(object, adapter);
}

template <class OUTPUT, class TYPE, class FUNCTION, class INFO_1, class INFO_2>
int Encoder_TypeCategoryUtil::transformByCategory(OUTPUT          *output,
                                                  const TYPE&      object,
                                                  const FUNCTION&  function,
                                                  const INFO_1&    info1,
                                                  const INFO_2&    info2)
{
    Encoder_TransformByCategoryCb<OUTPUT, FUNCTION, INFO_1, INFO_2>
        adapter(output, &function, &info1, &info2);
    return bdlat_TypeCategoryUtil::accessByCategory(object, adapter);
}

                          // ------------------------
                          // struct Encoder_ArrayUtil
                          // ------------------------

// CLASS METHODS
template <class TYPE, class ACCESSOR>
int Encoder_ArrayUtil::accessElementByCategory(const TYPE& array,
                                               ACCESSOR&   accessor,
                                               int         index)
{
    Encoder_AccessSubObjectByCategoryCb<ACCESSOR> adapter(&accessor);
    return bdlat_ArrayFunctions::accessElement(array, adapter, index);
}

template <class OUTPUT, class TYPE, class FUNCTION, class INFO_1>
int Encoder_ArrayUtil::transformElementByCategory(OUTPUT          *output,
                                                  const TYPE&      array,
                                                  const FUNCTION&  function,
                                                  const INFO_1&    info1,
                                                  int              index)
{
    Encoder_TransformSubObjectByCategoryCb<OUTPUT, FUNCTION, INFO_1> adapter(
        output, &function, &info1);
    return Encoder_ArrayUtil::accessElementByCategory(array, adapter, index);
}


template <class OUTPUT, class TYPE, class FUNCTION>
int Encoder_ArrayUtil::foldElementsByCategory(OUTPUT          *output,
                                                const TYPE&      array,
                                                const FUNCTION&  function,
                                                const OUTPUT&    initial)
{
    *output            = initial;
    OUTPUT accumulator = initial;

    const bsl::size_t size = bdlat_ArrayFunctions::size(array);
    for (bsl::size_t index = 0; index != size; ++index) {
        int rc = Encoder_ArrayUtil::transformElementByCategory(
            output, array, function, accumulator, static_cast<int>(index));
        if (0 != rc) {
            return rc;                                                // RETURN
        }

        accumulator = *output;
    }

    return 0;
}

                         // -------------------------
                         // struct Encoder_ChoiceUtil
                         // -------------------------

// CLASS METHODS
template <class TYPE, class ACCESSOR>
int Encoder_ChoiceUtil::accessSelectionByCategory(const TYPE& choice,
                                                  ACCESSOR&   accessor)
{
    Encoder_AccessPropertyByCategoryCb<ACCESSOR> adapter(&accessor);
    return bdlat_ChoiceFunctions::accessSelection(choice, adapter);
}

template <class OUTPUT, class TYPE, class FUNCTION, class INFO_1>
int Encoder_ChoiceUtil::transformSelectionByCategory(OUTPUT          *output,
                                                     const TYPE&      choice,
                                                     const FUNCTION&  function,
                                                     const INFO_1&    info1)
{
    Encoder_TransformPropertyByCategoryCb<OUTPUT, FUNCTION, INFO_1> adapter(
        output, &function, &info1);
    return Encoder_ChoiceUtil::accessSelectionByCategory(choice, adapter);
}

                      // --------------------------------
                      // struct Encoder_NullableValueUtil
                      // --------------------------------

// CLASS METHODS
template <class TYPE, class ACCESSOR>
int Encoder_NullableValueUtil::accessValueByCategory(const TYPE& nullableValue,
                                                     ACCESSOR&   accessor)
{
    Encoder_AccessSubObjectByCategoryCb<ACCESSOR> adapter(&accessor);
    return bdlat_NullableValueFunctions::accessValue(nullableValue, adapter);
}

template <class OUTPUT, class TYPE, class FUNCTION, class INFO_1>
int Encoder_NullableValueUtil::transformValueByCategory(
                                                OUTPUT          *output,
                                                const TYPE&      nullableValue,
                                                const FUNCTION&  function,
                                                const INFO_1&    info1)
{
    Encoder_TransformSubObjectByCategoryCb<OUTPUT, FUNCTION, INFO_1> adapter(
        output, &function, &info1);
    return Encoder_NullableValueUtil::accessValueByCategory(nullableValue,
                                                            adapter);
}

template <class OUTPUT, class TYPE, class FUNCTION, class INFO_1, class INFO_2>
int Encoder_NullableValueUtil::transformValueByCategory(
                                                OUTPUT          *output,
                                                const TYPE&      nullableValue,
                                                const FUNCTION&  function,
                                                const INFO_1&    info1,
                                                const INFO_2&    info2)
{
    Encoder_TransformSubObjectByCategoryCb<OUTPUT, FUNCTION, INFO_1, INFO_2>
        adapter(output, &function, &info1, &info2);
    return Encoder_NullableValueUtil::accessValueByCategory(nullableValue,
                                                            adapter);
}

                        // ---------------------------
                        // struct Encoder_SequenceUtil
                        // ---------------------------

// CLASS METHODS
template <class TYPE, class ACCESSOR>
int Encoder_SequenceUtil::accessAttributesByCategory(const TYPE& sequence,
                                                     ACCESSOR&   accessor)
{
    Encoder_AccessPropertyByCategoryCb<ACCESSOR> adapter(&accessor);
    return bdlat_SequenceFunctions::accessAttributes(sequence, adapter);
}

template <class OUTPUT, class TYPE, class FUNCTION>
int Encoder_SequenceUtil::foldAttributesByCategory(OUTPUT          *output,
                                                   const TYPE&      sequence,
                                                   const FUNCTION&  function,
                                                   const OUTPUT&    initial)
{
    *output = initial;
    Encoder_FoldAttributesByCategoryCb<OUTPUT, FUNCTION> adapter(
        output, &function, initial);
    return Encoder_SequenceUtil::accessAttributesByCategory(sequence, adapter);
}

            // ---------------------------------------------------
            // class Encoder_AccessSubObjectByCategoryCb<ACCESSOR>
            // ---------------------------------------------------

// CREATORS
template <class ACCESSOR>
Encoder_AccessSubObjectByCategoryCb<ACCESSOR>::
    Encoder_AccessSubObjectByCategoryCb(ACCESSOR *accessor)
: d_accessor_p(accessor)
{
}

// ACCESSORS
template <class ACCESSOR>
template <class VALUE>
int Encoder_AccessSubObjectByCategoryCb<ACCESSOR>::operator()(
                                                      const VALUE& value) const
{
    return bdlat_TypeCategoryUtil::accessByCategory(value, *d_accessor_p);
}

     // -----------------------------------------------------------------
     // class Encoder_AccessPropertyByCategoryCb<ACCESSOR, PROPERTY_INFO>
     // -----------------------------------------------------------------

// CREATORS
template <class ACCESSOR>
Encoder_AccessPropertyByCategoryCb<
    ACCESSOR>::Encoder_AccessPropertyByCategoryCb(ACCESSOR *accessor)
: d_accessor_p(accessor)
{
}

// ACCESSORS
template <class ACCESSOR>
template <class VALUE, class PROPERTY_INFO>
int Encoder_AccessPropertyByCategoryCb<ACCESSOR>::operator()(
                                       const VALUE&         value,
                                       const PROPERTY_INFO& propertyInfo) const
{
    Encoder_AccessPropertyByCategoryCbImp<ACCESSOR, PROPERTY_INFO> adapter(
        d_accessor_p, &propertyInfo);
    return bdlat_TypeCategoryUtil::accessByCategory(value, adapter);
}

    // --------------------------------------------------------------------
    // class Encoder_AccessPropertyByCategoryCbImp<ACCESSOR, PROPERTY_INFO>
    // --------------------------------------------------------------------

// CREATORS
template <class ACCESSOR, class PROPERTY_INFO>
Encoder_AccessPropertyByCategoryCbImp<ACCESSOR, PROPERTY_INFO>::
    Encoder_AccessPropertyByCategoryCbImp(ACCESSOR            *accessor,
                                          const PROPERTY_INFO *propertyInfo)
: d_accessor_p(accessor)
, d_propertyInfo_p(propertyInfo)
{
}

// ACCESSORS
template <class ACCESSOR, class PROPERTY_INFO>
template <class VALUE, class CATEGORY>
int Encoder_AccessPropertyByCategoryCbImp<ACCESSOR, PROPERTY_INFO>::operator()(
                                                   const VALUE& value,
                                                   CATEGORY     category) const
{
    return (*d_accessor_p)(value, *d_propertyInfo_p, category);
}

   // ---------------------------------------------------------------------
   // class Encoder_TransformByCategoryCb<OUTPUT, FUNCTION, INFO_1, INFO_2>
   // ---------------------------------------------------------------------

// CREATORS
template <class OUTPUT, class FUNCTION, class INFO_1, class INFO_2>
Encoder_TransformByCategoryCb<OUTPUT, FUNCTION, INFO_1, INFO_2>::
    Encoder_TransformByCategoryCb(OUTPUT         *output,
                                  const FUNCTION *function,
                                  const INFO_1   *info1,
                                  const INFO_2   *info2)
: d_output_p(output)
, d_function_p(function)
, d_info1_p(info1)
, d_info2_p(info2)
{
}

// ACCESSORS
template <class OUTPUT, class FUNCTION, class INFO_1, class INFO_2>
template <class VALUE, class CATEGORY>
int
Encoder_TransformByCategoryCb<OUTPUT, FUNCTION, INFO_1, INFO_2>::operator()(
                                                   const VALUE& value,
                                                   CATEGORY     category) const
{
    return (*d_function_p)(
        d_output_p, value, *d_info1_p, *d_info2_p, category);
}

       // -------------------------------------------------------------
       // class Encoder_TransformByCategoryCb<OUTPUT, FUNCTION, INFO_1>
       // -------------------------------------------------------------

// CREATORS
template <class OUTPUT, class FUNCTION, class INFO_1>
Encoder_TransformByCategoryCb<OUTPUT, FUNCTION, INFO_1, bslmf::Nil>::
    Encoder_TransformByCategoryCb(OUTPUT         *output,
                                  const FUNCTION *function,
                                  const INFO_1   *info1)
: d_output_p(output)
, d_function_p(function)
, d_info1_p(info1)
{
}

// ACCESSORS
template <class OUTPUT, class FUNCTION, class INFO_1>
template <class VALUE, class CATEGORY>
int Encoder_TransformByCategoryCb<OUTPUT, FUNCTION, INFO_1, bslmf::Nil>::
operator()(const VALUE& value, CATEGORY category) const
{
    return (*d_function_p)(d_output_p, value, *d_info1_p, category);
}

           // -----------------------------------------------------
           // class Encoder_TransformByCategoryCb<OUTPUT, FUNCTION>
           // -----------------------------------------------------

// CREATORS
template <class OUTPUT, class FUNCTION>
Encoder_TransformByCategoryCb<OUTPUT, FUNCTION, bslmf::Nil, bslmf::Nil>::
    Encoder_TransformByCategoryCb(OUTPUT *output, const FUNCTION *function)
: d_output_p(output)
, d_function_p(function)
{
}

// ACCESSORS
template <class OUTPUT, class FUNCTION>
template <class VALUE, class CATEGORY>
int Encoder_TransformByCategoryCb<OUTPUT, FUNCTION, bslmf::Nil, bslmf::Nil>::
operator()(const VALUE& value, CATEGORY category) const
{
    return (*d_function_p)(d_output_p, value, category);
}

// ---------------------------------------------------------------------------
// class Encoder_TransformPropertyByCategoryCb<OUTPUT, FUNCTION, PROP, INFO_1>
// ---------------------------------------------------------------------------

// CREATORS
template <class OUTPUT, class FUNCTION, class INFO_1>
Encoder_TransformPropertyByCategoryCb<OUTPUT, FUNCTION, INFO_1>::
    Encoder_TransformPropertyByCategoryCb(OUTPUT         *output,
                                          const FUNCTION *function,
                                          const INFO_1   *info1)
: d_output_p(output)
, d_function_p(function)
, d_info1_p(info1)
{
}

// ACCESSORS
template <class OUTPUT, class FUNCTION, class INFO_1>
template <class VALUE, class PROPERTY_INFO, class CATEGORY>
int
Encoder_TransformPropertyByCategoryCb<OUTPUT, FUNCTION, INFO_1>::operator()(
                                           const VALUE&         value,
                                           const PROPERTY_INFO& propertyInfo,
                                           CATEGORY             category) const
{
    return (*d_function_p)(
        d_output_p, value, propertyInfo, *d_info1_p, category);
}

    // -------------------------------------------------------------------
    // class Encoder_TransformPropertyByCategoryCb<OUTPUT, FUNCTION, PROP>
    // -------------------------------------------------------------------

// CREATORS
template <class OUTPUT, class FUNCTION>
Encoder_TransformPropertyByCategoryCb<OUTPUT, FUNCTION, bslmf::Nil>::
    Encoder_TransformPropertyByCategoryCb(OUTPUT         *output,
                                          const FUNCTION *function)
: d_output_p(output)
, d_function_p(function)
{
}

// ACCESSORS
template <class OUTPUT, class FUNCTION>
template <class VALUE, class PROPERTY_INFO, class CATEGORY>
int Encoder_TransformPropertyByCategoryCb<OUTPUT, FUNCTION, bslmf::Nil>::
operator()(const VALUE&         value,
           const PROPERTY_INFO& propertyInfo,
           CATEGORY             category) const
{
    return (*d_function_p)(d_output_p, value, propertyInfo, category);
}

   // ----------------------------------------------------------------------
   // class Encoder_TransformSubObjectByCategoryCb<OUT, FUN, INFO_1, INFO_2>
   // ----------------------------------------------------------------------

// CREATORS
template <class OUTPUT, class FUNCTION, class INFO_1, class INFO_2>
Encoder_TransformSubObjectByCategoryCb<OUTPUT, FUNCTION, INFO_1, INFO_2>::
    Encoder_TransformSubObjectByCategoryCb(OUTPUT         *output,
                                           const FUNCTION *function,
                                           const INFO_1   *info1,
                                           const INFO_2   *info2)
: d_output_p(output)
, d_function_p(function)
, d_info1_p(info1)
, d_info2_p(info2)
{
}

// ACCESSORS
template <class OUTPUT, class FUNCTION, class INFO_1, class INFO_2>
template <class VALUE, class CATEGORY>
int Encoder_TransformSubObjectByCategoryCb<OUTPUT, FUNCTION, INFO_1, INFO_2>::
operator()(const VALUE& value, CATEGORY category) const
{
    return (*d_function_p)(
        d_output_p, value, *d_info1_p, *d_info2_p, category);
}

    // --------------------------------------------------------------------
    // class Encoder_TransformSubObjectByCategoryCb<OUTPUT, FUNCTION, INFO>
    // --------------------------------------------------------------------

// CREATORS
template <class OUTPUT, class FUNCTION, class INFO_1>
Encoder_TransformSubObjectByCategoryCb<OUTPUT, FUNCTION, INFO_1, bslmf::Nil>::
    Encoder_TransformSubObjectByCategoryCb(OUTPUT         *output,
                                           const FUNCTION *function,
                                           const INFO_1   *info1)
: d_output_p(output)
, d_function_p(function)
, d_info1_p(info1)
{
}

// ACCESSORS
template <class OUTPUT, class FUNCTION, class INFO_1>
template <class VALUE, class CATEGORY>
int Encoder_TransformSubObjectByCategoryCb<OUTPUT,
                                           FUNCTION,
                                           INFO_1,
                                           bslmf::Nil>::
operator()(const VALUE& value, CATEGORY category) const
{
    return (*d_function_p)(d_output_p, value, *d_info1_p, category);
}

       // --------------------------------------------------------------
       // class Encoder_TransformSubObjectByCategoryCb<OUTPUT, FUNCTION>
       // --------------------------------------------------------------

// CREATORS
template <class OUTPUT, class FUNCTION>
Encoder_TransformSubObjectByCategoryCb<OUTPUT, FUNCTION, bslmf::Nil>::
    Encoder_TransformSubObjectByCategoryCb(OUTPUT         *output,
                                           const FUNCTION *function)
: d_output_p(output)
, d_function_p(function)
{
}

// ACCESSORS
template <class OUTPUT, class FUNCTION>
template <class VALUE, class CATEGORY>
int Encoder_TransformSubObjectByCategoryCb<OUTPUT, FUNCTION, bslmf::Nil>::
operator()(const VALUE& value, CATEGORY category) const
{
    return (*d_function_p)(d_output_p, value, category);
}

         // ----------------------------------------------------------
         // class Encoder_FoldAttributesByCategoryCb<OUTPUT, FUNCTION>
         // ----------------------------------------------------------

// CREATORS
template <class OUTPUT, class FUNCTION>
Encoder_FoldAttributesByCategoryCb<OUTPUT, FUNCTION>::
    Encoder_FoldAttributesByCategoryCb(OUTPUT         *output,
                                         const FUNCTION *function,
                                         const OUTPUT&   initial)
: d_output_p(output)
, d_function_p(function)
, d_accumulator(initial)
{
}

// ACCESSORS
template <class OUTPUT, class FUNCTION>
template <class VALUE, class ATTRIBUTE_INFO, class CATEGORY>
int Encoder_FoldAttributesByCategoryCb<OUTPUT, FUNCTION>::operator()(
                                           const VALUE&          attribute,
                                           const ATTRIBUTE_INFO& attributeInfo,
                                           CATEGORY              category)
{
    const int rc = (*d_function_p)(
        d_output_p, attribute, attributeInfo, d_accumulator, category);
    if (0 != rc) {
        return rc;                                                    // RETURN
    }

    d_accumulator = *d_output_p;
    return 0;
}

// The 'Encoder_Formatter' 'class' has been replaced by the 'baljsn::Formatter'
// 'class' in the 'baljsn_formatter' component.  Clients should use that
// 'class' instead.  The following 'class' definition is provided for
// backwards-compatibility for users that have written code using this
// component-private 'class'.

                          // =======================
                          // class Encoder_Formatter
                          // =======================

class Encoder_Formatter {
    // This class implements a formatter providing operations for rending JSON
    // text elements to an output stream (supplied at construction) according
    // to a set of formatting options (also supplied at construction).  This is
    // a component-private class and should not be used outside of this
    // component.
    //
    // DEPRECATED: Use 'baljsn::Formatter' instead.

    // DATA
    bsl::ostream& d_outputStream;     // stream for output (held, not owned)
    bool          d_usePrettyStyle;   // encoding style
    int           d_indentLevel;      // initial indent level
    int           d_spacesPerLevel;   // spaces per level
    bool          d_isArrayElement;   // is current element part of an array

  public:
    // CREATORS
    Encoder_Formatter(bsl::ostream& stream, const EncoderOptions& options);
        // Create a 'Encoder_Formatter' object using the specified 'stream' and
        // 'options'.

    //! ~Encoder_Formatter() = default;
        // Destroy this object.

    // MANIPULATORS
    void openObject();
        // Print onto the stream supplied at construction the sequence of
        // characters designating the start of an object.

    void closeObject();
        // Print onto the stream supplied at construction the sequence of
        // characters designating the end of an object.

    void openArray(bool formatAsEmptyArrayFlag = false);
        // Print onto the stream supplied at construction the sequence of
        // characters designating the start of an array.  Optionally specify
        // 'formatAsEmptyArrayFlag' denoting if the array being opened should
        // be formatted as an empty array.  If 'formatAsEmptyArrayFlag' is not
        // specified then the array being opened is formatted as an array
        // having elements.  Note that the formatting (and as a consequence the
        // 'formatAsEmptyArrayFlag') is relevant only if this formatter encodes
        // in the pretty style and is ignored otherwise.

    void closeArray(bool formatAsEmptyArrayFlag = false);
        // Print onto the stream supplied at construction the sequence of
        // characters designating the end of an array.  Optionally specify
        // 'formatAsEmptyArrayFlag' denoting if the array being closed should
        // be formatted as an empty array.  If 'formatAsEmptyArrayFlag' is not
        // specified then the array being closed is formatted as an array
        // having elements.  Note that the formatting (and as a consequence the
        // 'formatAsEmptyArrayFlag') is relevant only if this formatter encodes
        // in the pretty style and is ignored otherwise.

    void indent();
        // Print onto the stream supplied at construction the sequence of
        // whitespace characters for the proper indentation of an element given
        // the encoding options supplied at construction.

    int openElement(const bsl::string& name);
        // Print onto the stream supplied at construction the sequence of
        // characters designating the start of an element having the specified
        // 'name'.  Return 0 on success and a non-zero value otherwise.

    void closeElement();
        // Print onto the stream supplied at construction the sequence of
        // characters designating the end of an element.

    void openDocument();
        // Print onto the stream supplied at construction the sequence of
        // characters designating the start of the document.

    void closeDocument();
        // Print onto the stream supplied at construction the sequence of
        // characters designating the end of the document.

    void setIsArrayElement(bool isArrayElement);
        // Set the flag denoting if the current element refers to an array
        // element to the specified 'isArrayElement'.

    // ACCESSORS
    bool isArrayElement() const;
        // Return the value of the flag denoting if the current element refers
        // to an array element.
};

                        // -----------------------
                        // class Encoder_Formatter
                        // -----------------------

// MANIPULATORS
inline
void Encoder_Formatter::setIsArrayElement(bool isArrayElement)
{
    d_isArrayElement = isArrayElement;
}

// ACCESSORS
inline
bool Encoder_Formatter::isArrayElement() const
{
    return d_isArrayElement;
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
