// bslma_constructionutil_cpp03.h                                     -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BSLMA_CONSTRUCTIONUTIL_CPP03
#define INCLUDED_BSLMA_CONSTRUCTIONUTIL_CPP03

//@PURPOSE: Provide C++03 implementation for bslma_constructionutil.h
//
//@CLASSES: See bslma_constructionutil.h for list of classes
//
//@SEE_ALSO: bslma_constructionutil
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Thu Jun  8 12:15:23 2023
// Command line: sim_cpp11_features.pl bslma_constructionutil.h

#ifdef COMPILING_BSLMA_CONSTRUCTIONUTIL_H

namespace BloombergLP {
namespace bslma {

// Workaround for optimization issue in xlC that mishandles pointer aliasing.
//   IV56864: ALIASING BEHAVIOUR FOR PLACEMENT NEW
//   http://www-01.ibm.com/support/docview.wss?uid=swg1IV56864
// Place this macro following each use of placement new.  Alternatively,
// compile with xlC_r -qalias=noansi, which reduces optimization opportunities
// across entire translation unit instead of simply across optimization fence.
// Update: issue is fixed in xlC 13.1 (__xlC__ >= 0x0d01).

#if defined(BSLS_PLATFORM_CMP_IBM) && BSLS_PLATFORM_CMP_VERSION < 0x0d01
    #define BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX                     \
                             BSLS_PERFORMANCEHINT_OPTIMIZATION_FENCE
#else
    #define BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX
#endif

struct ConstructionUtil_Imp;

                          // =======================
                          // struct ConstructionUtil
                          // =======================

struct ConstructionUtil {
    // This 'struct' provides a namespace for utility functions that construct
    // elements of (a template parameter) 'TARGET_TYPE'.

  private:
    // PRIVATE TYPES
    typedef ConstructionUtil_Imp Imp;
        // This 'typedef' is a convenient alias for the implementation-specific
        // utility class defined in this component.

  public:
    // CLASS METHODS
    template <class TARGET_TYPE>
    static void construct(TARGET_TYPE *address, bslma::Allocator *allocator);
    template <class TARGET_TYPE>
    static void construct(TARGET_TYPE *address, void *allocator);
        // Create a default-constructed object of (template parameter)
        // 'TARGET_TYPE' at the specified 'address'.  If 'allocator' is of type
        // 'bslma::Allocator' and 'TARGET_TYPE' supports 'bslma'-style
        // allocation, 'allocator' is passed to the default constructor.  If
        // the constructor throws, the memory at 'address' is left in an
        // unspecified state.  Note that this operation may bypass the call to
        // the default constructor of a user-defined type entirely if
        // 'TARGET_TYPE' 1) does not use 'bslma'-style allocators and 2) has a
        // trivial default constructor.

    template <class TARGET_TYPE>
    static void construct(TARGET_TYPE        *address,
                          bslma::Allocator   *allocator,
                          const TARGET_TYPE&  original);
    template <class TARGET_TYPE>
    static void
    construct(TARGET_TYPE *address, void *, const TARGET_TYPE& original);
    template <class TARGET_TYPE>
    static void construct(TARGET_TYPE        *address,
                          bslma::Allocator   *allocator,
                          TARGET_TYPE&        original);
    template <class TARGET_TYPE>
    static void
    construct(TARGET_TYPE *address, void *, TARGET_TYPE& original);
        // Create an object of (template parameter) 'TARGET_TYPE', having
        // the same value as the specified 'original' object, at the specified
        // 'address'.  If 'allocator' is of type 'bslma::Allocator' and
        // 'TARGET_TYPE' supports 'bslma'-style allocation, 'allocator' is
        // propagated to the newly created object.  If a constructor throws,
        // the memory at 'address' is left in an unspecified state.  Note that
        // this operation may elide the call to the copy constructor entirely
        // if 'TARGET_TYPE' 1) does not use 'bslma'-style allocators and 2) is
        // trivially copyable.  Further note that we provide (unconventional)
        // overloads for modifiable lvalues because these may match more
        // generic overloads (below) taking a variable number of deduced
        // template parameters.

    template <class TARGET_TYPE>
    static void construct(TARGET_TYPE                    *address,
                          bslma::Allocator               *allocator,
                          bslmf::MovableRef<TARGET_TYPE>  original);
    template <class TARGET_TYPE>
    static void construct(TARGET_TYPE                    *address,
                          void                           *allocator,
                          bslmf::MovableRef<TARGET_TYPE>  original);
        // Create an object of (template parameter) 'TARGET_TYPE', having
        // the same value as the specified 'original' object, at the specified
        // 'address'.  'original' is left in a valid but unspecified state.  If
        // the specified 'allocator' is of type 'bslma::Allocator' and
        // 'TARGET_TYPE' supports 'bslma'-style allocation, 'allocator' is
        // propagated to the newly created object.  If a constructor throws,
        // the memory at 'address' is left in an unspecified state.  Note that
        // this operation may elide the call to the copy constructor entirely
        // if 'TARGET_TYPE' 1) does not use 'bslma'-style allocators and 2) is
        // trivially copyable.  Further note that we provide (unconventional)
        // overloads for modifiable lvalues because these may match more
        // generic overloads (below) taking a variable number of deduced
        // template parameters.

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_constructionutil.h
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT 15
#endif
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#endif
#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 0
    template <class TARGET_TYPE, class ARG1>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 1
    template <class TARGET_TYPE, class ARG1, class ARGS_01>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 2
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 3
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 4
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 5
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 6
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 7
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 8
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 9
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 10
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 11
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 12
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 13
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12,
                                             class ARGS_13>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 13

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 14
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12,
                                             class ARGS_13,
                                             class ARGS_14>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 14

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 15
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12,
                                             class ARGS_13,
                                             class ARGS_14,
                                             class ARGS_15>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_15) arguments_15);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 15

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 0
    template <class TARGET_TYPE, class ARG1>
    static void construct(TARGET_TYPE *address,
                          void        *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 1
    template <class TARGET_TYPE, class ARG1, class ARGS_01>
    static void construct(TARGET_TYPE *address,
                          void        *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 2
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02>
    static void construct(TARGET_TYPE *address,
                          void        *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 3
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03>
    static void construct(TARGET_TYPE *address,
                          void        *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 4
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04>
    static void construct(TARGET_TYPE *address,
                          void        *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 5
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05>
    static void construct(TARGET_TYPE *address,
                          void        *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 6
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06>
    static void construct(TARGET_TYPE *address,
                          void        *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 7
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07>
    static void construct(TARGET_TYPE *address,
                          void        *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 8
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08>
    static void construct(TARGET_TYPE *address,
                          void        *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 9
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09>
    static void construct(TARGET_TYPE *address,
                          void        *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 10
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10>
    static void construct(TARGET_TYPE *address,
                          void        *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 11
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11>
    static void construct(TARGET_TYPE *address,
                          void        *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 12
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12>
    static void construct(TARGET_TYPE *address,
                          void        *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 13
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12,
                                             class ARGS_13>
    static void construct(TARGET_TYPE *address,
                          void        *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 13

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 14
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12,
                                             class ARGS_13,
                                             class ARGS_14>
    static void construct(TARGET_TYPE *address,
                          void        *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 14

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 15
    template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12,
                                             class ARGS_13,
                                             class ARGS_14,
                                             class ARGS_15>
    static void construct(TARGET_TYPE *address,
                          void        *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_15) arguments_15);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_A >= 15

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template <class TARGET_TYPE, class ARG1, class... ARGS>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments);
    template <class TARGET_TYPE, class ARG1, class... ARGS>
    static void construct(TARGET_TYPE *address,
                          void        *allocator,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments);
// }}} END GENERATED CODE
#endif

    template <class TARGET_TYPE, class ALLOCATOR>
    static void destructiveMove(TARGET_TYPE *address,
                                ALLOCATOR   *allocator,
                                TARGET_TYPE *original);
        // Create an object of (template parameter) 'TARGET_TYPE' at the
        // specified 'address' having the same value as the object at the
        // specified 'original' address, propagating the specified 'allocator'
        // to the moved object if 'TARGET_TYPE' uses 'bslma'-style allocation
        // and the (template parameter) type 'ALLOCATOR' is implicitly
        // convertible to 'bslma::Allocator', and destroy 'original'.  If the
        // move constructor throws an exception, the memory at 'address' is
        // left in an unspecified state and 'original' is left in a valid but
        // unspecified state.  The behavior is undefined unless either
        // 'TARGET_TYPE' does not support 'bslma'-style allocation or
        // 'original' uses 'allocator' to supply memory.  Note that this class
        // method is equivalent to move-constructing an object at 'address'
        // from '*original' and then destroying 'original', except that this
        // method elides the calls to the constructor and destructor for
        // objects that are bitwise movable.  Also note that if 'original'
        // actually points to an object of a type derived from 'TARGET_TYPE'
        // (i.e., a slicing move) where 'TARGET_TYPE' has a non-'virtual'
        // destructor and is not bitwise-movable, then 'original' will be only
        // partially destroyed.

#if defined(BSLS_COMPILERFEATURES_GUARANTEED_COPY_ELISION)
    template <class TARGET_TYPE>
    static TARGET_TYPE make(bslma::Allocator *allocator);
    template <class TARGET_TYPE>
    static TARGET_TYPE make(void             *allocator);
        // Return, by value, an object of the specified (template parameter)
        // 'TARGET_TYPE', having default value.  If the specified 'allocator'
        // is a pointer to a class derived from 'bslma::Allocator *' and
        // 'TARGET_TYPE' supports 'bslma'-style allocation, 'allocator' is
        // propagated to the newly created object; otherwise, 'allocator' is
        // ignored.  Note that this method is available only for compilers that
        // reliably implement copy/move elision (i.e., RVO) on the returned
        // object.  This copy/move elision is required starting with C++17 and
        // is widely implemented, though optional, prior to C++17.

    template <class TARGET_TYPE, class ANY_TYPE>
    static TARGET_TYPE make(
                        bslma::Allocator                            *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ANY_TYPE)  argument);
    template <class TARGET_TYPE,class ANY_TYPE>
    static TARGET_TYPE make(
                        void                                        *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ANY_TYPE)  argument);
        // Return, by value, an object of the specified (template parameter)
        // 'TARGET_TYPE', constructed from the specified 'argument'.  If the
        // specified 'allocator' is a pointer to a class derived from
        // 'bslma::Allocator *' and 'TARGET_TYPE' supports 'bslma'-style
        // allocation, 'allocator' is propagated to the newly created object;
        // otherwise, 'allocator' is ignored.  Note that this method is
        // available only for compilers that reliably implement copy/move
        // elision (i.e., RVO) on the returned object.  This copy/move elision
        // is required starting with C++17 and is widely implemented, though
        // optional, prior to C++17.

#endif // defined(BSLS_COMPILERFEATURES_GUARANTEED_COPY_ELISION)

};
                        // ===========================
                        // struct ConstructionUtil_Imp
                        // ===========================

struct ConstructionUtil_Imp {
    // This 'struct' provides a namespace for a suite of utility functions that
    // are used to implement functions in 'ConstructionUtil'.  In particular,
    // they provide overloads, resolved at compile-time, for various features
    // (e.g., passing down the allocator to sub-elements of 'pair'-like types)
    // and optimizations (e.g., bypassing the call to the constructor for
    // classes with trivial default and copy constructors).  These functions
    // should not be used outside this component.

    // TYPES
    enum {
        // These constants are used in the overloads below, when the last
        // argument is of type 'bsl::integral_constant<int, N> *', indicating
        // that 'TARGET_TYPE' has the traits for which the enumerator equal to
        // 'N' is named.

        e_USES_ALLOCATOR_ARG_T_TRAITS     = 5, // Implies USES_BSLMA_ALLOCATOR
        e_USES_BSLMA_ALLOCATOR_TRAITS     = 4,
        e_HAS_TRIVIAL_DEFAULT_CTOR_TRAITS = 3,
        e_BITWISE_COPYABLE_TRAITS         = 2,
        e_BITWISE_MOVABLE_TRAITS          = 1,
        e_NIL_TRAITS                      = 0
    };

    // CLASS METHODS
    template <class TARGET_TYPE>
    static void construct(
             TARGET_TYPE      *address,
             bslma::Allocator *allocator,
             bsl::integral_constant<int, e_HAS_TRIVIAL_DEFAULT_CTOR_TRAITS> *);

    template <class TARGET_TYPE>
    static void construct(
             TARGET_TYPE *address,
             bsl::integral_constant<int, e_HAS_TRIVIAL_DEFAULT_CTOR_TRAITS> *);
        // Construct a default instance of (template parameter) 'TARGET_TYPE'
        // that has a trivial default constructor, at the specified 'address'.
        // If the constructor throws, the memory at 'address' is left in an
        // unspecified state.  Note that the behavior is undefined if
        // 'TARGET_TYPE' supports 'bslma'-style allocators.

    // In order to implement:
    //   'allocator_traits<A>::construct(m, p, rv)'
    //   'allocator_traits<A>::construct(m, p,  v)'
    // if 'e_BITWISE_COPYABLE_TRAITS'.

    template <class TARGET_TYPE>
    static void
    construct(TARGET_TYPE        *address,
              bslma::Allocator   *allocator,
              bsl::integral_constant<int, e_BITWISE_COPYABLE_TRAITS> *,
              const TARGET_TYPE&  original);

    template <class TARGET_TYPE>
    static void
    construct(TARGET_TYPE        *address,
              bsl::integral_constant<int, e_BITWISE_COPYABLE_TRAITS> *,
              const TARGET_TYPE&  original);
        // Create an object of a bitwise copyable (template parameter)
        // 'TARGET_TYPE' at the specified 'address', with the same value as the
        // specified 'original' object.  If the constructor throws, the memory
        // at 'address' is left in an unspecified state.  Note that the
        // behavior is undefined if 'TARGET_TYPE' supports 'bslma'-style
        // allocators.

    template <class TARGET_TYPE>
    static void
    construct(
             TARGET_TYPE                                            *address,
             bslma::Allocator                                       *allocator,
             bsl::integral_constant<int, e_BITWISE_COPYABLE_TRAITS> *,
             bslmf::MovableRef<TARGET_TYPE>                          original);
    template <class TARGET_TYPE>
    static void
    construct(
             TARGET_TYPE                                            *address,
             bsl::integral_constant<int, e_BITWISE_COPYABLE_TRAITS> *,
             bslmf::MovableRef<TARGET_TYPE>                          original);
        // Create an object of a bitwise moveable (template parameter)
        // 'TARGET_TYPE' at the specified 'address', with the same value as the
        // specified 'original' object.  If the constructor throws, the memory
        // at 'address' is left in an unspecified state.  Note that the
        // behavior is undefined if 'TARGET_TYPE' supports 'bslma'-style
        // allocators.

    // In order to implement:
    //   'allocator_traits<A>::construct(m, p    )'
    //   'allocator_traits<A>::construct(m, p, rv)'
    //   'allocator_traits<A>::construct(m, p,  v)'
    // if 'e_USES_BSLMA_ALLOCATOR_TRAITS', and:
    //   'allocator_traits<A>::construct(m, p, args)'

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_constructionutil.h
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT 15
#endif
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#endif
#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 0
    template <class TARGET_TYPE>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 1
    template <class TARGET_TYPE, class ARGS_01>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 2
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 3
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 4
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 5
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 6
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 7
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 8
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 9
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 10
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 11
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 12
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 13
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 13

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 14
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13,
                                 class ARGS_14>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 14

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 15
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13,
                                 class ARGS_14,
                                 class ARGS_15>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_15) arguments_15);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 15

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 0
    template <class TARGET_TYPE>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 1
    template <class TARGET_TYPE, class ARGS_01>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 2
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 3
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 4
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 5
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 6
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 7
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 8
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 9
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 10
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 11
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 12
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 13
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 13

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 14
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13,
                                 class ARGS_14>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 14

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 15
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13,
                                 class ARGS_14,
                                 class ARGS_15>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_15) arguments_15);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 15


#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 0
    template <class TARGET_TYPE>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          bsl::integral_constant<int, e_NIL_TRAITS> *);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 1
    template <class TARGET_TYPE, class ARGS_01>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 2
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 3
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 4
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 5
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 6
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 7
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 8
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 9
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 10
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 11
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 12
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 13
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 13

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 14
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13,
                                 class ARGS_14>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 14

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 15
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13,
                                 class ARGS_14,
                                 class ARGS_15>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_15) arguments_15);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 15


#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 0
    template <class TARGET_TYPE>
    static void construct(TARGET_TYPE      *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 1
    template <class TARGET_TYPE, class ARGS_01>
    static void construct(TARGET_TYPE      *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 2
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02>
    static void construct(TARGET_TYPE      *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 3
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03>
    static void construct(TARGET_TYPE      *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 4
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04>
    static void construct(TARGET_TYPE      *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 5
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05>
    static void construct(TARGET_TYPE      *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 6
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06>
    static void construct(TARGET_TYPE      *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 7
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07>
    static void construct(TARGET_TYPE      *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 8
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08>
    static void construct(TARGET_TYPE      *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 9
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09>
    static void construct(TARGET_TYPE      *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 10
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10>
    static void construct(TARGET_TYPE      *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 11
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11>
    static void construct(TARGET_TYPE      *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 12
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12>
    static void construct(TARGET_TYPE      *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 13
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13>
    static void construct(TARGET_TYPE      *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 13

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 14
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13,
                                 class ARGS_14>
    static void construct(TARGET_TYPE      *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 14

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 15
    template <class TARGET_TYPE, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13,
                                 class ARGS_14,
                                 class ARGS_15>
    static void construct(TARGET_TYPE      *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14,
                      BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_15) arguments_15);
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_B >= 15

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template <class TARGET_TYPE, class... ARGS>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments);
    template <class TARGET_TYPE, class... ARGS>
    static void construct(
                  TARGET_TYPE      *address,
                  bslma::Allocator *allocator,
                  bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments);

    template <class TARGET_TYPE, class... ARGS>
    static void construct(TARGET_TYPE      *address,
                          bslma::Allocator *allocator,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments);

    template <class TARGET_TYPE, class... ARGS>
    static void construct(TARGET_TYPE      *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments);
// }}} END GENERATED CODE
#endif

#if defined(BSLS_PLATFORM_CMP_MSVC) && BSLS_PLATFORM_CMP_VERSION < 1900
    template <class TARGET_TYPE>
    static void defaultConstructScalar(bsl::false_type, TARGET_TYPE *address);
        // Value-initialize a scalar object of the (template parameter)
        // 'TARGET_TYPE' at the specified 'address'.  The unused
        // 'bsl::false_type' value indicates that the scalar 'TARGET_TYPE' is
        // not a pointer-to-member.

    template <class TARGET_TYPE>
    static void defaultConstructScalar(bsl::true_type, TARGET_TYPE *address);
        // Value-initialize a pointer-to-member at the specified 'address' to
        // the null pointer value.  Note that early versions of the Microsoft
        // Visual C++ compiler would fail to initialize such an object when
        // requested with the simple value-initialization syntax of
        // 'new (address) TYPE();', requiring this additional workaround.
#endif

    template <class TARGET_TYPE, class ALLOCATOR>
    static void destructiveMove(
              TARGET_TYPE                                           *address,
              ALLOCATOR                                             *allocator,
              bsl::integral_constant<int, e_BITWISE_MOVABLE_TRAITS> *,
              TARGET_TYPE                                           *original);
        // Move the bitwise movable object of (template parameter)
        // 'TARGET_TYPE' at the specified 'original' address to the specified
        // 'address', eliding the call to the move constructor and destructor
        // in favor of performing a bitwise copy.  The behavior is undefined
        // unless either 'TARGET_TYPE' does not support 'bslma'-style
        // allocation or 'original' uses the specified 'allocator' to supply
        // memory.

    template <class TARGET_TYPE, class ALLOCATOR>
    static void destructiveMove(
                          TARGET_TYPE                               *address,
                          ALLOCATOR                                 *allocator,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                          TARGET_TYPE                               *original);
        // Create an object of (template parameter) 'TARGET_TYPE' at the
        // specified 'address' having the same value as the object at the
        // specified 'original' address, propagating the specified 'allocator'
        // to the moved object if 'TARGET_TYPE' uses 'bslma'-style allocation
        // and the (template parameter) type 'ALLOCATOR' is implicitly
        // convertible to 'bslma::Allocator', and destroy 'original'.  If the
        // move constructor throws an exception, the memory at 'address' is
        // left in an unspecified state and 'original' is left in a valid but
        // unspecified state.  The behavior is undefined unless either
        // 'TARGET_TYPE' does not support 'bslma'-style allocation or
        // 'original' uses 'allocator' to supply memory.  Note that this class
        // method is equivalent to move-constructing an object at 'address'
        // from '*original' and then destroying 'original'.  Also note that if
        // 'original' actually points to an object of a type derived from
        // 'TARGET_TYPE' (i.e., a slicing move) where 'TARGET_TYPE' has a
        // non-'virtual' destructor, then 'original' will be only partially
        // destroyed.

#if defined(BSLS_COMPILERFEATURES_GUARANTEED_COPY_ELISION)
    template <class TARGET_TYPE>
    static TARGET_TYPE make(
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *);
    template <class TARGET_TYPE>
    static TARGET_TYPE make(
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *);
    template <class TARGET_TYPE>
    static TARGET_TYPE make(bslma::Allocator *allocator,
                            bsl::integral_constant<int, e_NIL_TRAITS> *);
        // Return, by value, a default-constructed object of the specified
        // (template parameter) 'TARGET_TYPE', using the specified 'allocator'
        // to supply memory.  The 'integral_constant' pointer argument is used
        // to dispatch on various traits so that the correct constructor is
        // invoked for the specified 'TARGET_TYPE'.

    template <class TARGET_TYPE, class ANY_TYPE>
    static TARGET_TYPE make(
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ANY_TYPE)                 argument);
    template <class TARGET_TYPE, class ANY_TYPE>
    static TARGET_TYPE make(
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ANY_TYPE)                 argument);
    template <class TARGET_TYPE, class ANY_TYPE>
    static TARGET_TYPE make(
                        bslma::Allocator                            *allocator,
                        bsl::integral_constant<int, e_NIL_TRAITS>   *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(ANY_TYPE)  argument);
        // Return, by value, an object of the specified (template parameter)
        // 'TARGET_TYPE', constructed from the specified 'argument' object,
        // using the specified 'allocator' to supply memory.  The
        // 'integral_constant' pointer argument is used to dispatch on various
        // traits so that the correct constructor is invoked for the specified
        // 'TARGET_TYPE'.

#endif // defined(BSLS_COMPILERFEATURES_GUARANTEED_COPY_ELISION)

    template <class TARGET_TYPE>
    static void *voidify(TARGET_TYPE *address);
        // Return the specified 'address' cast as a pointer to 'void', even if
        // the (template parameter) 'TARGET_TYPE' is cv-qualified.
};

// ============================================================================
//                      TEMPLATE FUNCTION DEFINITIONS
// ============================================================================

                          // -----------------------
                          // struct ConstructionUtil
                          // -----------------------

// CLASS METHODS
template <class TARGET_TYPE>
inline
void
ConstructionUtil::construct(TARGET_TYPE      *address,
                            bslma::Allocator *allocator)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                 ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                 : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : bsl::is_trivially_default_constructible<TARGET_TYPE>::value
                    ? Imp::e_HAS_TRIVIAL_DEFAULT_CTOR_TRAITS
                    : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   allocator,
                   (bsl::integral_constant<int, k_VALUE>*)0);
}

template <class TARGET_TYPE>
inline
void
ConstructionUtil::construct(TARGET_TYPE *address,
                            void        *)
{
    enum {
        k_VALUE = bsl::is_trivially_default_constructible<TARGET_TYPE>::value
                ? Imp::e_HAS_TRIVIAL_DEFAULT_CTOR_TRAITS
                : Imp::e_NIL_TRAITS
    };
    Imp::construct(address, (bsl::integral_constant<int, k_VALUE>*)0);
}

template <class TARGET_TYPE>
inline
void ConstructionUtil::construct(TARGET_TYPE        *address,
                                 bslma::Allocator   *allocator,
                                 const TARGET_TYPE&  original)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                 ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                 : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : bslmf::IsBitwiseCopyable<TARGET_TYPE>::value
                    ? Imp::e_BITWISE_COPYABLE_TRAITS
                    : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   allocator,
                   (bsl::integral_constant<int, k_VALUE> *)0,
                   original);
}

template <class TARGET_TYPE>
inline
void ConstructionUtil::construct(TARGET_TYPE      *address,
                                 bslma::Allocator *allocator,
                                 TARGET_TYPE&      original)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                 ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                 : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : bslmf::IsBitwiseCopyable<TARGET_TYPE>::value
                    ? Imp::e_BITWISE_COPYABLE_TRAITS
                    : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   allocator,
                   (bsl::integral_constant<int, k_VALUE> *)0,
                   original);
}

template <class TARGET_TYPE>
inline
void ConstructionUtil::construct(TARGET_TYPE        *address,
                                 void               *,
                                 const TARGET_TYPE&  original)
{
    enum {
        k_VALUE = bslmf::IsBitwiseCopyable<TARGET_TYPE>::value
                ? Imp::e_BITWISE_COPYABLE_TRAITS
                : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   (bsl::integral_constant<int, k_VALUE>*)0,
                   original);
}

template <class TARGET_TYPE>
inline
void ConstructionUtil::construct(TARGET_TYPE  *address,
                                 void         *,
                                 TARGET_TYPE&  original)
{
    enum {
        k_VALUE = bslmf::IsBitwiseCopyable<TARGET_TYPE>::value
                ? Imp::e_BITWISE_COPYABLE_TRAITS
                : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   (bsl::integral_constant<int, k_VALUE>*)0,
                   original);
}

template <class TARGET_TYPE>
inline
void ConstructionUtil::construct(TARGET_TYPE                    *address,
                                 bslma::Allocator               *allocator,
                                 bslmf::MovableRef<TARGET_TYPE>  original)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                 ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                 : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : bslmf::IsBitwiseCopyable<TARGET_TYPE>::value
                 ? Imp::e_BITWISE_COPYABLE_TRAITS
                 : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   allocator,
                   (bsl::integral_constant<int, k_VALUE> *)0,
                   BSLS_COMPILERFEATURES_FORWARD(TARGET_TYPE, original));
}

template <class TARGET_TYPE>
inline
void ConstructionUtil::construct(TARGET_TYPE                    *address,
                                 void                           *,
                                 bslmf::MovableRef<TARGET_TYPE>  original)
{

    enum {
        k_VALUE = bslmf::IsBitwiseCopyable<TARGET_TYPE>::value
                ? Imp::e_BITWISE_COPYABLE_TRAITS
                : Imp::e_NIL_TRAITS
    };

    Imp::construct(address,
                   (bsl::integral_constant<int, k_VALUE>*)0,
                   BSLS_COMPILERFEATURES_FORWARD(TARGET_TYPE, original));
}

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_constructionutil.h
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT 15
#endif
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#endif
#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 0
template <class TARGET_TYPE, class ARG1>
inline
void
ConstructionUtil::construct(TARGET_TYPE      *address,
                            bslma::Allocator *allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                 ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                 : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   allocator,
                   (bsl::integral_constant<int, k_VALUE>*)0,
                   BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 1
template <class TARGET_TYPE, class ARG1, class ARGS_01>
inline
void
ConstructionUtil::construct(TARGET_TYPE      *address,
                            bslma::Allocator *allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                 ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                 : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   allocator,
                   (bsl::integral_constant<int, k_VALUE>*)0,
                   BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 2
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02>
inline
void
ConstructionUtil::construct(TARGET_TYPE      *address,
                            bslma::Allocator *allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                 ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                 : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   allocator,
                   (bsl::integral_constant<int, k_VALUE>*)0,
                   BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 3
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03>
inline
void
ConstructionUtil::construct(TARGET_TYPE      *address,
                            bslma::Allocator *allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                 ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                 : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   allocator,
                   (bsl::integral_constant<int, k_VALUE>*)0,
                   BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 4
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04>
inline
void
ConstructionUtil::construct(TARGET_TYPE      *address,
                            bslma::Allocator *allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                 ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                 : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   allocator,
                   (bsl::integral_constant<int, k_VALUE>*)0,
                   BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 5
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04,
                                         class ARGS_05>
inline
void
ConstructionUtil::construct(TARGET_TYPE      *address,
                            bslma::Allocator *allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                 ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                 : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   allocator,
                   (bsl::integral_constant<int, k_VALUE>*)0,
                   BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 6
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04,
                                         class ARGS_05,
                                         class ARGS_06>
inline
void
ConstructionUtil::construct(TARGET_TYPE      *address,
                            bslma::Allocator *allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                 ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                 : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   allocator,
                   (bsl::integral_constant<int, k_VALUE>*)0,
                   BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 7
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04,
                                         class ARGS_05,
                                         class ARGS_06,
                                         class ARGS_07>
inline
void
ConstructionUtil::construct(TARGET_TYPE      *address,
                            bslma::Allocator *allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                 ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                 : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   allocator,
                   (bsl::integral_constant<int, k_VALUE>*)0,
                   BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 8
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04,
                                         class ARGS_05,
                                         class ARGS_06,
                                         class ARGS_07,
                                         class ARGS_08>
inline
void
ConstructionUtil::construct(TARGET_TYPE      *address,
                            bslma::Allocator *allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                 ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                 : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   allocator,
                   (bsl::integral_constant<int, k_VALUE>*)0,
                   BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 9
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04,
                                         class ARGS_05,
                                         class ARGS_06,
                                         class ARGS_07,
                                         class ARGS_08,
                                         class ARGS_09>
inline
void
ConstructionUtil::construct(TARGET_TYPE      *address,
                            bslma::Allocator *allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                 ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                 : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   allocator,
                   (bsl::integral_constant<int, k_VALUE>*)0,
                   BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 10
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04,
                                         class ARGS_05,
                                         class ARGS_06,
                                         class ARGS_07,
                                         class ARGS_08,
                                         class ARGS_09,
                                         class ARGS_10>
inline
void
ConstructionUtil::construct(TARGET_TYPE      *address,
                            bslma::Allocator *allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                 ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                 : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   allocator,
                   (bsl::integral_constant<int, k_VALUE>*)0,
                   BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 11
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04,
                                         class ARGS_05,
                                         class ARGS_06,
                                         class ARGS_07,
                                         class ARGS_08,
                                         class ARGS_09,
                                         class ARGS_10,
                                         class ARGS_11>
inline
void
ConstructionUtil::construct(TARGET_TYPE      *address,
                            bslma::Allocator *allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                 ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                 : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   allocator,
                   (bsl::integral_constant<int, k_VALUE>*)0,
                   BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 12
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04,
                                         class ARGS_05,
                                         class ARGS_06,
                                         class ARGS_07,
                                         class ARGS_08,
                                         class ARGS_09,
                                         class ARGS_10,
                                         class ARGS_11,
                                         class ARGS_12>
inline
void
ConstructionUtil::construct(TARGET_TYPE      *address,
                            bslma::Allocator *allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                 ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                 : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   allocator,
                   (bsl::integral_constant<int, k_VALUE>*)0,
                   BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_12,arguments_12));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 13
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04,
                                         class ARGS_05,
                                         class ARGS_06,
                                         class ARGS_07,
                                         class ARGS_08,
                                         class ARGS_09,
                                         class ARGS_10,
                                         class ARGS_11,
                                         class ARGS_12,
                                         class ARGS_13>
inline
void
ConstructionUtil::construct(TARGET_TYPE      *address,
                            bslma::Allocator *allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                 ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                 : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   allocator,
                   (bsl::integral_constant<int, k_VALUE>*)0,
                   BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_12,arguments_12),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_13,arguments_13));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 13

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 14
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04,
                                         class ARGS_05,
                                         class ARGS_06,
                                         class ARGS_07,
                                         class ARGS_08,
                                         class ARGS_09,
                                         class ARGS_10,
                                         class ARGS_11,
                                         class ARGS_12,
                                         class ARGS_13,
                                         class ARGS_14>
inline
void
ConstructionUtil::construct(TARGET_TYPE      *address,
                            bslma::Allocator *allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                 ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                 : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   allocator,
                   (bsl::integral_constant<int, k_VALUE>*)0,
                   BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_12,arguments_12),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_13,arguments_13),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_14,arguments_14));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 14

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 15
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04,
                                         class ARGS_05,
                                         class ARGS_06,
                                         class ARGS_07,
                                         class ARGS_08,
                                         class ARGS_09,
                                         class ARGS_10,
                                         class ARGS_11,
                                         class ARGS_12,
                                         class ARGS_13,
                                         class ARGS_14,
                                         class ARGS_15>
inline
void
ConstructionUtil::construct(TARGET_TYPE      *address,
                            bslma::Allocator *allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_15) arguments_15)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                 ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                 : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   allocator,
                   (bsl::integral_constant<int, k_VALUE>*)0,
                   BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_12,arguments_12),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_13,arguments_13),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_14,arguments_14),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_15,arguments_15));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 15


#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 0
template <class TARGET_TYPE, class ARG1>
inline
void
ConstructionUtil::construct(TARGET_TYPE *address,
                            void        *,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1)
{
    ::new (Imp::voidify(address)) TARGET_TYPE(
                             BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 1
template <class TARGET_TYPE, class ARG1, class ARGS_01>
inline
void
ConstructionUtil::construct(TARGET_TYPE *address,
                            void        *,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01)
{
    ::new (Imp::voidify(address)) TARGET_TYPE(
                             BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 2
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02>
inline
void
ConstructionUtil::construct(TARGET_TYPE *address,
                            void        *,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02)
{
    ::new (Imp::voidify(address)) TARGET_TYPE(
                             BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 3
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03>
inline
void
ConstructionUtil::construct(TARGET_TYPE *address,
                            void        *,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03)
{
    ::new (Imp::voidify(address)) TARGET_TYPE(
                             BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 4
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04>
inline
void
ConstructionUtil::construct(TARGET_TYPE *address,
                            void        *,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04)
{
    ::new (Imp::voidify(address)) TARGET_TYPE(
                             BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 5
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04,
                                         class ARGS_05>
inline
void
ConstructionUtil::construct(TARGET_TYPE *address,
                            void        *,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05)
{
    ::new (Imp::voidify(address)) TARGET_TYPE(
                             BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 6
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04,
                                         class ARGS_05,
                                         class ARGS_06>
inline
void
ConstructionUtil::construct(TARGET_TYPE *address,
                            void        *,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06)
{
    ::new (Imp::voidify(address)) TARGET_TYPE(
                             BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 7
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04,
                                         class ARGS_05,
                                         class ARGS_06,
                                         class ARGS_07>
inline
void
ConstructionUtil::construct(TARGET_TYPE *address,
                            void        *,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07)
{
    ::new (Imp::voidify(address)) TARGET_TYPE(
                             BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 8
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04,
                                         class ARGS_05,
                                         class ARGS_06,
                                         class ARGS_07,
                                         class ARGS_08>
inline
void
ConstructionUtil::construct(TARGET_TYPE *address,
                            void        *,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08)
{
    ::new (Imp::voidify(address)) TARGET_TYPE(
                             BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 9
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04,
                                         class ARGS_05,
                                         class ARGS_06,
                                         class ARGS_07,
                                         class ARGS_08,
                                         class ARGS_09>
inline
void
ConstructionUtil::construct(TARGET_TYPE *address,
                            void        *,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09)
{
    ::new (Imp::voidify(address)) TARGET_TYPE(
                             BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 10
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04,
                                         class ARGS_05,
                                         class ARGS_06,
                                         class ARGS_07,
                                         class ARGS_08,
                                         class ARGS_09,
                                         class ARGS_10>
inline
void
ConstructionUtil::construct(TARGET_TYPE *address,
                            void        *,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10)
{
    ::new (Imp::voidify(address)) TARGET_TYPE(
                             BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 11
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04,
                                         class ARGS_05,
                                         class ARGS_06,
                                         class ARGS_07,
                                         class ARGS_08,
                                         class ARGS_09,
                                         class ARGS_10,
                                         class ARGS_11>
inline
void
ConstructionUtil::construct(TARGET_TYPE *address,
                            void        *,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11)
{
    ::new (Imp::voidify(address)) TARGET_TYPE(
                             BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 12
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04,
                                         class ARGS_05,
                                         class ARGS_06,
                                         class ARGS_07,
                                         class ARGS_08,
                                         class ARGS_09,
                                         class ARGS_10,
                                         class ARGS_11,
                                         class ARGS_12>
inline
void
ConstructionUtil::construct(TARGET_TYPE *address,
                            void        *,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12)
{
    ::new (Imp::voidify(address)) TARGET_TYPE(
                             BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_12,arguments_12));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 13
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04,
                                         class ARGS_05,
                                         class ARGS_06,
                                         class ARGS_07,
                                         class ARGS_08,
                                         class ARGS_09,
                                         class ARGS_10,
                                         class ARGS_11,
                                         class ARGS_12,
                                         class ARGS_13>
inline
void
ConstructionUtil::construct(TARGET_TYPE *address,
                            void        *,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13)
{
    ::new (Imp::voidify(address)) TARGET_TYPE(
                             BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_12,arguments_12),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_13,arguments_13));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 13

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 14
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04,
                                         class ARGS_05,
                                         class ARGS_06,
                                         class ARGS_07,
                                         class ARGS_08,
                                         class ARGS_09,
                                         class ARGS_10,
                                         class ARGS_11,
                                         class ARGS_12,
                                         class ARGS_13,
                                         class ARGS_14>
inline
void
ConstructionUtil::construct(TARGET_TYPE *address,
                            void        *,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14)
{
    ::new (Imp::voidify(address)) TARGET_TYPE(
                             BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_12,arguments_12),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_13,arguments_13),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_14,arguments_14));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 14

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 15
template <class TARGET_TYPE, class ARG1, class ARGS_01,
                                         class ARGS_02,
                                         class ARGS_03,
                                         class ARGS_04,
                                         class ARGS_05,
                                         class ARGS_06,
                                         class ARGS_07,
                                         class ARGS_08,
                                         class ARGS_09,
                                         class ARGS_10,
                                         class ARGS_11,
                                         class ARGS_12,
                                         class ARGS_13,
                                         class ARGS_14,
                                         class ARGS_15>
inline
void
ConstructionUtil::construct(TARGET_TYPE *address,
                            void        *,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_15) arguments_15)
{
    ::new (Imp::voidify(address)) TARGET_TYPE(
                             BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_12,arguments_12),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_13,arguments_13),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_14,arguments_14),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_15,arguments_15));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_C >= 15

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class TARGET_TYPE, class ARG1, class... ARGS>
inline
void
ConstructionUtil::construct(TARGET_TYPE      *address,
                            bslma::Allocator *allocator,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                 ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                 : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : Imp::e_NIL_TRAITS
    };
    Imp::construct(address,
                   allocator,
                   (bsl::integral_constant<int, k_VALUE>*)0,
                   BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS,arguments)...);
}

template <class TARGET_TYPE, class ARG1, class... ARGS>
inline
void
ConstructionUtil::construct(TARGET_TYPE *address,
                            void        *,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) argument1,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments)
{
    ::new (Imp::voidify(address)) TARGET_TYPE(
                             BSLS_COMPILERFEATURES_FORWARD(ARG1,argument1),
                             BSLS_COMPILERFEATURES_FORWARD(ARGS,arguments)...);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
// }}} END GENERATED CODE
#endif

template <class TARGET_TYPE, class ALLOCATOR>
inline
void
ConstructionUtil::destructiveMove(TARGET_TYPE *address,
                                  ALLOCATOR   *allocator,
                                  TARGET_TYPE *original)
{
    BSLS_ASSERT_SAFE(address);
    BSLS_ASSERT_SAFE(original);

    enum {
        k_VALUE = bslmf::IsBitwiseMoveable<TARGET_TYPE>::value
                ? Imp::e_BITWISE_MOVABLE_TRAITS
                : Imp::e_NIL_TRAITS
    };

    Imp::destructiveMove(address,
                         allocator,
                         (bsl::integral_constant<int, k_VALUE>*)0,
                         original);
}

#if defined(BSLS_COMPILERFEATURES_GUARANTEED_COPY_ELISION)
// Suppress bde_verify warnings about return-by-value in this region.
// BDE_VERIFY pragma: push
// BDE_VERIFY pragma: -AR01: Type using allocator is returned by value

template <class TARGET_TYPE>
inline
TARGET_TYPE
ConstructionUtil::make(bslma::Allocator *allocator)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                   ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                   : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : Imp::e_NIL_TRAITS
    };

    return Imp::make<TARGET_TYPE>(allocator,
                                  (bsl::integral_constant<int, k_VALUE> *) 0);
}

template <class TARGET_TYPE>
inline
TARGET_TYPE
ConstructionUtil::make(void *)
{
    return TARGET_TYPE();
}

template <class TARGET_TYPE, class ANY_TYPE>
inline
TARGET_TYPE
ConstructionUtil::make(bslma::Allocator                            *allocator,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ANY_TYPE)  argument)
{
    enum {
        k_VALUE = bslma::UsesBslmaAllocator<TARGET_TYPE>::value
                ? (bslmf::UsesAllocatorArgT<TARGET_TYPE>::value
                   ? Imp::e_USES_ALLOCATOR_ARG_T_TRAITS
                   : Imp::e_USES_BSLMA_ALLOCATOR_TRAITS)
                : Imp::e_NIL_TRAITS
    };

    return Imp::make<TARGET_TYPE>(allocator,
                                  (bsl::integral_constant<int, k_VALUE> *) 0,
                                  BSLS_COMPILERFEATURES_FORWARD(ANY_TYPE,
                                                                argument));
}

template <class TARGET_TYPE, class ANY_TYPE>
inline
TARGET_TYPE
ConstructionUtil::make(void                                        *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ANY_TYPE)  argument)
{
    return TARGET_TYPE(BSLS_COMPILERFEATURES_FORWARD(ANY_TYPE, argument));
}

// BDE_VERIFY pragma: pop
#endif // defined(BSLS_COMPILERFEATURES_GUARANTEED_COPY_ELISION)

                       // ---------------------------
                       // struct ConstructionUtil_Imp
                       // ---------------------------

// CLASS METHODS
template <class TARGET_TYPE>
inline
void
ConstructionUtil_Imp::construct(
              TARGET_TYPE *address,
              bslma::Allocator *,
              bsl::integral_constant<int, e_HAS_TRIVIAL_DEFAULT_CTOR_TRAITS> *)
{
    construct(address,
              (bsl::integral_constant<int,
                                      e_HAS_TRIVIAL_DEFAULT_CTOR_TRAITS> *) 0);
}

template <class TARGET_TYPE>
inline
void
ConstructionUtil_Imp::construct(
              TARGET_TYPE *address,
              bsl::integral_constant<int, e_HAS_TRIVIAL_DEFAULT_CTOR_TRAITS> *)
{
#if defined(BSLS_PLATFORM_CMP_MSVC) && BSLS_PLATFORM_CMP_VERSION < 1900
    defaultConstructScalar(bsl::is_member_pointer<TARGET_TYPE>(), address);
#else
    ::new (voidify(address)) TARGET_TYPE();
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
#endif
}

template <class TARGET_TYPE>
inline
void ConstructionUtil_Imp::construct(
              TARGET_TYPE                                            *address,
              bslma::Allocator                                       *,
              bsl::integral_constant<int, e_BITWISE_COPYABLE_TRAITS> *,
              const TARGET_TYPE&                                      original)
{
    construct(address,
              (bsl::integral_constant<int, e_BITWISE_COPYABLE_TRAITS>*)0,
               original);
}

template <class TARGET_TYPE>
inline
void ConstructionUtil_Imp::construct(
              TARGET_TYPE                                            *address,
              bsl::integral_constant<int, e_BITWISE_COPYABLE_TRAITS> *,
              const TARGET_TYPE&                                      original)
{
    ::new (voidify(address)) TARGET_TYPE(original);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}

template <class TARGET_TYPE>
inline
void ConstructionUtil_Imp::construct(
              TARGET_TYPE                                            *address,
              bslma::Allocator                                       *,
              bsl::integral_constant<int, e_BITWISE_COPYABLE_TRAITS> *,
              bslmf::MovableRef<TARGET_TYPE>                          original)
{
    construct(address,
              (bsl::integral_constant<int, e_BITWISE_COPYABLE_TRAITS>*)0,
              BSLS_COMPILERFEATURES_FORWARD(TARGET_TYPE, original));
}

template <class TARGET_TYPE>
inline
void ConstructionUtil_Imp::construct(
              TARGET_TYPE                                            *address,
              bsl::integral_constant<int, e_BITWISE_COPYABLE_TRAITS> *,
              bslmf::MovableRef<TARGET_TYPE>                          original)
{
    ::new (voidify(address)) TARGET_TYPE(BSLS_COMPILERFEATURES_FORWARD(
        TARGET_TYPE, bslmf::MovableRefUtil::move(original)));
}

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslma_constructionutil.h
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT 15
#endif
#ifndef BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D
#define BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT
#endif
#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 0
template <class TARGET_TYPE>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *)
{
    ::new (voidify(address)) TARGET_TYPE(
                  allocator);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 1
template <class TARGET_TYPE, class ARGS_01>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01)
{
    ::new (voidify(address)) TARGET_TYPE(
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                  allocator);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 2
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02)
{
    ::new (voidify(address)) TARGET_TYPE(
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                  allocator);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 3
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03)
{
    ::new (voidify(address)) TARGET_TYPE(
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                  allocator);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 4
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04)
{
    ::new (voidify(address)) TARGET_TYPE(
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                  allocator);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 5
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05)
{
    ::new (voidify(address)) TARGET_TYPE(
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                  allocator);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 6
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06)
{
    ::new (voidify(address)) TARGET_TYPE(
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                  allocator);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 7
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07)
{
    ::new (voidify(address)) TARGET_TYPE(
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                  allocator);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 8
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08)
{
    ::new (voidify(address)) TARGET_TYPE(
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                  allocator);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 9
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09)
{
    ::new (voidify(address)) TARGET_TYPE(
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                  allocator);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 10
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10)
{
    ::new (voidify(address)) TARGET_TYPE(
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                  allocator);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 11
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10,
                             class ARGS_11>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11)
{
    ::new (voidify(address)) TARGET_TYPE(
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11),
                  allocator);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 12
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10,
                             class ARGS_11,
                             class ARGS_12>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12)
{
    ::new (voidify(address)) TARGET_TYPE(
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_12,arguments_12),
                  allocator);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 13
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10,
                             class ARGS_11,
                             class ARGS_12,
                             class ARGS_13>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13)
{
    ::new (voidify(address)) TARGET_TYPE(
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_12,arguments_12),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_13,arguments_13),
                  allocator);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 13

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 14
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10,
                             class ARGS_11,
                             class ARGS_12,
                             class ARGS_13,
                             class ARGS_14>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14)
{
    ::new (voidify(address)) TARGET_TYPE(
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_12,arguments_12),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_13,arguments_13),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_14,arguments_14),
                  allocator);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 14

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 15
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10,
                             class ARGS_11,
                             class ARGS_12,
                             class ARGS_13,
                             class ARGS_14,
                             class ARGS_15>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_15) arguments_15)
{
    ::new (voidify(address)) TARGET_TYPE(
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_12,arguments_12),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_13,arguments_13),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_14,arguments_14),
                  BSLS_COMPILERFEATURES_FORWARD(ARGS_15,arguments_15),
                  allocator);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 15


#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 0
template <class TARGET_TYPE>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *)
{
    ::new (voidify(address)) TARGET_TYPE(
                             bsl::allocator_arg,
                             allocator);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 1
template <class TARGET_TYPE, class ARGS_01>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01)
{
    ::new (voidify(address)) TARGET_TYPE(
                             bsl::allocator_arg,
                             allocator,
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 2
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02)
{
    ::new (voidify(address)) TARGET_TYPE(
                             bsl::allocator_arg,
                             allocator,
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 3
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03)
{
    ::new (voidify(address)) TARGET_TYPE(
                             bsl::allocator_arg,
                             allocator,
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 4
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04)
{
    ::new (voidify(address)) TARGET_TYPE(
                             bsl::allocator_arg,
                             allocator,
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 5
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05)
{
    ::new (voidify(address)) TARGET_TYPE(
                             bsl::allocator_arg,
                             allocator,
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 6
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06)
{
    ::new (voidify(address)) TARGET_TYPE(
                             bsl::allocator_arg,
                             allocator,
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 7
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07)
{
    ::new (voidify(address)) TARGET_TYPE(
                             bsl::allocator_arg,
                             allocator,
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 8
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08)
{
    ::new (voidify(address)) TARGET_TYPE(
                             bsl::allocator_arg,
                             allocator,
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 9
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09)
{
    ::new (voidify(address)) TARGET_TYPE(
                             bsl::allocator_arg,
                             allocator,
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 10
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10)
{
    ::new (voidify(address)) TARGET_TYPE(
                             bsl::allocator_arg,
                             allocator,
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 11
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10,
                             class ARGS_11>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11)
{
    ::new (voidify(address)) TARGET_TYPE(
                             bsl::allocator_arg,
                             allocator,
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 12
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10,
                             class ARGS_11,
                             class ARGS_12>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12)
{
    ::new (voidify(address)) TARGET_TYPE(
                             bsl::allocator_arg,
                             allocator,
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_12,arguments_12));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 13
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10,
                             class ARGS_11,
                             class ARGS_12,
                             class ARGS_13>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13)
{
    ::new (voidify(address)) TARGET_TYPE(
                             bsl::allocator_arg,
                             allocator,
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_12,arguments_12),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_13,arguments_13));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 13

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 14
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10,
                             class ARGS_11,
                             class ARGS_12,
                             class ARGS_13,
                             class ARGS_14>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14)
{
    ::new (voidify(address)) TARGET_TYPE(
                             bsl::allocator_arg,
                             allocator,
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_12,arguments_12),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_13,arguments_13),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_14,arguments_14));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 14

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 15
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10,
                             class ARGS_11,
                             class ARGS_12,
                             class ARGS_13,
                             class ARGS_14,
                             class ARGS_15>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_15) arguments_15)
{
    ::new (voidify(address)) TARGET_TYPE(
                             bsl::allocator_arg,
                             allocator,
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_12,arguments_12),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_13,arguments_13),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_14,arguments_14),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_15,arguments_15));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 15


#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 0
template <class TARGET_TYPE>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bslma::Allocator                          *,
                          bsl::integral_constant<int, e_NIL_TRAITS> *)
{
    construct(address,
              (bsl::integral_constant<int, e_NIL_TRAITS> *)0);
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 1
template <class TARGET_TYPE, class ARGS_01>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bslma::Allocator                          *,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01)
{
    construct(address,
              (bsl::integral_constant<int, e_NIL_TRAITS> *)0,
              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 2
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bslma::Allocator                          *,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02)
{
    construct(address,
              (bsl::integral_constant<int, e_NIL_TRAITS> *)0,
              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 3
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bslma::Allocator                          *,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03)
{
    construct(address,
              (bsl::integral_constant<int, e_NIL_TRAITS> *)0,
              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 4
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bslma::Allocator                          *,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04)
{
    construct(address,
              (bsl::integral_constant<int, e_NIL_TRAITS> *)0,
              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 5
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bslma::Allocator                          *,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05)
{
    construct(address,
              (bsl::integral_constant<int, e_NIL_TRAITS> *)0,
              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 6
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bslma::Allocator                          *,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06)
{
    construct(address,
              (bsl::integral_constant<int, e_NIL_TRAITS> *)0,
              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 7
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bslma::Allocator                          *,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07)
{
    construct(address,
              (bsl::integral_constant<int, e_NIL_TRAITS> *)0,
              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 8
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bslma::Allocator                          *,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08)
{
    construct(address,
              (bsl::integral_constant<int, e_NIL_TRAITS> *)0,
              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 9
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bslma::Allocator                          *,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09)
{
    construct(address,
              (bsl::integral_constant<int, e_NIL_TRAITS> *)0,
              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 10
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bslma::Allocator                          *,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10)
{
    construct(address,
              (bsl::integral_constant<int, e_NIL_TRAITS> *)0,
              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 11
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10,
                             class ARGS_11>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bslma::Allocator                          *,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11)
{
    construct(address,
              (bsl::integral_constant<int, e_NIL_TRAITS> *)0,
              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 12
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10,
                             class ARGS_11,
                             class ARGS_12>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bslma::Allocator                          *,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12)
{
    construct(address,
              (bsl::integral_constant<int, e_NIL_TRAITS> *)0,
              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 13
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10,
                             class ARGS_11,
                             class ARGS_12,
                             class ARGS_13>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bslma::Allocator                          *,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13)
{
    construct(address,
              (bsl::integral_constant<int, e_NIL_TRAITS> *)0,
              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_13, arguments_13));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 13

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 14
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10,
                             class ARGS_11,
                             class ARGS_12,
                             class ARGS_13,
                             class ARGS_14>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bslma::Allocator                          *,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14)
{
    construct(address,
              (bsl::integral_constant<int, e_NIL_TRAITS> *)0,
              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_13, arguments_13),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_14, arguments_14));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 14

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 15
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10,
                             class ARGS_11,
                             class ARGS_12,
                             class ARGS_13,
                             class ARGS_14,
                             class ARGS_15>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bslma::Allocator                          *,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_15) arguments_15)
{
    construct(address,
              (bsl::integral_constant<int, e_NIL_TRAITS> *)0,
              BSLS_COMPILERFEATURES_FORWARD(ARGS_01, arguments_01),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_02, arguments_02),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_03, arguments_03),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_04, arguments_04),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_05, arguments_05),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_06, arguments_06),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_07, arguments_07),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_08, arguments_08),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_09, arguments_09),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_10, arguments_10),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_11, arguments_11),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_12, arguments_12),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_13, arguments_13),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_14, arguments_14),
              BSLS_COMPILERFEATURES_FORWARD(ARGS_15, arguments_15));
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 15


#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 0
template <class TARGET_TYPE>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *)
{
    ::new (voidify(address)) TARGET_TYPE(
                             );
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 0

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 1
template <class TARGET_TYPE, class ARGS_01>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01)
{
    ::new (voidify(address)) TARGET_TYPE(
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 1

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 2
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02)
{
    ::new (voidify(address)) TARGET_TYPE(
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 2

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 3
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03)
{
    ::new (voidify(address)) TARGET_TYPE(
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 3

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 4
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04)
{
    ::new (voidify(address)) TARGET_TYPE(
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 4

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 5
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05)
{
    ::new (voidify(address)) TARGET_TYPE(
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 5

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 6
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06)
{
    ::new (voidify(address)) TARGET_TYPE(
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 6

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 7
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07)
{
    ::new (voidify(address)) TARGET_TYPE(
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 7

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 8
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08)
{
    ::new (voidify(address)) TARGET_TYPE(
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 8

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 9
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09)
{
    ::new (voidify(address)) TARGET_TYPE(
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 9

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 10
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10)
{
    ::new (voidify(address)) TARGET_TYPE(
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 10

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 11
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10,
                             class ARGS_11>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11)
{
    ::new (voidify(address)) TARGET_TYPE(
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 11

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 12
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10,
                             class ARGS_11,
                             class ARGS_12>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12)
{
    ::new (voidify(address)) TARGET_TYPE(
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_12,arguments_12));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 12

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 13
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10,
                             class ARGS_11,
                             class ARGS_12,
                             class ARGS_13>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13)
{
    ::new (voidify(address)) TARGET_TYPE(
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_12,arguments_12),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_13,arguments_13));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 13

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 14
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10,
                             class ARGS_11,
                             class ARGS_12,
                             class ARGS_13,
                             class ARGS_14>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14)
{
    ::new (voidify(address)) TARGET_TYPE(
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_12,arguments_12),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_13,arguments_13),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_14,arguments_14));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 14

#if BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 15
template <class TARGET_TYPE, class ARGS_01,
                             class ARGS_02,
                             class ARGS_03,
                             class ARGS_04,
                             class ARGS_05,
                             class ARGS_06,
                             class ARGS_07,
                             class ARGS_08,
                             class ARGS_09,
                             class ARGS_10,
                             class ARGS_11,
                             class ARGS_12,
                             class ARGS_13,
                             class ARGS_14,
                             class ARGS_15>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) arguments_01,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) arguments_02,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) arguments_03,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) arguments_04,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) arguments_05,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) arguments_06,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) arguments_07,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) arguments_08,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) arguments_09,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) arguments_10,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_11) arguments_11,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_12) arguments_12,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_13) arguments_13,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_14) arguments_14,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_15) arguments_15)
{
    ::new (voidify(address)) TARGET_TYPE(
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_01,arguments_01),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_02,arguments_02),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_03,arguments_03),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_04,arguments_04),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_05,arguments_05),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_06,arguments_06),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_07,arguments_07),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_08,arguments_08),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_09,arguments_09),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_10,arguments_10),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_11,arguments_11),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_12,arguments_12),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_13,arguments_13),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_14,arguments_14),
                          BSLS_COMPILERFEATURES_FORWARD(ARGS_15,arguments_15));
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
#endif  // BSLMA_CONSTRUCTIONUTIL_VARIADIC_LIMIT_D >= 15

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class TARGET_TYPE, class... ARGS>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments)
{
    ::new (voidify(address)) TARGET_TYPE(
                  BSLS_COMPILERFEATURES_FORWARD(ARGS,arguments)..., allocator);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}

template <class TARGET_TYPE, class... ARGS>
inline
void
ConstructionUtil_Imp::construct(
         TARGET_TYPE                                                *address,
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments)
{
    ::new (voidify(address)) TARGET_TYPE(
                             bsl::allocator_arg,
                             allocator,
                             BSLS_COMPILERFEATURES_FORWARD(ARGS,arguments)...);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}

template <class TARGET_TYPE, class... ARGS>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bslma::Allocator                          *,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments)
{
    construct(address,
              (bsl::integral_constant<int, e_NIL_TRAITS> *)0,
              BSLS_COMPILERFEATURES_FORWARD(ARGS, arguments)...);
}

template <class TARGET_TYPE, class... ARGS>
inline
void
ConstructionUtil_Imp::construct(
                          TARGET_TYPE                               *address,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... arguments)
{
    ::new (voidify(address)) TARGET_TYPE(
                             BSLS_COMPILERFEATURES_FORWARD(ARGS,arguments)...);
    BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
}
// }}} END GENERATED CODE
#endif

#if defined(BSLS_PLATFORM_CMP_MSVC) && BSLS_PLATFORM_CMP_VERSION < 1900
template <class TARGET_TYPE>
inline
void
ConstructionUtil_Imp::defaultConstructScalar(bsl::false_type,
                                             TARGET_TYPE *address)
{
    ::new (voidify(address)) TARGET_TYPE();
}

template <class TARGET_TYPE>
inline
void
ConstructionUtil_Imp::defaultConstructScalar(bsl::true_type,
                                             TARGET_TYPE *address)
{
    ::new (voidify(address)) TARGET_TYPE(nullptr);
}
#endif

template <class TARGET_TYPE, class ALLOCATOR>
inline
void
ConstructionUtil_Imp::destructiveMove(
               TARGET_TYPE                                           *address,
               ALLOCATOR                                             *,
               bsl::integral_constant<int, e_BITWISE_MOVABLE_TRAITS> *,
               TARGET_TYPE                                           *original)
{
    if (bsl::is_fundamental<TARGET_TYPE>::value ||
        bsl::is_pointer<TARGET_TYPE>::value) {
        ::new (voidify(address)) TARGET_TYPE(*original);
        BSLMA_CONSTRUCTIONUTIL_XLC_PLACEMENT_NEW_FIX;
    }
    else {
        // voidify(address) is used here to suppress compiler warning
        // "-Wclass-memaccess".
        memcpy(voidify(address), original, sizeof *original);
    }
}

template <class TARGET_TYPE, class ALLOCATOR>
inline
void
ConstructionUtil_Imp::destructiveMove(
                          TARGET_TYPE                               *address,
                          ALLOCATOR                                 *allocator,
                          bsl::integral_constant<int, e_NIL_TRAITS> *,
                          TARGET_TYPE                               *original)
{
    // TBD: should be ok with C++03 as well, but need to test edge cases first
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES)
    ConstructionUtil::construct(address,
                                allocator,
                                bslmf::MovableRefUtil::move(*original));
#else
    ConstructionUtil::construct(address, allocator, *original);
#endif
    DestructionUtil::destroy(original);
}

#if defined(BSLS_COMPILERFEATURES_GUARANTEED_COPY_ELISION)
// Suppress bde_verify warnings about return-by-value in this region.
// BDE_VERIFY pragma: push
// BDE_VERIFY pragma: -AR01: Type using allocator is returned by value

template <class TARGET_TYPE>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *)
{
    return TARGET_TYPE(allocator);
}

template <class TARGET_TYPE>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *)
{
    return TARGET_TYPE(bsl::allocator_arg, allocator);
}

template <class TARGET_TYPE>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(bslma::Allocator                          *,
                           bsl::integral_constant<int, e_NIL_TRAITS> *)
{
    return TARGET_TYPE();
}

template <class TARGET_TYPE, class ANY_TYPE>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_BSLMA_ALLOCATOR_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ANY_TYPE)                 argument)
{
    return TARGET_TYPE(BSLS_COMPILERFEATURES_FORWARD(ANY_TYPE, argument),
                       allocator);
}

template <class TARGET_TYPE, class ANY_TYPE>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
         bslma::Allocator                                           *allocator,
         bsl::integral_constant<int, e_USES_ALLOCATOR_ARG_T_TRAITS> *,
         BSLS_COMPILERFEATURES_FORWARD_REF(ANY_TYPE)                 argument)
{
    return TARGET_TYPE(bsl::allocator_arg, allocator,
                       BSLS_COMPILERFEATURES_FORWARD(ANY_TYPE, argument));
}

template <class TARGET_TYPE, class ANY_TYPE>
inline
TARGET_TYPE
ConstructionUtil_Imp::make(
                         bslma::Allocator                            *,
                         bsl::integral_constant<int, e_NIL_TRAITS>   *,
                         BSLS_COMPILERFEATURES_FORWARD_REF(ANY_TYPE)  argument)
{
    return TARGET_TYPE(BSLS_COMPILERFEATURES_FORWARD(ANY_TYPE, argument));
}

// BDE_VERIFY pragma: pop
#endif // defined(BSLS_COMPILERFEATURES_GUARANTEED_COPY_ELISION)

template <class TARGET_TYPE>
inline
void *ConstructionUtil_Imp::voidify(TARGET_TYPE *address)
{
    return static_cast<void *>(
            const_cast<typename bsl::remove_cv<TARGET_TYPE>::type *>(address));
}

}  // close package namespace
}  // close enterprise namespace

#else // if ! defined(DEFINED_BSLMA_CONSTRUCTIONUTIL_H)
# error Not valid except when included from bslma_constructionutil.h
#endif // ! defined(COMPILING_BSLMA_CONSTRUCTIONUTIL_H)

#endif // ! defined(INCLUDED_BSLMA_CONSTRUCTIONUTIL_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2023 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
