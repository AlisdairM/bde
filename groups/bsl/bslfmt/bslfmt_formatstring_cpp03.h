// bslfmt_formatstring_cpp03.h                                        -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BSLFMT_FORMATSTRING_CPP03
#define INCLUDED_BSLFMT_FORMATSTRING_CPP03

//@PURPOSE: Provide C++03 implementation for bslfmt_formatstring.h
//
//@CLASSES: See bslfmt_formatstring.h for list of classes
//
//@SEE_ALSO: bslfmt_formatstring
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Tue Jun 18 15:38:48 2024
// Command line: sim_cpp11_features.pl bslfmt_formatstring.h

#ifdef COMPILING_BSLFMT_FORMATSTRING_H

namespace BloombergLP {
namespace bslfmt {

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslfmt_formatstring.h
#ifndef BSLFMT_FORMATSTRING_VARIADIC_LIMIT
#define BSLFMT_FORMATSTRING_VARIADIC_LIMIT 3
#endif
#ifndef BSLFMT_FORMATSTRING_VARIADIC_LIMIT_A
#define BSLFMT_FORMATSTRING_VARIADIC_LIMIT_A BSLFMT_FORMATSTRING_VARIADIC_LIMIT
#endif

template <class t_CHAR>
struct FormatString_Test_Updater;
#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.

template <class t_CHAR>
struct FormatString_Test_Updater;

// }}} END GENERATED CODE
#endif

#ifdef BSLS_LIBRARYFEATURES_HAS_CPP20_BASELINE_LIBRARY

template <class t_CHAR, class... t_ARGS>
struct basic_format_string {
  public:
    // DATA
    bsl::basic_string_view<t_CHAR> d_formatString;

  public:
    // CREATORS
    template <class t_STR,
              class = typename bsl::enable_if<bsl::is_convertible<
                  t_STR,
                  bsl::basic_string_view<t_CHAR> >::value>::type>
    consteval basic_format_string(t_STR&& s)
    {
        d_formatString = std::forward<t_STR>(s);
    }

    // ACCESSORS
    BSLS_KEYWORD_CONSTEXPR bsl::basic_string_view<t_CHAR> get()
    {
        return d_formatString;
    }

  private:
    // FRIENDS
    template <class t_INNER_CHAR, class... t_INNER_ARGS>
    friend struct FormatString_Test_Updater;
};

template <class... t_ARGS>
using format_string =
                 basic_format_string<char, bsl::type_identity_t<t_ARGS>...>;

template <class... t_ARGS>
using wformat_string =
                 basic_format_string<wchar_t, bsl::type_identity_t<t_ARGS>...>;

#elif BSLS_LIBRARYFEATURES_HAS_CPP11_BASELINE_LIBRARY

template <class t_CHAR, class... t_ARGS>
struct basic_format_string {
    bsl::basic_string_view<t_CHAR> d_formatString;

    BSLS_KEYWORD_CONSTEXPR_CPP14 basic_format_string(const t_CHAR *s)
    {
        d_formatString = s;
    }

    BSLS_KEYWORD_CONSTEXPR bsl::basic_string_view<t_CHAR> get()
    {
        return d_formatString;
    }

  private:
    // FRIENDS
    template <class t_INNER_CHAR, class... t_ARGS>
    friend struct FormatString_Test_Updater;
};

template <class... t_ARGS>
using format_string =
                 basic_format_string<char, bsl::type_identity_t<t_ARGS>...>;

template <class... t_ARGS>
using wformat_string =
                 basic_format_string<wchar_t, bsl::type_identity_t<t_ARGS>...>;

#else

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslfmt_formatstring.h
#ifndef BSLFMT_FORMATSTRING_VARIADIC_LIMIT
#define BSLFMT_FORMATSTRING_VARIADIC_LIMIT 3
#endif
#ifndef BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B
#define BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B BSLFMT_FORMATSTRING_VARIADIC_LIMIT
#endif

template <class t_CHAR
#if BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 0
        , class t_ARGS_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 0

#if BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 1
        , class t_ARGS_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 1

#if BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 2
        , class t_ARGS_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 2
        , class = BSLS_COMPILERFEATURES_NILT>
struct basic_format_string;

#if BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 0
template <class t_CHAR>
struct basic_format_string<t_CHAR> {
    bsl::basic_string_view<t_CHAR> d_formatString;

    BSLS_KEYWORD_CONSTEXPR_CPP14 basic_format_string(const t_CHAR *s)
    {
        d_formatString = s;
    }

    BSLS_KEYWORD_CONSTEXPR bsl::basic_string_view<t_CHAR> get()
    {
        return d_formatString;
    }

  private:
    template <class t_INNER_CHAR>
    friend struct FormatString_Test_Updater;
};
#endif  // BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 0

#if BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 1
template <class t_CHAR, class t_ARGS_1>
struct basic_format_string<t_CHAR, t_ARGS_1> {
    bsl::basic_string_view<t_CHAR> d_formatString;

    BSLS_KEYWORD_CONSTEXPR_CPP14 basic_format_string(const t_CHAR *s)
    {
        d_formatString = s;
    }

    BSLS_KEYWORD_CONSTEXPR bsl::basic_string_view<t_CHAR> get()
    {
        return d_formatString;
    }

  private:
    template <class t_INNER_CHAR>
    friend struct FormatString_Test_Updater;
};
#endif  // BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 1

#if BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 2
template <class t_CHAR, class t_ARGS_1,
                        class t_ARGS_2>
struct basic_format_string<t_CHAR, t_ARGS_1,
                                   t_ARGS_2> {
    bsl::basic_string_view<t_CHAR> d_formatString;

    BSLS_KEYWORD_CONSTEXPR_CPP14 basic_format_string(const t_CHAR *s)
    {
        d_formatString = s;
    }

    BSLS_KEYWORD_CONSTEXPR bsl::basic_string_view<t_CHAR> get()
    {
        return d_formatString;
    }

  private:
    template <class t_INNER_CHAR>
    friend struct FormatString_Test_Updater;
};
#endif  // BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 2

#if BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 3
template <class t_CHAR, class t_ARGS_1,
                        class t_ARGS_2,
                        class t_ARGS_3>
struct basic_format_string<t_CHAR, t_ARGS_1,
                                   t_ARGS_2,
                                   t_ARGS_3> {
    bsl::basic_string_view<t_CHAR> d_formatString;

    BSLS_KEYWORD_CONSTEXPR_CPP14 basic_format_string(const t_CHAR *s)
    {
        d_formatString = s;
    }

    BSLS_KEYWORD_CONSTEXPR bsl::basic_string_view<t_CHAR> get()
    {
        return d_formatString;
    }

  private:
    template <class t_INNER_CHAR>
    friend struct FormatString_Test_Updater;
};
#endif  // BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 3




template <
#if BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 0
class t_ARGS_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 0

#if BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 1
        , class t_ARGS_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 1

#if BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 2
        , class t_ARGS_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 2
        , class = BSLS_COMPILERFEATURES_NILT>
struct format_string;

#if BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 0
template <>
struct format_string<> {
    bsl::basic_string_view<char> d_formatString;

    BSLS_KEYWORD_CONSTEXPR_CPP14 format_string(const char *s)
    {
        d_formatString = s;
    }

    BSLS_KEYWORD_CONSTEXPR bsl::basic_string_view<char> get()
    {
        return d_formatString;
    }

  private:
    template <class t_INNER_CHAR>
    friend struct FormatString_Test_Updater;
};
#endif  // BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 0

#if BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 1
template <class t_ARGS_1>
struct format_string<t_ARGS_1> {
    bsl::basic_string_view<char> d_formatString;

    BSLS_KEYWORD_CONSTEXPR_CPP14 format_string(const char *s)
    {
        d_formatString = s;
    }

    BSLS_KEYWORD_CONSTEXPR bsl::basic_string_view<char> get()
    {
        return d_formatString;
    }

  private:
    template <class t_INNER_CHAR>
    friend struct FormatString_Test_Updater;
};
#endif  // BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 1

#if BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 2
template <class t_ARGS_1,
          class t_ARGS_2>
struct format_string<t_ARGS_1,
                     t_ARGS_2> {
    bsl::basic_string_view<char> d_formatString;

    BSLS_KEYWORD_CONSTEXPR_CPP14 format_string(const char *s)
    {
        d_formatString = s;
    }

    BSLS_KEYWORD_CONSTEXPR bsl::basic_string_view<char> get()
    {
        return d_formatString;
    }

  private:
    template <class t_INNER_CHAR>
    friend struct FormatString_Test_Updater;
};
#endif  // BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 2

#if BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 3
template <class t_ARGS_1,
          class t_ARGS_2,
          class t_ARGS_3>
struct format_string<t_ARGS_1,
                     t_ARGS_2,
                     t_ARGS_3> {
    bsl::basic_string_view<char> d_formatString;

    BSLS_KEYWORD_CONSTEXPR_CPP14 format_string(const char *s)
    {
        d_formatString = s;
    }

    BSLS_KEYWORD_CONSTEXPR bsl::basic_string_view<char> get()
    {
        return d_formatString;
    }

  private:
    template <class t_INNER_CHAR>
    friend struct FormatString_Test_Updater;
};
#endif  // BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 3




template <
#if BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 0
class t_ARGS_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 0

#if BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 1
        , class t_ARGS_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 1

#if BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 2
        , class t_ARGS_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 2
        , class = BSLS_COMPILERFEATURES_NILT>
struct wformat_string;

#if BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 0
template <>
struct wformat_string<> : public basic_format_string<wchar_t> {
    BSLS_KEYWORD_CONSTEXPR_CPP14 wformat_string(const wchar_t *s)
    : basic_format_string<wchar_t>(s)
    {
        this->d_formatString = s;
    }
};
#endif  // BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 0

#if BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 1
template <class t_ARGS_1>
struct wformat_string<t_ARGS_1> : public basic_format_string<wchar_t,
                                 typename bsl::type_identity<t_ARGS_1>::type> {
    BSLS_KEYWORD_CONSTEXPR_CPP14 wformat_string(const wchar_t *s)
    : basic_format_string<wchar_t, typename bsl::type_identity<t_ARGS_1>::type
                                   >(s)
    {
        this->d_formatString = s;
    }
};
#endif  // BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 1

#if BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 2
template <class t_ARGS_1,
          class t_ARGS_2>
struct wformat_string<t_ARGS_1,
                      t_ARGS_2> : public basic_format_string<wchar_t,
                                 typename bsl::type_identity<t_ARGS_1>::type,
                                 typename bsl::type_identity<t_ARGS_2>::type> {
    BSLS_KEYWORD_CONSTEXPR_CPP14 wformat_string(const wchar_t *s)
    : basic_format_string<wchar_t, typename bsl::type_identity<t_ARGS_1>::type,
                                   typename bsl::type_identity<t_ARGS_2>::type
                                   >(s)
    {
        this->d_formatString = s;
    }
};
#endif  // BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 2

#if BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 3
template <class t_ARGS_1,
          class t_ARGS_2,
          class t_ARGS_3>
struct wformat_string<t_ARGS_1,
                      t_ARGS_2,
                      t_ARGS_3> : public basic_format_string<wchar_t,
                                 typename bsl::type_identity<t_ARGS_1>::type,
                                 typename bsl::type_identity<t_ARGS_2>::type,
                                 typename bsl::type_identity<t_ARGS_3>::type> {
    BSLS_KEYWORD_CONSTEXPR_CPP14 wformat_string(const wchar_t *s)
    : basic_format_string<wchar_t, typename bsl::type_identity<t_ARGS_1>::type,
                                   typename bsl::type_identity<t_ARGS_2>::type,
                                   typename bsl::type_identity<t_ARGS_3>::type
                                   >(s)
    {
        this->d_formatString = s;
    }
};
#endif  // BSLFMT_FORMATSTRING_VARIADIC_LIMIT_B >= 3

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.

template <class t_CHAR, class... t_ARGS>
struct basic_format_string {
    bsl::basic_string_view<t_CHAR> d_formatString;

    BSLS_KEYWORD_CONSTEXPR_CPP14 basic_format_string(const t_CHAR *s)
    {
        d_formatString = s;
    }

    BSLS_KEYWORD_CONSTEXPR bsl::basic_string_view<t_CHAR> get()
    {
        return d_formatString;
    }

  private:
    template <class t_INNER_CHAR>
    friend struct FormatString_Test_Updater;
};



template <class... t_ARGS>
struct format_string {
    bsl::basic_string_view<char> d_formatString;

    BSLS_KEYWORD_CONSTEXPR_CPP14 format_string(const char *s)
    {
        d_formatString = s;
    }

    BSLS_KEYWORD_CONSTEXPR bsl::basic_string_view<char> get()
    {
        return d_formatString;
    }

  private:
    template <class t_INNER_CHAR>
    friend struct FormatString_Test_Updater;
};



template <class... t_ARGS>
struct wformat_string : public basic_format_string<wchar_t, typename bsl::type_identity<t_ARGS>::type...> {
    BSLS_KEYWORD_CONSTEXPR_CPP14 wformat_string(const wchar_t *s)
    : basic_format_string<wchar_t, typename bsl::type_identity<t_ARGS>::type...>(s)
    {
        this->d_formatString = s;
    }
};

// }}} END GENERATED CODE
#endif

#endif // BSLS_LIBRARYFEATURES_HAS_CPP11/20_BASELINE_LIBRARY

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslfmt_formatstring.h
#ifndef BSLFMT_FORMATSTRING_VARIADIC_LIMIT
#define BSLFMT_FORMATSTRING_VARIADIC_LIMIT 3
#endif
#ifndef BSLFMT_FORMATSTRING_VARIADIC_LIMIT_C
#define BSLFMT_FORMATSTRING_VARIADIC_LIMIT_C BSLFMT_FORMATSTRING_VARIADIC_LIMIT
#endif

template <class t_CHAR>
struct FormatString_Test_Updater
{
    template <class t_FORMATSTRING>
    static void
    update(t_FORMATSTRING *out, const t_CHAR *v)
    {
        out->d_formatString = v;
    }

    template <class t_FORMATSTRING>
    static void
    update(t_FORMATSTRING *out, bsl::basic_string_view<t_CHAR> v)
    {
        out->d_formatString = v;
    }
};
#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.

template <class t_CHAR>
struct FormatString_Test_Updater
{
    template <class t_FORMATSTRING>
    static void
    update(t_FORMATSTRING *out, const t_CHAR *v)
    {
        out->d_formatString = v;
    }

    template <class t_FORMATSTRING>
    static void
    update(t_FORMATSTRING *out, bsl::basic_string_view<t_CHAR> v)
    {
        out->d_formatString = v;
    }
};

// }}} END GENERATED CODE
#endif

} // close namespace bslfmt
} // close enterprise namespace

#else // if ! defined(DEFINED_BSLFMT_FORMATSTRING_H)
# error Not valid except when included from bslfmt_formatstring.h
#endif // ! defined(COMPILING_BSLFMT_FORMATSTRING_H)

#endif // ! defined(INCLUDED_BSLFMT_FORMATSTRING_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2023 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
