// bslh_wyhashalgorithm.t.cpp                                         -*-C++-*-
#include <bslh_wyhashalgorithm.h>

#include <bslmf_assert.h>
#include <bslmf_isbitwisemoveable.h>
#include <bslmf_issame.h>

#include <bsls_assert.h>
#include <bsls_asserttest.h>
#include <bsls_bsltestutil.h>
#include <bsls_byteorderutil.h>
#include <bsls_platform.h>
#include <bsls_stopwatch.h>
#include <bsls_systemtime.h>
#include <bsls_timeinterval.h>
#include <bsls_types.h>

#include <algorithm>

#include <limits.h>
#include <stddef.h>  // for 'size_t'
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

#if defined(_MSC_VER) && defined(_M_X64)
# include <intrin.h>
# pragma intrinsic(_umul128)
#endif

using namespace BloombergLP;

//=============================================================================
//                                  TEST PLAN
//-----------------------------------------------------------------------------
//                                  Overview
//                                  --------
// The component under test is a 'bslh' hashing algorithm.  The basic test plan
// is to compare the output of the function call operator with the expected
// output generated by a known-good implementation of the hashing algorithm.
// The component will also be tested for conformance to the requirements on
// 'bslh' hashing algorithms, outlined in the 'bslh' package level
// documentation.
//-----------------------------------------------------------------------------
// TYPEDEF
// [ 4] typedef bsls::Types::Uint64 result_type;
//
// CONSTANTS
// [ 5] enum { k_SEED_LENGTH = 16 };
//
// CREATORS
// [ 2] Obj();
// [ 2] Obj(const char *seed);
// [ 2] ~Obj();
//
// MANIPULATORS
// [ 3] void operator()(void const* key, size_t len);
// [ 3] result_type computeHash();
// ----------------------------------------------------------------------------
// [ 1] BREATHING TEST
// [ 6] Trait IsBitwiseMoveable
// [ 7] MATCH TEST
// [ 8] ALIGNMENT INDEPENDENCE
// [ 9] PLATFORM INDEPENDENCE
// [10] USAGE EXAMPLE
// [-1] DISPERSION TEST
//-----------------------------------------------------------------------------

// ============================================================================
//                     STANDARD BSL ASSERT TEST FUNCTION
// ----------------------------------------------------------------------------

namespace {

int testStatus = 0;

void aSsErT(bool condition, const char *message, int line)
{
    if (condition) {
        printf("Error " __FILE__ "(%d): %s    (failed)\n", line, message);

        if (0 <= testStatus && testStatus <= 100) {
            ++testStatus;
        }
    }
}

}  // close unnamed namespace

// ============================================================================
//               STANDARD BSL TEST DRIVER MACRO ABBREVIATIONS
// ----------------------------------------------------------------------------

#define ASSERT       BSLS_BSLTESTUTIL_ASSERT
#define ASSERTV      BSLS_BSLTESTUTIL_ASSERTV

#define LOOP_ASSERT  BSLS_BSLTESTUTIL_LOOP_ASSERT
#define LOOP0_ASSERT BSLS_BSLTESTUTIL_LOOP0_ASSERT
#define LOOP1_ASSERT BSLS_BSLTESTUTIL_LOOP1_ASSERT
#define LOOP2_ASSERT BSLS_BSLTESTUTIL_LOOP2_ASSERT
#define LOOP3_ASSERT BSLS_BSLTESTUTIL_LOOP3_ASSERT
#define LOOP4_ASSERT BSLS_BSLTESTUTIL_LOOP4_ASSERT
#define LOOP5_ASSERT BSLS_BSLTESTUTIL_LOOP5_ASSERT
#define LOOP6_ASSERT BSLS_BSLTESTUTIL_LOOP6_ASSERT

#define Q            BSLS_BSLTESTUTIL_Q   // Quote identifier literally.
#define P            BSLS_BSLTESTUTIL_P   // Print identifier and value.
#define P_           BSLS_BSLTESTUTIL_P_  // P(X) without '\n'.
#define T_           BSLS_BSLTESTUTIL_T_  // Print a tab (w/o newline).
#define L_           BSLS_BSLTESTUTIL_L_  // current Line number

// ============================================================================
//                  NEGATIVE-TEST MACRO ABBREVIATIONS
// ----------------------------------------------------------------------------

#define ASSERT_SAFE_PASS(EXPR) BSLS_ASSERTTEST_ASSERT_SAFE_PASS(EXPR)
#define ASSERT_SAFE_FAIL(EXPR) BSLS_ASSERTTEST_ASSERT_SAFE_FAIL(EXPR)
#define ASSERT_PASS(EXPR)      BSLS_ASSERTTEST_ASSERT_PASS(EXPR)
#define ASSERT_FAIL(EXPR)      BSLS_ASSERTTEST_ASSERT_FAIL(EXPR)
#define ASSERT_OPT_PASS(EXPR)  BSLS_ASSERTTEST_ASSERT_OPT_PASS(EXPR)
#define ASSERT_OPT_FAIL(EXPR)  BSLS_ASSERTTEST_ASSERT_OPT_FAIL(EXPR)

// ============================================================================
//                  PRINTF FORMAT MACRO ABBREVIATIONS
// ----------------------------------------------------------------------------

#define ZU BSLS_BSLTESTUTIL_FORMAT_ZU

//=============================================================================
//                             USAGE EXAMPLE
//-----------------------------------------------------------------------------

///Usage
///-----
// This section illustrates intended usage of this component.
//
///Example: Creating and Using a Hash Table
/// - - - - - - - - - - - - - - - - - - - -
// Suppose we have any array of types that define 'operator==', and we want a
// fast way to find out if values are contained in the array.  We can create a
// 'HashTable' data structure that is capable of looking up values in O(1)
// time.
//
// Further suppose that we will be storing futures (the financial instruments)
// in this table.  Since futures have standardized names, we don't have to
// worry about any malicious values causing collisions.  We will want to use a
// general purpose hashing algorithm with a good hash distribution and good
// speed.  This algorithm will need to be in the form of a hash functor -- an
// object that will take objects stored in our array as input, and yield a
// 64-bit int value.  The functor can pass the attributes of the 'TYPE' that
// are salient to hashing into the hashing algorithm, and then return the hash
// that is produced.
//
// We can use the result of the hash function to index into our array of
// 'buckets'.  Each 'bucket' is simply a pointer to a value in our original
// array of 'TYPE' objects.
//
// First, we define our 'HashTable' template class, with the two type
// parameters: 'TYPE' (the type being referenced) and 'HASHER' (a functor that
// produces the hash).
//..
    template <class TYPE, class HASHER>
    class HashTable {
//..
// This 'class template' implements a hash table providing fast lookup of an
// external, non-owned, array of values of (template parameter) 'TYPE'.
//
// The (template parameter) 'TYPE' shall have a transitive, symmetric
// 'operator==' function.  There is no requirement that it have any kind of
// creator defined.
//
// The 'HASHER' template parameter type must be a functor with a method having
// the following signature:
//..
//  size_t operator()(TYPE)  const;
//                   -OR-
//  size_t operator()(const TYPE&) const;
//..
// and 'HASHER' shall have a publicly accessible default constructor and
// destructor.
//
// Note that this hash table has numerous simplifications because we know the
// size of the array and never have to resize the table.
//..
        // DATA
        const TYPE       *d_values;          // Array of values table is to
                                             // hold
        size_t            d_numValues;       // Length of 'd_values'.
        const TYPE      **d_bucketArray;     // Contains ptrs into 'd_values'
        size_t            d_bucketArrayMask; // Will always be '2^N - 1'.
        HASHER            d_hasher;          // User supplied hashing algorithm

      private:
        // PRIVATE ACCESSORS
        bool lookup(size_t      *idx,
                    const TYPE&  value,
                    size_t       hashValue) const;
            // Look up the specified 'value', having the specified 'hashValue',
            // and load its index in 'd_bucketArray' into the specified 'idx'.
            // If not found, return the vacant entry in 'd_bucketArray' where
            // it should be inserted.  Return 'true' if 'value' is found and
            // 'false' otherwise.

      public:
        // CREATORS
        HashTable(const TYPE *valuesArray,
                  size_t      numValues);
            // Create a hash table referring to the specified 'valuesArray'
            // having length of the specified 'numValues'.  No value in
            // 'valuesArray' shall have the same value as any of the other
            // values in 'valuesArray'

        ~HashTable();
            // Free up memory used by this hash table.

        // ACCESSORS
        bool contains(const TYPE& value) const;
            // Return true if the specified 'value' is found in the table and
            // false otherwise.
    };

    // PRIVATE ACCESSORS
    template <class TYPE, class HASHER>
    bool HashTable<TYPE, HASHER>::lookup(size_t      *idx,
                                         const TYPE&  value,
                                         size_t       hashValue) const
    {
        const TYPE *ptr;
        for (*idx = hashValue & d_bucketArrayMask; (ptr = d_bucketArray[*idx]);
                                       *idx = (*idx + 1) & d_bucketArrayMask) {
            if (value == *ptr) {
                return true;                                          // RETURN
            }
        }

        // value was not found in table

        return false;
    }

    // CREATORS
    template <class TYPE, class HASHER>
    HashTable<TYPE, HASHER>::HashTable(const TYPE *valuesArray,
                                       size_t      numValues)
    : d_values(valuesArray)
    , d_numValues(numValues)
    , d_hasher()
    {
        size_t bucketArrayLength = 4;
        while (bucketArrayLength < numValues * 4) {
            bucketArrayLength *= 2;

        }
        d_bucketArrayMask = bucketArrayLength - 1;
        d_bucketArray = new const TYPE *[bucketArrayLength];
        memset(d_bucketArray,  0, bucketArrayLength * sizeof(TYPE *));

        for (unsigned i = 0; i < numValues; ++i) {
            const TYPE& value = d_values[i];
            size_t idx;
            const bool found = lookup(&idx, value, d_hasher(value));
            BSLS_ASSERT_OPT(!found);    (void) found;
            d_bucketArray[idx] = &d_values[i];
        }
    }

    template <class TYPE, class HASHER>
    HashTable<TYPE, HASHER>::~HashTable()
    {
        delete [] d_bucketArray;
    }

    // ACCESSORS
    template <class TYPE, class HASHER>
    bool HashTable<TYPE, HASHER>::contains(const TYPE& value) const
    {
        size_t idx;
        return lookup(&idx, value, d_hasher(value));
    }
//..
// Then, we define a 'Future' class, which holds a c-string 'name', char
// 'callMonth', and short 'callYear'.
//..
    class Future {
//..
// This 'class' identifies a future contract.  It tracks the name, call month
// and year of the contract it represents, and allows equality comparison.
//..
        // DATA
        const char *d_name;    // held, not owned
        const char  d_callMonth;
        const short d_callYear;

      public:
        // CREATORS
        Future(const char *name, const char callMonth, const short callYear)
        : d_name(name), d_callMonth(callMonth), d_callYear(callYear)
            // Create a 'Future' object out of the specified 'name',
            // 'callMonth', and 'callYear'.
        {}

        Future() : d_name(""), d_callMonth('\0'), d_callYear(0)
            // Create a 'Future' with default values.
        {}

        // ACCESSORS
        const char * getMonth() const
            // Return the month that this future expires.
        {
            return &d_callMonth;
        }

        const char * getName() const
            // Return the name of this future
        {
            return d_name;
        }

        const short * getYear() const
            // Return the year that this future expires
        {
            return &d_callYear;
        }

        bool operator==(const Future& rhs) const
            // Compare this to the specified 'other' object and return true if
            // they are equal
        {
            return (!strcmp(d_name, rhs.d_name)) &&
                                              d_callMonth == rhs.d_callMonth &&
                                              d_callYear  == rhs.d_callYear;
        }
    };

    bool operator!=(const Future& lhs, const Future& rhs)
        // Compare compare the specified 'lhs' and 'rhs' objects and return
        // true if they are not equal
    {
        return !(lhs == rhs);
    }
//..
// Next, we need a hash functor for 'Future'.  We are going to use the
// 'WyHashAlgorithm' because it is a fast, general purpose hashing algorithm
// that will provide an easy way to combine the attributes of 'Future' objects
// that are salient to hashing into one reasonable hash that will distribute
// the items evenly throughout the hash table.
//..
    struct HashFuture {
        // This struct is a functor that will apply the 'WyHashAlgorithm' to
        // objects of type 'Future'.

        bsls::Types::Uint64 d_seed;

        HashFuture()
        {
            // Generate random bits in 'd_seed' based on the time of day in
            // nanoseconds.

            bsls::Types::Int64 nano =
                      bsls::SystemTime::nowMonotonicClock().totalNanoseconds();
            const int iterations = static_cast<int>(nano & 7) + 1;
            for (int ii = 0; ii < iterations; ++ii) {
                nano *= bsls::SystemTime::nowMonotonicClock().
                                                            totalNanoseconds();
                nano += nano >> 32;
            }

            BSLMF_ASSERT(sizeof(d_seed) <= sizeof(nano));

            memcpy(&d_seed, &nano, sizeof(d_seed));
        }

        // MANIPULATOR
        size_t operator()(const Future& future) const
            // Return the hash of the of the specified 'future'.  Note that
            // this uses the 'WyHashAlgorithm' to quickly combine the
            // attributes of 'Future' objects that are salient to hashing into
            // a hash suitable for a hash table.
        {
            bslh::WyHashAlgorithm hash(d_seed);

            hash(future.getName(),  strlen(future.getName()));
            hash(future.getMonth(), sizeof(char));
            hash(future.getYear(),  sizeof(short));

            return static_cast<size_t>(hash.computeHash());
        }
    };
//..

//=============================================================================
//                     GLOBAL TYPEDEFS FOR TESTING
//-----------------------------------------------------------------------------

typedef bslh::WyHashAlgorithm Obj;
typedef bsls::Types::Uint64   Uint64;

namespace {
namespace u {

const Uint64 minus1 = static_cast<Uint64>(0) - 1;
Uint64 mmixRandAccum = 0;

inline
void munge()
{
    mmixRandAccum = mmixRandAccum * 6364136223846793005ULL +
                                                        1442695040888963407ULL;
}

inline
unsigned mmixRandNum(Uint64 seed = minus1)
    // MMIX Linear Congruential Generator algorithm by Donald Knuth
{
    if (minus1 != seed) {
        mmixRandAccum = seed;

        munge();
        mmixRandAccum ^= mmixRandAccum >> 32;
        munge();
        mmixRandAccum ^= mmixRandAccum >> 32;
        munge();
    }

    munge();

    return static_cast<unsigned>(mmixRandAccum >> 32);
}

void mmixRandMemory(void *memory, size_t size)
{
    char *ram = static_cast<char *>(memory);
    char *end = ram + size;

    for (size_t toCopy; ram < end; ram += toCopy) {
        unsigned randVal = mmixRandNum();
        toCopy = std::min<size_t>(sizeof(unsigned), end - ram);

#ifdef BSLS_PLATFORM_IS_BIG_ENDIAN
        // always change to little endian

        randVal = bsls::ByteOrderUtil::swapBytes32(randVal);
#endif

        memcpy(ram, &randVal, toCopy);
    }
}

template <class TYPE>
void mmixRandVal(TYPE *var)
{
    Uint64 accum = mmixRandNum();
    accum |= (static_cast<Uint64>(mmixRandNum()) << 32);

    *var = static_cast<TYPE>(accum);
}

}  // close namespace u
}  // close unnamed namespace

                                // ---------
                                // MatchTest
                                // ---------

namespace MatchTest {

// This is downloaded from
// https://github.com/wangyi-fudan/wyhash/blob/master/wyhash.h with as little
// modification as possible, to be compared to make sure that BDE-formatted
// version produces exactly the same results as the original algorithm.

#ifndef WYHASH_CONDOM
//protections that produce different results:
//1: normal valid behavior
//2: extra protection against entropy loss (probability=2^-63), aka. "blind multiplication"
#define WYHASH_CONDOM 1
#endif

#ifndef WYHASH_32BIT_MUM
//0: normal version, slow on 32 bit systems
//1: faster on 32 bit systems but produces different results, incompatible with wy2u0k function
#define WYHASH_32BIT_MUM 0
#endif

//likely and unlikely macros
#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
  #define _likely_(x)  __builtin_expect(x,1)
  #define _unlikely_(x)  __builtin_expect(x,0)
#else
  #define _likely_(x) (x)
  #define _unlikely_(x) (x)
#endif

//128bit multiply function
inline uint64_t _wyrot(uint64_t x) { return (x>>32)|(x<<32); }
inline void _wymum(uint64_t *A, uint64_t *B){
#if(WYHASH_32BIT_MUM)
  uint64_t hh=(*A>>32)*(*B>>32), hl=(*A>>32)*(uint32_t)*B, lh=(uint32_t)*A*(*B>>32), ll=(uint64_t)(uint32_t)*A*(uint32_t)*B;
  #if(WYHASH_CONDOM>1)
  *A^=_wyrot(hl)^hh; *B^=_wyrot(lh)^ll;
  #else
  *A=_wyrot(hl)^hh; *B=_wyrot(lh)^ll;
  #endif
#elif defined(__SIZEOF_INT128__)
  __uint128_t r=*A; r*=*B;
  #if(WYHASH_CONDOM>1)
  *A^=(uint64_t)r; *B^=(uint64_t)(r>>64);
  #else
  *A=(uint64_t)r; *B=(uint64_t)(r>>64);
  #endif
#elif defined(_MSC_VER) && defined(_M_X64)
  #if(WYHASH_CONDOM>1)
  uint64_t  a,  b;
  a=_umul128(*A,*B,&b);
  *A^=a;  *B^=b;
  #else
  *A=_umul128(*A,*B,B);
  #endif
#else
  uint64_t ha=*A>>32, hb=*B>>32, la=(uint32_t)*A, lb=(uint32_t)*B, hi, lo;
  uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0<<32), c=t<rl;
  lo=t+(rm1<<32); c+=lo<t; hi=rh+(rm0>>32)+(rm1>>32)+c;
  #if(WYHASH_CONDOM>1)
  *A^=lo;  *B^=hi;
  #else
  *A=lo;  *B=hi;
  #endif
#endif
}

//multiply and xor mix function, aka MUM
static inline uint64_t _wymix(uint64_t A, uint64_t B){ _wymum(&A,&B); return A^B; }

//endian macros
#ifndef WYHASH_LITTLE_ENDIAN
  #if defined(_WIN32) || defined(__LITTLE_ENDIAN__) || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || defined(BSLS_PLATFORM_IS_LITTLE_ENDIAN)
    #define WYHASH_LITTLE_ENDIAN 1
  #elif defined(__BIG_ENDIAN__) || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__) || defined(BSLS_PLATFORM_IS_BIG_ENDIAN)
    #define WYHASH_LITTLE_ENDIAN 0
  #else
    #error could not determine endianness! Falling back to little endian.
    #define WYHASH_LITTLE_ENDIAN 1
  #endif
#endif

//read functions
#if (WYHASH_LITTLE_ENDIAN)
inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return v;}
inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return v;}
#elif defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return __builtin_bswap64(v);}
inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return __builtin_bswap32(v);}
#elif defined(_MSC_VER)
inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return _byteswap_uint64(v);}
inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return _byteswap_ulong(v);}
#else
inline uint64_t _wyr8(const uint8_t *p) {
  uint64_t v; memcpy(&v, p, 8);
  return (((v >> 56) & 0xff)| ((v >> 40) & 0xff00)| ((v >> 24) & 0xff0000)| ((v >>  8) & 0xff000000)| ((v <<  8) & 0xff00000000ull)| ((v << 24) & 0xff0000000000ull)| ((v << 40) & 0xff000000000000ull)| ((v << 56) & 0xff00000000000000ull));
}
static inline uint64_t _wyr4(const uint8_t *p) {
  uint32_t v; memcpy(&v, p, 4);
  return (((v >> 24) & 0xff)| ((v >>  8) & 0xff00)| ((v <<  8) & 0xff0000)| ((v << 24) & 0xff000000));
}
#endif
inline uint64_t _wyr3(const uint8_t *p, size_t k) { return (((uint64_t)p[0])<<16)|(((uint64_t)p[k>>1])<<8)|p[k-1];}

//wyhash main function
uint64_t wyhash(const void *key, size_t len, uint64_t seed, const uint64_t *secret){
  const uint8_t *p=(const uint8_t *)key; seed^=*secret; uint64_t        a,      b;
  if(_likely_(len<=16)){
    if(_likely_(len>=4)){ a=(_wyr4(p)<<32)|_wyr4(p+((len>>3)<<2)); b=(_wyr4(p+len-4)<<32)|_wyr4(p+len-4-((len>>3)<<2)); }
    else if(_likely_(len>0)){ a=_wyr3(p,len); b=0;}
    else a=b=0;
  }
  else{
    size_t i=len;
    if(_unlikely_(i>48)){
      uint64_t see1=seed, see2=seed;
      do{
        seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);
        see1=_wymix(_wyr8(p+16)^secret[2],_wyr8(p+24)^see1);
        see2=_wymix(_wyr8(p+32)^secret[3],_wyr8(p+40)^see2);
        p+=48; i-=48;
      }while(_likely_(i>48));
      seed^=see1^see2;
    }
    while(_unlikely_(i>16)){  seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);  i-=16; p+=16;  }
    a=_wyr8(p+i-16);  b=_wyr8(p+i-8);
  }
  return _wymix(secret[1]^len,_wymix(a^secret[1],b^seed));
}

//the default secret parameters
const uint64_t _wyp[4] = {0xa0761d6478bd642full, 0xe7037ed1a0b428dbull, 0x8ebc6af09c88c6e3ull, 0x589965cc75374cc3ull};

struct Alg {
    // DATA
    uint64_t d_data;

    // CREATOR
    Alg()
    : d_data(0x50defacedfacade5ULL)
    {}

    explicit
    Alg(uint64_t seed)
    : d_data(seed)
    {}

    // MANIPULATORS
    void operator()(const void *data, size_t numBytes)
    {
        d_data ^= wyhash(data, numBytes, d_data, _wyp);
    }

    Uint64 computeHash()
    {
        return d_data;
    }
};

#undef WYHASH_CONDOM
#undef WYHASH_32BIT_MUM
#undef _likely_
#undef _unlikely_
#undef WYHASH_LITTLE_ENDIAN

}  // close namespace MatchTest

int numBitsSet(Uint64 x)
{
    int ret = 0;
    for (; x; ++ret) {
        x &= x - 1;
    }

    return ret;
}

// ============================================================================
//                            MAIN PROGRAM
// ----------------------------------------------------------------------------

int main(int argc, char *argv[])
{
    int                 test = argc > 1 ? atoi(argv[1]) : 0;
    bool             verbose = argc > 2;    (void) verbose;
    bool         veryVerbose = argc > 3;    (void) veryVerbose;
    bool     veryVeryVerbose = argc > 4;    (void) veryVeryVerbose;
    bool veryVeryVeryVerbose = argc > 5;    (void) veryVeryVeryVerbose;

    (void)veryVeryVeryVerbose;  // suppress warning

    printf("TEST " __FILE__ " CASE %d\n", test);

    switch (test) { case 0:
      case 9: {
        // --------------------------------------------------------------------
        // USAGE EXAMPLE
        //   The hashing algorithm can be used to create more powerful
        //   components such as functors that can be used to power hash tables.
        //
        // Concerns:
        //: 1 The usage example provided in the component header file compiles,
        //:   links, and runs as shown.
        //
        // Plan:
        //: 1 Incorporate usage example from header into test driver (C-1)
        //
        // Testing:
        //   USAGE EXAMPLE
        // --------------------------------------------------------------------

        if (verbose) printf("USAGE EXAMPLE\n"
                            "=============\n");

// Then, we want to actually use our hash table on 'Future' objects.  We create
// an array of 'Future's based on data that was originally from some external
// source:
//..
        Future futures[] = { Future("Swiss Franc", 'F', 2014),
                             Future("US Dollar", 'G', 2015),
                             Future("Canadian Dollar", 'Z', 2014),
                             Future("British Pound", 'M', 2015),
                             Future("Deutsche Mark", 'X', 2016),
                             Future("Eurodollar", 'Q', 2017)};
        enum { NUM_FUTURES = sizeof futures / sizeof *futures };
//..
// Next, we create our HashTable 'hashTable'.  We pass the functor that we
// defined above as the second argument:
//..
        HashTable<Future, HashFuture> hashTable(futures, NUM_FUTURES);
//..
// Now, we verify that each element in our array registers with count:
//..
        for ( int i = 0; i < 6; ++i) {
            ASSERT(hashTable.contains(futures[i]));
        }
//..
// Finally, we verify that futures not in our original array are correctly
// identified as not being in the set:
//..
        ASSERT(!hashTable.contains(Future("French Franc", 'N', 2019)));
        ASSERT(!hashTable.contains(Future("Swiss Franc", 'X', 2014)));
        ASSERT(!hashTable.contains(Future("US Dollar", 'F', 2014)));
//..
      } break;
      case 8: {
        // --------------------------------------------------------------------
        // PLATFORM INDEPENDENCE TEST
        //
        // Concerns:
        //: 1 That all platforms get the same hash values for given memory
        //:   input.
        //
        // Plan:
        //: 1 Use the 'mmix*' random number generator in the 'u' namespace in
        //:   this file to create input data.  The 'MMIX' algorithm is a
        //:   modification of Donald Knuth's random number algorithm, and it
        //:   produces the same result regardless of platform and CPU
        //:   endian-ness.
        //:
        //: 2 In each iteration, seed the 'mmix' random number generator in
        //:   the 'u' namespace in this file with the iteration counter.
        //:
        //: 3 Use the now-seeded random number generator to populate a buffer
        //:   with data.
        //:
        //: 4 Use the random number generator to produce a random number seed.
        //:
        //: 5 Hash the buffer, with and without using the generated seed, to
        //:   create 2 hash values.
        //:
        //: 6 Compare the hash values created with the hash values in the
        //:   table, and confirm that they match.
        //:
        //: 7 Since the table values are the same across all platforms, running
        //:   this test on all platforms confirms that the hash function is
        //:   platform-independent.
        //
        // Testing:
        //   PLATFORM INDEPENDENCE
        // --------------------------------------------------------------------

        if (verbose) printf("PLATFORM INDEPENDENCE TEST\n"
                            "==========================\n");

        static const struct Data {
            int    d_line;
            size_t d_len;
            Uint64 d_hash;
            Uint64 d_seedlessHash;
        } DATA[] = {
            { L_,  0, 0x0840b4221c56e786ULL, 0xe0a732a8bf7d7e68ULL },
            { L_,  1, 0xd2e76925e210d3cfULL, 0xc148bd58364217b0ULL },
            { L_,  2, 0x7f7295ca10b85125ULL, 0x6b435e94355591ccULL },
            { L_,  3, 0xc0c3febe8e225d76ULL, 0xbdc63ece1ff113edULL },
            { L_,  4, 0x265412a7905945daULL, 0x9683a40424114d77ULL },
            { L_,  5, 0xd8446241c2f5cba7ULL, 0x12ace40bf6080d66ULL },
            { L_,  6, 0x0e82a29294205926ULL, 0xe77265e6dc8b1956ULL },
            { L_,  7, 0xfbf69aa1eb5d0ab4ULL, 0x2e62383ee557733fULL },
            { L_,  8, 0x63ec8478d268ff64ULL, 0x2e7149a6e9ab97f2ULL },
            { L_,  9, 0xd0e0a22bf719e4d0ULL, 0x745b86e5a55bcdaeULL },
            { L_, 10, 0x3fb791bb6d323e44ULL, 0xda6b575752f592a8ULL },
            { L_, 11, 0xe90c40e8be4a4d2dULL, 0x75f9deb0007c3b33ULL },
            { L_, 12, 0xa616e0afdf6f0b5cULL, 0x60812d3aba2607dcULL },
            { L_, 13, 0x054ce64c43a8a17cULL, 0x8510bf1bafc8d60cULL },
            { L_, 14, 0xeaa0cae988990e4aULL, 0x2a637ac9d3266b2bULL },
            { L_, 15, 0x10b1aa7b0903e065ULL, 0x47ab89f3f2cd83faULL },
            { L_, 16, 0x00f08a1f65ee4afeULL, 0xefa30473c2e4c575ULL },
            { L_, 17, 0x540dbe2595eb73d8ULL, 0x6ffd989ab22bc4eeULL },
            { L_, 18, 0xce7746b930832f9eULL, 0x9a7e0c6e21955d04ULL },
            { L_, 19, 0xa422e395943fc25eULL, 0x7db5440bb207b0b9ULL },
            { L_, 20, 0xa5a0cd01ec402747ULL, 0x2cf922c529630df0ULL },
            { L_, 21, 0xe5bcd4e37871a0f4ULL, 0x57a0c87ae1ea57a4ULL },
            { L_, 22, 0x77e366ae419f227fULL, 0x087631f1eb486142ULL },
            { L_, 23, 0xc170537ac4baec43ULL, 0x0e6bc6cb6cb0daf7ULL },
            { L_, 24, 0xeaebaa8ffb72d8a6ULL, 0xac4f2f0a0075ebdbULL },
            { L_, 25, 0xa986caefd2c9ba1bULL, 0x5564a00ef56d63dcULL },
            { L_, 26, 0x1dc71f45e4422bb2ULL, 0x70ec22e2260f04c3ULL },
            { L_, 27, 0x30014325d9dd470dULL, 0x2d8f87742967e853ULL },
            { L_, 28, 0xd4853210adda6893ULL, 0x137ddab26de321f2ULL },
            { L_, 29, 0x864d869833c38ca1ULL, 0x4b138619f98b3146ULL },
            { L_, 30, 0x1c41ccfcc37deed8ULL, 0x19d692030eabce8aULL },
            { L_, 31, 0xadb2e4f3cd5b148cULL, 0x48fe93438f5e1a81ULL },
            { L_, 32, 0x7ac5ef8a387c716dULL, 0x398295062b397acaULL },
            { L_, 33, 0x8e9d2da66cbeb3c4ULL, 0xe1e70e60b035db1dULL },
            { L_, 34, 0xd63f40d73317cbc4ULL, 0x09b951910781aaf3ULL },
            { L_, 35, 0x978a5c54a7ce73fbULL, 0xf46a1e0b26fc3278ULL },
            { L_, 36, 0x2917d0ec576c7da3ULL, 0xde920f0e726893f4ULL },
            { L_, 37, 0x6ee6621032df51adULL, 0xaafe273dbf9f0787ULL },
            { L_, 38, 0xbcfeb646c87c34a0ULL, 0x55a5ae3894627c4dULL },
            { L_, 39, 0xef7e74a8b89cc0b7ULL, 0x12b125d480d27a5fULL },
            { L_, 40, 0xcc84ce412cc525e3ULL, 0x2560dd1a765afaf5ULL },
            { L_, 41, 0x77c895947bbb2a49ULL, 0x87ad18244f15eb8fULL },
            { L_, 42, 0x707babdc48d541baULL, 0x44ae8a16cf5e0ae3ULL },
            { L_, 43, 0x2abbc1654062648bULL, 0xec48404b189f6df8ULL },
            { L_, 44, 0xc49c9bc6121d188fULL, 0xad99b9c54753b40dULL },
            { L_, 45, 0xeb566c3234872820ULL, 0x7b9371dc6f0642f8ULL },
            { L_, 46, 0x7bd0ca3e1017d0e5ULL, 0x62a9ffcf302a3461ULL },
            { L_, 47, 0xd9b2eeb167bb5454ULL, 0xf01e7623b331387bULL },
            { L_, 48, 0x784a3a7bd20bfaa2ULL, 0x9fca5880933fb0d9ULL },
            { L_, 49, 0xd9d9ff94ab97d115ULL, 0xd0b3815f0acc0d5fULL },
            { L_, 50, 0x3772baf11d95303bULL, 0x1cc85fb767413f34ULL },
            { L_, 51, 0xfc2b981f880d2e17ULL, 0x795b9f053850f7a2ULL },
            { L_, 52, 0x3bce47c758a5d726ULL, 0xc3c024b1ac5993e0ULL },
            { L_, 53, 0xc2b82bb7e8812049ULL, 0x3b88ba4b6a5f46cdULL },
            { L_, 54, 0x242be0f513e9290cULL, 0x168591d45153f78dULL },
            { L_, 55, 0x6c1b9f63afcd651dULL, 0x8ab45c4898a8f584ULL },
            { L_, 56, 0x1192b7cf45aa3e94ULL, 0x0eb395e7dc4bdefeULL },
            { L_, 57, 0x21e0ba0ee7fa13b1ULL, 0xda169e8208684910ULL },
            { L_, 58, 0x85f7e268c64d7f88ULL, 0xd9513aebab5934e7ULL },
            { L_, 59, 0x861bb28b88195c1dULL, 0x066f64b206f8512dULL },
            { L_, 60, 0x0bc7b63f457fd02cULL, 0x60e100ce76467417ULL },
            { L_, 61, 0x9db41b78b14623dfULL, 0xaea50325d129d0c4ULL },
            { L_, 62, 0x20b8854eaaab750dULL, 0xda32158ff7d3a04dULL },
            { L_, 63, 0x9f275b8f3c72703aULL, 0x2e6d0b5460b2de17ULL },
            { L_, 64, 0xf7264eba098773d4ULL, 0xcfdbdc4724b5e569ULL },
            { L_, 65, 0x690f8332baf6ead2ULL, 0x50c24dc3bbbb6f5cULL },
            { L_, 66, 0x7c8fe2a6f9a2da1cULL, 0xaedbf3ed25182d0bULL },
            { L_, 67, 0x7dcab376cf345327ULL, 0xa134fd7782f32854ULL },
            { L_, 68, 0xba01b4999b9b2c46ULL, 0x06f9888cd01d45ddULL },
            { L_, 69, 0xf63ce727bbfe6538ULL, 0xb107b33b0645d640ULL },
            { L_, 70, 0xd1ae6408c5835c40ULL, 0x70a45dc41eed1594ULL },
            { L_, 71, 0x6486dbfe63d60ab7ULL, 0x8b237b8c23b1de93ULL },
            { L_, 72, 0xaf8a324f453cf05fULL, 0x00c6ad2a4986ec2dULL },
            { L_, 73, 0xbbb584ea0fb5ff4cULL, 0xfe45e4192278ca17ULL },
            { L_, 74, 0xe94f99ee5f3a1df4ULL, 0x5c742ee0ea400c6fULL },
            { L_, 75, 0x7fd8fa0bee5439c8ULL, 0xcb706ad67d8e1ee3ULL },
            { L_, 76, 0xf7c0ba560bb3f732ULL, 0x18fbe2d0dad40e33ULL },
            { L_, 77, 0x71c3c8c0328d5dc7ULL, 0x16e195251c62d510ULL },
            { L_, 78, 0x844ee9e0c78aa049ULL, 0xe4ebff13933f09b0ULL },
            { L_, 79, 0x148244fad3548c3aULL, 0xd0809293db898719ULL },
            { L_, 80, 0xc878fc1b8200f05dULL, 0x9db56c060f266502ULL },
            { L_, 81, 0x942d3b58f4595d75ULL, 0x1dc7c8db0193d1feULL },
            { L_, 82, 0x0a9714e2013206fbULL, 0x637f94ae64a6becfULL },
            { L_, 83, 0x37b6da53347d0a3aULL, 0x2919770edfe02641ULL },
            { L_, 84, 0x75e1435bb931a469ULL, 0xb1b2df03c767269aULL },
            { L_, 85, 0xb4249c1a7f920941ULL, 0x65d9181bf5e235c8ULL },
            { L_, 86, 0x29b0013d3f49761aULL, 0xd0481f9bfa81822fULL },
            { L_, 87, 0xecee003da7ee7ca2ULL, 0x64fac0446dd25c46ULL },
            { L_, 88, 0xf01dfaa169e900f6ULL, 0x963686b8e311e905ULL },
            { L_, 89, 0xa6943adf4b068a29ULL, 0x1177ecd9ba27c4ddULL },
            { L_, 90, 0x92b16a461664386eULL, 0x4eba672d8ce245daULL },
            { L_, 91, 0x063e8b875acaa067ULL, 0xaf66cc8a9052d3c7ULL },
            { L_, 92, 0x34cb66db6e875430ULL, 0x22b16b37969e062dULL },
            { L_, 93, 0xa255b058397e7219ULL, 0xb432a7bffa061117ULL },
            { L_, 94, 0x9bd656ac4c492613ULL, 0x59e681c7258076aeULL },
            { L_, 95, 0x4c92a5fd931afcaaULL, 0x27996a62ab96402cULL },
            { L_, 96, 0xfd7a79af556f9608ULL, 0xf117c97958152845ULL },
            { L_, 97, 0x5e8718725b3504bfULL, 0x8ee569ab0dfbd93eULL },
            { L_, 98, 0xe1234976bbc60dafULL, 0x690db421736c0997ULL },
            { L_, 99, 0xaf13757d1b5f4bd1ULL, 0xa31cbbd8293704f1ULL }
        };
        enum { k_DATA_LEN = sizeof DATA / sizeof *DATA };

        char buffer[100];

        for (int ti = 0; ti < k_DATA_LEN; ++ti) {
            const Data&  data = DATA[ti];
            const int    LINE          = data.d_line;
            const size_t LEN           = data.d_len;
            const Uint64 HASH          = data.d_hash;
            const Uint64 SEEDLESS_HASH = data.d_seedlessHash;

            u::mmixRandNum(ti);
            u::mmixRandMemory(buffer, LEN);
            Uint64 seed;
            u::mmixRandVal(&seed);
            Uint64 leSeed = BSLS_BYTEORDER_HOST_U64_TO_LE(seed);

            if (veryVerbose) {
                P_(buffer[0]);    P_(buffer[LEN - 1]);    P(seed);
            }

            Obj hash(reinterpret_cast<const char *>(&leSeed));
            hash(buffer, LEN);
            const Uint64 hashVal = hash.computeHash();

            Obj hash2(seed);
            hash2(buffer, LEN);
            const Uint64 hash2Val = hash2.computeHash();

            Obj seedlessHash;
            seedlessHash(buffer, LEN);
            const Uint64 seedlessHashVal = seedlessHash.computeHash();

#if 0
            printf("{ L_, %2d, 0x%016llxULL, 0x%016llxULL },\n",
                              static_cast<int>(LEN), hashVal, seedlessHashVal);
#endif

            ASSERTV(LINE, HASH, hashVal, HASH == hashVal);
            ASSERTV(LINE, HASH, hashVal, HASH == hash2Val);
            ASSERTV(LINE, SEEDLESS_HASH, seedlessHashVal,
                                             SEEDLESS_HASH == seedlessHashVal);
        }
      } break;
      case 7: {
        // --------------------------------------------------------------------
        // ALIGNMENT INDEPENDENCE TEST
        //
        // Concern:
        //: 1 That the hash value is independent of the alignment of input.
        //
        // Plan:
        //: 1 Populate a buffer with random data, hash it, then mememove the
        //:   data to different locations and observe that the hash value
        //:   doesn't change.
        //
        // Testing:
        //   ALIGNMENT INDEPENDENCE
        // --------------------------------------------------------------------

        if (verbose) printf("ALIGNMENT INDEPENDENCE TEST\n"
                            "===========================\n");

        enum { k_MAX_DATA_LEN = 64,
               k_MAX_SHIFT = 7 };
        char buffer[k_MAX_DATA_LEN + k_MAX_SHIFT];

        for (int ii = 1 << 20; 0 < ii--; ) {
            const size_t len = u::mmixRandNum() % (k_MAX_DATA_LEN + 1);
            u::mmixRandMemory(buffer, len);

            const Uint64 seed = u::mmixRandNum() |
                                 (static_cast<Uint64>(u::mmixRandNum()) << 32);

            Obj hash(seed);
            hash(buffer, len);
            const Uint64 hashVal = hash.computeHash();

            for (int jj = 1; jj <= k_MAX_SHIFT; ++jj) {
                ::memmove(buffer + jj, buffer + jj - 1, len);

                Obj hashB(seed);
                hashB(buffer + jj, len);
                ASSERT(hashB.computeHash() == hashVal);
            }
        }
      } break;
      case 6: {
        // --------------------------------------------------------------------
        // MATCH TEST
        //
        // Concerns:
        //: 1 That the component under test produces EXACTLY the same results
        //:   as the original code from
        //:   https://github.com/wangyi-fudan/wyhash/blob/master/wyhash.h
        //
        // Plan:
        //: 1 Create a random number generator.
        //:
        //: 2 Populate a buffer with random data.
        //:
        //: 3 Have a minimally-modified copy of the code from the website in
        //:   test driver, and hash with both that and the hash function
        //:   provided by this component, and compare the results.
        //:
        //: 4 Hash on varying subranges of the buffer.
        //
        // Testing:
        //   MATCH TEST
        // --------------------------------------------------------------------

        if (verbose) printf("MATCH TEST\n"
                            "==========\n");

        namespace TC = MatchTest;

        enum { k_MAX_LEN = 1024 };

        char buffer[k_MAX_LEN];    const char *constBuffer = buffer;
        Uint64 seed;

        static const Uint64 data[] = { 0, 1, 2, 3, 4, 8, 16, 127, 128, 255,
           0x7fffffffffffffffULL, 0x8000000000000000ULL, 0xffffffffffffffffULL,
           0x1234567812345678ULL, 0x8765432187654321ULL, 0xf0f0f0f0f0f0f0f0ULL,
           0x8080808080808080ULL, 0xaaaaaaaaaaaaaaaaULL, 0xa0a0a0a0a0a0a0a0ULL,
           0x123456789abcdef0ULL, 0x0fedcba987654321ULL, 0x1122334455667788ULL,
           0x9900aabbccddeeffULL
        };
        enum { k_DATA_LEN   = sizeof data / sizeof *data };

        if (verbose) {
            printf("Table-driven test: k_DATA_LEN: %d\n", k_DATA_LEN);
        }

        static int misses[k_MAX_LEN + 1], hits[k_MAX_LEN + 1];
        bool matchFail = false;
        for (int ti = 0; ti < k_DATA_LEN; ++ti) {
            const char *pBeginRaw = reinterpret_cast<const char *>(&data[ti]);
            const char *pEndRaw   = pBeginRaw + sizeof(Uint64);
            for (const char *pBegin = pBeginRaw; pBegin < pEndRaw; ++pBegin) {
                for (const char *pEnd = pBegin; pEnd <= pEndRaw; ++pEnd) {
                    const size_t numBytes = pEnd - pBegin;

                    if (0 == numBytes && (pBeginRaw < pBegin || 0 != ti)) {
                        continue;
                    }

                    for (int tj = 0; tj < k_DATA_LEN; ++tj) {
                        const Uint64 seed   = data[tj];

                        TC::Alg oldH(seed);
                        oldH(pBegin, numBytes);
                        Uint64 oldHash = oldH.computeHash();

                        Obj hash(seed);
                        hash(pBegin, numBytes);
                        Uint64 newHash = hash.computeHash();

                        bool fail;
                        ASSERTV(oldHash, newHash, seed, numBytes,
                                  numBytes % 32, !(fail = oldHash != newHash));

                        hits  [numBytes] += !fail;
                        misses[numBytes] += fail;
                        matchFail   |= fail;
                    }
                }
            }
        }

        if (veryVerbose || matchFail) {
            printf("Results of table-driven test:\n");
            for (unsigned ii = 0; ii <= sizeof(Uint64); ++ii) {
                printf("%smod: %2d, misses: %5d, hits: %5d\n",
                            0 == ii % 4 ? "\n" : "", ii, misses[ii], hits[ii]);
            }
        }

        if (verbose) printf("Random-Driven Test\n");

        memset(misses, 0, sizeof(misses));
        memset(hits,   0, sizeof(hits));
        matchFail = false;
        for (int ii = 0; ii < (1 << 12); ++ii) {
            u::mmixRandVal(&seed);
            u::mmixRandMemory(&buffer, sizeof(buffer));

            for (unsigned dataLen = 0; dataLen <= k_MAX_LEN; ++dataLen) {
                TC::Alg oldH(seed);
                oldH(constBuffer, dataLen);
                const Uint64 oldHash = oldH.computeHash();

                Obj hash(seed);
                hash(constBuffer, dataLen);
                const Uint64 newHash = hash.computeHash();

                if ((veryVerbose && ii < 10) || veryVeryVerbose) {
                    printf("%d seed: 0x%016llx size: %u"
                                          "\nold: 0x%016llx\nnew: 0x%016llx\n",
                                          ii, seed, dataLen, oldHash, newHash);
                }

                bool fail;
                ASSERTV(ii, oldHash, newHash, seed, dataLen, dataLen % 32,
                                                 !(fail = oldHash != newHash));

                hits  [dataLen] += !fail;
                misses[dataLen] += fail;
                matchFail       |= fail;
            }
        }

        if (veryVerbose || matchFail) {
            printf("Results of random test:\n");
            for (int ii = 0; ii <= k_MAX_LEN; ++ii) {
                printf("%smod: %2d, misses: %5d, hits: %5d\n",
                            0 == ii % 4 ? "\n" : "", ii, misses[ii], hits[ii]);
            }
        }
      } break;
      case 5: {
        // --------------------------------------------------------------------
        // TESTING BDE TYPE TRAITS
        //   The class is bitwise movable and should have a trait that
        //   indicates that.
        //
        // Concerns:
        //: 1 The class is marked as 'IsBitwiseMoveable'.
        //
        // Plan:
        //: 1 ASSERT the presence of the trait using the 'bslalg::HasTrait'
        //:   metafunction. (C-1)
        //
        // Testing:
        //   Trait IsBitwiseMoveable
        // --------------------------------------------------------------------

        if (verbose) printf("TESTING BDE TYPE TRAITS\n"
                            "=======================\n");

        if (verbose) printf("ASSERT the presence of the trait using the"
                            " 'bslalg::HasTrait' metafunction. (C-1)\n");
        {
            ASSERT(bslmf::IsBitwiseMoveable<Obj>::value);
        }

      } break;
      case 4: {
        // --------------------------------------------------------------------
        // TESTING 'result_type' TYPEDEF
        //   Verify that the class offers the result_type typedef that needs to
        //   be exposed by all 'bslh' hashing algorithms
        //
        // Concerns:
        //: 1 The typedef 'result_type' is publicly accessible and an alias for
        //:   'bsls::Types::Uint64'.
        //:
        //: 2 'computeHash()' returns 'result_type'
        //:
        //: 2 'operator()(const void *, size_t)' returns 'void'
        //
        // Plan:
        //: 1 ASSERT the typedef is accessible and is the correct type using
        //:   'bslmf::IsSame'. (C-1)
        //:
        //: 2 Declare the expected signature of 'computeHash()' and then assign
        //:   to it.  If it compiles, the test passes. (C-2)
        //:
        //: 3 Declare the expected signature of 'operator()' and then assign to
        //:   it.  If it compiles, the test passes.  (C-3)
        //
        // Testing:
        //   typedef bsls::Types::Uint64 result_type;
        // --------------------------------------------------------------------

        if (verbose) printf("TESTING 'result_type' TYPEDEF\n"
                            "=============================\n");

        if (verbose) printf("ASSERT the typedef is accessible and is the"
                            " correct type using 'bslmf::IsSame'. (C-1)\n");
        {
            ASSERT((bslmf::IsSame<bsls::Types::Uint64,
                                  Obj::result_type>::VALUE));
        }
        if (verbose) printf("Declare the expected signature of 'computeHash()'"
                            " and then assign to it.  If it compiles, the test"
                            " passes. (C-2)\n");
        {
            Obj::result_type (Obj::*expectedSignature) ();

            expectedSignature = &Obj::computeHash;
            (void)expectedSignature;
        }

        if (verbose) printf("Declare the expected signature of 'operator()'"
                            " and then assign to it.  If it compiles, the test"
                            " passes. (C-3)\n");
        {
            void (Obj::*expectedSignature)(const void *, size_t);

            expectedSignature = &Obj::operator();
            (void)expectedSignature;
        }
      } break;
      case 3: {
        // --------------------------------------------------------------------
        // TESTING TESTING 'operator()' AND 'computeHash()'
        //   Verify the class provides an overload for the function call
        //   operator that can be called with some bytes and a length.  Verify
        //   that calling 'operator()' will permute the algorithm's internal
        //   state as specified by WyHash.  Verify that 'computeHash()'
        //   returns the final value specified by the canonical WyHash
        //   implementation.
        //
        // Concerns:
        //: 1 The function call operator is callable.
        //:
        //: 2 Given the same bytes, the function call operator will permute the
        //:   internal state of the algorithm in the same way, regardless of
        //:   whether the bytes are passed in all at once or in pieces.
        //:
        //: 3 Byte sequences passed in to 'operator()' with a length of 0 will
        //:   not contribute to the final hash
        //:
        //: 4 'computeHash()' and returns the appropriate value according to
        //:   the WyHash specification.
        //:
        //: 5 'operator()' does a BSLS_ASSERT for null pointers and non-zero
        //:   length, and not for null pointers and zero length.
        //
        // Plan:
        //: 1 Insert various lengths of c-strings into the algorithm both all
        //:   at once and char by char using 'operator()'.  Assert that the
        //:   algorithm produces the same result in both cases. (C-1,2)
        //:
        //: 2 Hash c-strings all at once and with multiple calls to
        //:   'operator()' with length 0.  Assert that both methods of hashing
        //:   c-strings produce the same values.(C-3)
        //:
        //: 3 Check the output of 'computeHash()' against the expected results
        //:   from a known good version of the algorithm. (C-4)
        //:
        //: 4 Call 'operator()' with a null pointer. (C-5)
        //
        // Testing:
        //   void operator()(void const* key, size_t len);
        //   result_type computeHash();
        // --------------------------------------------------------------------

        if (verbose) printf("NEGATIVE TESTING\n"
                            "================\n");

        if (verbose) printf("Call 'operator()' with null pointers. (C-5)\n");
        {
            const char data[5] = {'a', 'b', 'c', 'd', 'e'};

            bsls::AssertTestHandlerGuard guard;

            ASSERT_FAIL(Obj().operator()(   0, 5));
            ASSERT_PASS(Obj().operator()(   0, 0));
            ASSERT_PASS(Obj().operator()(data, 5));
        }
      } break;
      case 2: {
        // --------------------------------------------------------------------
        // TESTING CREATORS
        //   Ensure that the implicit destructor as well as the explicit
        //   default and parameterized constructors are publicly callable.
        //   Verify that the algorithm can be instantiated with or without a
        //   seed.  Note that a null pointer is not tested here, because there
        //   is no way to perform a BSLS_ASSERT before dereferenceing the
        //   pointer (without a performance penalty).
        //
        // Concerns:
        //: 1 Objects can be created using the default constructor.
        //:
        //: 2 Objects can be created using either of the parameterized
        //:   constructors.
        //:
        //: 3 Objects can be destroyed.
        //
        // Plan:
        //: 1 Create a default constructed 'Obj' and allow it
        //:   to leave scope to be destroyed. (C-1,3)
        //:
        //: 2 Call the parameterized constructor with a seed. (C-2)
        //
        // Testing:
        //   Obj();
        //   Obj(const char *seed);
        //   Obj(Uint64 seed);
        //   ~Obj();
        // --------------------------------------------------------------------

        if (verbose)
            printf("TESTING CREATORS\n"
                   "================\n");

        if (verbose) printf("Create a default constructed"
                            " 'Obj' and allow it to leave"
                            " scope to be destroyed. (C-1,3)\n");
        {
            Obj alg1;
        }

        if (verbose) printf("Call the parameterized constructor with a seed."
                            " (C-2)\n");
        {
            Uint64 seed = 5;
            Obj alg1(reinterpret_cast<const char *>(&seed));
            Obj alg2(seed);
        }

      } break;
      case 1: {
        // --------------------------------------------------------------------
        // BREATHING TEST
        //   This case exercises (but does not fully test) basic functionality.
        //
        // Concerns:
        //: 1 The class is sufficiently functional to enable comprehensive
        //:   testing in subsequent test cases.
        //
        // Plan:
        //: 1 Create an instance of 'bsl::Obj'. (C-1)
        //:
        //: 2 Verify different hashes are produced for different c-strings.
        //:   (C-1)
        //:
        //: 3 Verify the same hashes are produced for the same c-strings. (C-1)
        //:
        //: 4 Verify different hashes are produced for different 'int's. (C-1)
        //:
        //: 5 Verify the same hashes are produced for the same 'int's. (C-1)
        //
        // Testing:
        //   BREATHING TEST
        // --------------------------------------------------------------------

        if (verbose) printf("BREATHING TEST\n"
                            "==============\n");

        if (verbose) printf("Instantiate 'bsl::Obj'\n");
        {
            Obj hashAlg;
        }

        if (verbose) printf("Verify different hashes are produced for"
                            " different c-strings.\n");
        {
            Obj hashAlg1;
            Obj hashAlg2;
            const char * str1 = "Hello World";
            const char * str2 = "Goodbye World";
            hashAlg1(str1, strlen(str1));
            hashAlg2(str2, strlen(str2));
            ASSERT(hashAlg1.computeHash() != hashAlg2.computeHash());
        }

        if (verbose) printf("Verify the same hashes are produced for the same"
                            " c-strings.\n");
        {
            Obj hashAlg1;
            Obj hashAlg2;
            const char * str1 = "Hello World";
            const char * str2 = "Hello World";
            hashAlg1(str1, strlen(str1));
            hashAlg2(str2, strlen(str2));
            ASSERT(hashAlg1.computeHash() == hashAlg2.computeHash());
        }

        if (verbose) printf("Verify different hashes are produced for"
                            " different 'int's.\n");
        {
            Obj hashAlg1;
            Obj hashAlg2;
            int int1 = 123456;
            int int2 = 654321;
            hashAlg1(&int1, sizeof(int));
            hashAlg2(&int2, sizeof(int));
            ASSERT(hashAlg1.computeHash() != hashAlg2.computeHash());
        }

        if (verbose) printf("Verify the same hashes are produced for the same"
                            " 'int's.\n");
        {
            Obj hashAlg1;
            Obj hashAlg2;
            int int1 = 123456;
            int int2 = 123456;
            hashAlg1(&int1, sizeof(int));
            hashAlg2(&int2, sizeof(int));
            ASSERT(hashAlg1.computeHash() == hashAlg2.computeHash());
        }
      } break;
      case -1: {
        // --------------------------------------------------------------------
        // DISPERSION TEST
        //
        // Concern:
        //: 1 Measure how much difference a change of 1 bit to the input makes
        //:   to the result.
        //
        // Plan:
        //: 1 Try the hash function with a variety of inputs, then perturb the
        //:   inputs by toggling one bit and see how much it changes the
        //:   result.
        //
        // Testing:
        //   DISPERSION TEST
        // --------------------------------------------------------------------

        if (verbose) printf("DISPERSION TEST\n"
                            "===============\n");

        Uint64 seed, data;
        static int seedDiffBits[64], dataDiffBits[64];

        bsls::Stopwatch sw;
        sw.start(true);

        for (int ti = 0; ti < 100 * 1000; ++ti) {
            u::mmixRandVal(&seed);
            u::mmixRandVal(&data);

            Uint64 result[3];
            {
                Obj hasher(seed);
                hasher(&data, sizeof(data));
                result[0] = hasher.computeHash();
            }

            for (int ii = 0; ii < 64; ++ii) {
                const Uint64 otherSeed = seed ^ (1ULL << ii);

                Obj hasher(otherSeed);
                hasher(&data, sizeof(data));
                result[1] = hasher.computeHash();
                ++seedDiffBits[numBitsSet(result[1] ^ result[0])];
            }

            for (int ii = 0; ii < 64; ++ii) {
                const Uint64 otherData = data ^ (1ULL << ii);

                Obj hasher(seed);
                hasher(&otherData, sizeof(otherData));
                result[2] = hasher.computeHash();
                ++dataDiffBits[numBitsSet(result[2] ^ result[0])];
            }
        }

        sw.stop();

        printf("Seed diff bits:\n");
        for (int ii = 0; ii < 64; ++ii) {
            printf("%2d: diff: %5d\n%s", ii, seedDiffBits[ii],
                                                      3 == ii % 4 ? "\n" : "");
        }

        printf("Data diff bits:\n");
        for (int ii = 0; ii < 64; ++ii) {
            printf("%2d: diff: %5d\n%s", ii, dataDiffBits[ii],
                                                      3 == ii % 4 ? "\n" : "");
        }

        double system, user, wall;
        sw.accumulatedTimes(&system, &user, &wall);
        printf("Times: wall: %g, system: %g, user: %g\n", wall, system, user);
      } break;
      default: {
        fprintf(stderr, "WARNING: CASE `%d' NOT FOUND.\n", test);
        testStatus = -1;
      }
    }
    return testStatus;
}

// ----------------------------------------------------------------------------
// Copyright 2021 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
