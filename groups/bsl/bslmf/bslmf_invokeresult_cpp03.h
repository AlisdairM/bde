// bslmf_invokeresult_cpp03.h                                         -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BSLMF_INVOKERESULT_CPP03
#define INCLUDED_BSLMF_INVOKERESULT_CPP03

//@PURPOSE: Provide C++03 implementation for bslmf_invokeresult.h
//
//@CLASSES: See bslmf_invokeresult.h for list of classes
//
//@SEE_ALSO: bslmf_invokeresult
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the the original
// header contains any specially delimited regions of C++11 code, then this
// generated file contains the C++03 equivelent, i.e., with variadic templates
// expanded and rvalue-references replaced by 'bslmf::MovableRef' objects.
// The header code in this file is designed to be '#include'd into the
// original header when compiling with a C++03 compiler.  If there are no
// specially delimited regions of C++11 code, then this header contains no
// code and is not '#include'd in the original header.
//
// Generated on Tue Apr 27 13:41:48 2021
// Command line: sim_cpp11_features.pl bslmf_invokeresult.h

#ifdef COMPILING_BSLMF_INVOKERESULT_H

namespace BloombergLP {
namespace bslmf {

                 // ==========================================
                 // class template InvokeResultDeductionFailed
                 // ==========================================

struct InvokeResultDeductionFailed {
    // When 'invoke_result' cannot deduce the actual return type of a functor
    // (in C++03 mode), it yields this type as a placeholder.  The advantage of
    // using this placeholder instead of a compilation failure (e.g., using a
    // static assert) is that the return type of an INVOKE() operation is
    // often discarded, so our failure to deduce the return type is often
    // harmless.  Since 'InvokeResultDeductionFailed' is a return type, it must
    // be convertible from the actual return type; this conversion is
    // accomplished by means of a constructor that makes it convertible from
    // *any* type.

    // CREATORS
    template <class TYPE>
    InvokeResultDeductionFailed(const TYPE&) { }
        // Convert from an arbitrary type.  The actual argument value is
        // discarded.
};

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslmf_invokeresult.h
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT 13
#endif
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT_A
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT_A BSLMF_INVOKERESULT_VARIADIC_LIMIT
#endif

template <class FN
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 0
        , class ARGTYPES_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 1
        , class ARGTYPES_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 2
        , class ARGTYPES_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 3
        , class ARGTYPES_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 4
        , class ARGTYPES_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 5
        , class ARGTYPES_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 6
        , class ARGTYPES_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 7
        , class ARGTYPES_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 8
        , class ARGTYPES_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 9
        , class ARGTYPES_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 10
        , class ARGTYPES_10 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 11
        , class ARGTYPES_11 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 12
        , class ARGTYPES_12 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_A >= 12
        , class = BSLS_COMPILERFEATURES_NILT>
struct InvokeResult_BaseCalcUtil;

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.

template <class FN, class... ARGTYPES>
struct InvokeResult_BaseCalcUtil;

// }}} END GENERATED CODE
#endif

}  // close package namespace
}  // close enterprise namespace

                        // ============================
                        // class template invoke_result
                        // ============================

namespace bsl {

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslmf_invokeresult.h
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT 13
#endif
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT_B
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT_B BSLMF_INVOKERESULT_VARIADIC_LIMIT
#endif

template <class FN
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 0
        , class ARGTYPES_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 1
        , class ARGTYPES_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 2
        , class ARGTYPES_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 3
        , class ARGTYPES_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 4
        , class ARGTYPES_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 5
        , class ARGTYPES_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 6
        , class ARGTYPES_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 7
        , class ARGTYPES_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 8
        , class ARGTYPES_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 9
        , class ARGTYPES_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 10
        , class ARGTYPES_10 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 11
        , class ARGTYPES_11 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 12
        , class ARGTYPES_12 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 12
        , class = BSLS_COMPILERFEATURES_NILT>
class invoke_result;

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 0
template <class FN>
class invoke_result<FN>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<FN>::BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 1
template <class FN, class ARGTYPES_01>
class invoke_result<FN, ARGTYPES_01>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<FN,
                                                       ARGTYPES_01>::BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 2
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02>
class invoke_result<FN, ARGTYPES_01,
                        ARGTYPES_02>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<FN,
                                                       ARGTYPES_01,
                                                       ARGTYPES_02>::BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 3
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03>
class invoke_result<FN, ARGTYPES_01,
                        ARGTYPES_02,
                        ARGTYPES_03>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<FN,
                                                       ARGTYPES_01,
                                                       ARGTYPES_02,
                                                       ARGTYPES_03>::BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 4
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04>
class invoke_result<FN, ARGTYPES_01,
                        ARGTYPES_02,
                        ARGTYPES_03,
                        ARGTYPES_04>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<FN,
                                                       ARGTYPES_01,
                                                       ARGTYPES_02,
                                                       ARGTYPES_03,
                                                       ARGTYPES_04>::BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 5
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05>
class invoke_result<FN, ARGTYPES_01,
                        ARGTYPES_02,
                        ARGTYPES_03,
                        ARGTYPES_04,
                        ARGTYPES_05>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<FN,
                                                       ARGTYPES_01,
                                                       ARGTYPES_02,
                                                       ARGTYPES_03,
                                                       ARGTYPES_04,
                                                       ARGTYPES_05>::BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 6
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06>
class invoke_result<FN, ARGTYPES_01,
                        ARGTYPES_02,
                        ARGTYPES_03,
                        ARGTYPES_04,
                        ARGTYPES_05,
                        ARGTYPES_06>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<FN,
                                                       ARGTYPES_01,
                                                       ARGTYPES_02,
                                                       ARGTYPES_03,
                                                       ARGTYPES_04,
                                                       ARGTYPES_05,
                                                       ARGTYPES_06>::BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 7
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07>
class invoke_result<FN, ARGTYPES_01,
                        ARGTYPES_02,
                        ARGTYPES_03,
                        ARGTYPES_04,
                        ARGTYPES_05,
                        ARGTYPES_06,
                        ARGTYPES_07>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<FN,
                                                       ARGTYPES_01,
                                                       ARGTYPES_02,
                                                       ARGTYPES_03,
                                                       ARGTYPES_04,
                                                       ARGTYPES_05,
                                                       ARGTYPES_06,
                                                       ARGTYPES_07>::BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 8
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08>
class invoke_result<FN, ARGTYPES_01,
                        ARGTYPES_02,
                        ARGTYPES_03,
                        ARGTYPES_04,
                        ARGTYPES_05,
                        ARGTYPES_06,
                        ARGTYPES_07,
                        ARGTYPES_08>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<FN,
                                                       ARGTYPES_01,
                                                       ARGTYPES_02,
                                                       ARGTYPES_03,
                                                       ARGTYPES_04,
                                                       ARGTYPES_05,
                                                       ARGTYPES_06,
                                                       ARGTYPES_07,
                                                       ARGTYPES_08>::BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 9
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09>
class invoke_result<FN, ARGTYPES_01,
                        ARGTYPES_02,
                        ARGTYPES_03,
                        ARGTYPES_04,
                        ARGTYPES_05,
                        ARGTYPES_06,
                        ARGTYPES_07,
                        ARGTYPES_08,
                        ARGTYPES_09>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<FN,
                                                       ARGTYPES_01,
                                                       ARGTYPES_02,
                                                       ARGTYPES_03,
                                                       ARGTYPES_04,
                                                       ARGTYPES_05,
                                                       ARGTYPES_06,
                                                       ARGTYPES_07,
                                                       ARGTYPES_08,
                                                       ARGTYPES_09>::BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 10
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10>
class invoke_result<FN, ARGTYPES_01,
                        ARGTYPES_02,
                        ARGTYPES_03,
                        ARGTYPES_04,
                        ARGTYPES_05,
                        ARGTYPES_06,
                        ARGTYPES_07,
                        ARGTYPES_08,
                        ARGTYPES_09,
                        ARGTYPES_10>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<FN,
                                                       ARGTYPES_01,
                                                       ARGTYPES_02,
                                                       ARGTYPES_03,
                                                       ARGTYPES_04,
                                                       ARGTYPES_05,
                                                       ARGTYPES_06,
                                                       ARGTYPES_07,
                                                       ARGTYPES_08,
                                                       ARGTYPES_09,
                                                       ARGTYPES_10>::BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 11
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11>
class invoke_result<FN, ARGTYPES_01,
                        ARGTYPES_02,
                        ARGTYPES_03,
                        ARGTYPES_04,
                        ARGTYPES_05,
                        ARGTYPES_06,
                        ARGTYPES_07,
                        ARGTYPES_08,
                        ARGTYPES_09,
                        ARGTYPES_10,
                        ARGTYPES_11>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<FN,
                                                       ARGTYPES_01,
                                                       ARGTYPES_02,
                                                       ARGTYPES_03,
                                                       ARGTYPES_04,
                                                       ARGTYPES_05,
                                                       ARGTYPES_06,
                                                       ARGTYPES_07,
                                                       ARGTYPES_08,
                                                       ARGTYPES_09,
                                                       ARGTYPES_10,
                                                       ARGTYPES_11>::BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 12
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11,
                    class ARGTYPES_12>
class invoke_result<FN, ARGTYPES_01,
                        ARGTYPES_02,
                        ARGTYPES_03,
                        ARGTYPES_04,
                        ARGTYPES_05,
                        ARGTYPES_06,
                        ARGTYPES_07,
                        ARGTYPES_08,
                        ARGTYPES_09,
                        ARGTYPES_10,
                        ARGTYPES_11,
                        ARGTYPES_12>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<FN,
                                                       ARGTYPES_01,
                                                       ARGTYPES_02,
                                                       ARGTYPES_03,
                                                       ARGTYPES_04,
                                                       ARGTYPES_05,
                                                       ARGTYPES_06,
                                                       ARGTYPES_07,
                                                       ARGTYPES_08,
                                                       ARGTYPES_09,
                                                       ARGTYPES_10,
                                                       ARGTYPES_11,
                                                       ARGTYPES_12>::BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 13
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11,
                    class ARGTYPES_12,
                    class ARGTYPES_13>
class invoke_result<FN, ARGTYPES_01,
                        ARGTYPES_02,
                        ARGTYPES_03,
                        ARGTYPES_04,
                        ARGTYPES_05,
                        ARGTYPES_06,
                        ARGTYPES_07,
                        ARGTYPES_08,
                        ARGTYPES_09,
                        ARGTYPES_10,
                        ARGTYPES_11,
                        ARGTYPES_12,
                        ARGTYPES_13>
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<FN,
                                                       ARGTYPES_01,
                                                       ARGTYPES_02,
                                                       ARGTYPES_03,
                                                       ARGTYPES_04,
                                                       ARGTYPES_05,
                                                       ARGTYPES_06,
                                                       ARGTYPES_07,
                                                       ARGTYPES_08,
                                                       ARGTYPES_09,
                                                       ARGTYPES_10,
                                                       ARGTYPES_11,
                                                       ARGTYPES_12,
                                                       ARGTYPES_13>::BaseType {

};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_B >= 13

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.

template <class FN, class... ARGTYPES>
class invoke_result
: public BloombergLP::bslmf::InvokeResult_BaseCalcUtil<FN,
                                                       ARGTYPES...>::BaseType {

};

// }}} END GENERATED CODE
#endif

}  // close namespace bsl

// ============================================================================
//                              TEMPLATE IMPLEMENTATIONS
// ============================================================================

namespace BloombergLP {
namespace bslmf {

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslmf_invokeresult.h
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT 13
#endif
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT_C
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT_C BSLMF_INVOKERESULT_VARIADIC_LIMIT
#endif

template <bool IS_FUNCPTR,
          bool IS_MEMFUNCPTR,
          bool IS_MEMOBJPTR,
          class FN
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 0
        , class ARGTYPES_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 1
        , class ARGTYPES_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 2
        , class ARGTYPES_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 3
        , class ARGTYPES_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 4
        , class ARGTYPES_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 5
        , class ARGTYPES_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 6
        , class ARGTYPES_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 7
        , class ARGTYPES_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 8
        , class ARGTYPES_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 9
        , class ARGTYPES_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 10
        , class ARGTYPES_10 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 11
        , class ARGTYPES_11 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 12
        , class ARGTYPES_12 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 12
        , class = BSLS_COMPILERFEATURES_NILT>
struct InvokeResult_Imp;



#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 0
template <class FN>
struct InvokeResult_BaseCalcUtil<FN> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename
    bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR || k_IS_MEMOBJPTR,
                     F, FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 1
template <class FN, class ARGTYPES_01>
struct InvokeResult_BaseCalcUtil<FN, ARGTYPES_01> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename
    bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR || k_IS_MEMOBJPTR,
                     F, FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          ARGTYPES_01>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 2
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02>
struct InvokeResult_BaseCalcUtil<FN, ARGTYPES_01,
                                     ARGTYPES_02> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename
    bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR || k_IS_MEMOBJPTR,
                     F, FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          ARGTYPES_01,
                                                          ARGTYPES_02>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 3
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03>
struct InvokeResult_BaseCalcUtil<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename
    bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR || k_IS_MEMOBJPTR,
                     F, FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          ARGTYPES_01,
                                                          ARGTYPES_02,
                                                          ARGTYPES_03>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 4
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04>
struct InvokeResult_BaseCalcUtil<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename
    bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR || k_IS_MEMOBJPTR,
                     F, FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          ARGTYPES_01,
                                                          ARGTYPES_02,
                                                          ARGTYPES_03,
                                                          ARGTYPES_04>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 5
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05>
struct InvokeResult_BaseCalcUtil<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename
    bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR || k_IS_MEMOBJPTR,
                     F, FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          ARGTYPES_01,
                                                          ARGTYPES_02,
                                                          ARGTYPES_03,
                                                          ARGTYPES_04,
                                                          ARGTYPES_05>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 6
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06>
struct InvokeResult_BaseCalcUtil<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename
    bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR || k_IS_MEMOBJPTR,
                     F, FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          ARGTYPES_01,
                                                          ARGTYPES_02,
                                                          ARGTYPES_03,
                                                          ARGTYPES_04,
                                                          ARGTYPES_05,
                                                          ARGTYPES_06>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 7
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07>
struct InvokeResult_BaseCalcUtil<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename
    bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR || k_IS_MEMOBJPTR,
                     F, FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          ARGTYPES_01,
                                                          ARGTYPES_02,
                                                          ARGTYPES_03,
                                                          ARGTYPES_04,
                                                          ARGTYPES_05,
                                                          ARGTYPES_06,
                                                          ARGTYPES_07>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 8
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08>
struct InvokeResult_BaseCalcUtil<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename
    bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR || k_IS_MEMOBJPTR,
                     F, FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          ARGTYPES_01,
                                                          ARGTYPES_02,
                                                          ARGTYPES_03,
                                                          ARGTYPES_04,
                                                          ARGTYPES_05,
                                                          ARGTYPES_06,
                                                          ARGTYPES_07,
                                                          ARGTYPES_08>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 9
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09>
struct InvokeResult_BaseCalcUtil<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08,
                                     ARGTYPES_09> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename
    bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR || k_IS_MEMOBJPTR,
                     F, FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          ARGTYPES_01,
                                                          ARGTYPES_02,
                                                          ARGTYPES_03,
                                                          ARGTYPES_04,
                                                          ARGTYPES_05,
                                                          ARGTYPES_06,
                                                          ARGTYPES_07,
                                                          ARGTYPES_08,
                                                          ARGTYPES_09>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 10
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10>
struct InvokeResult_BaseCalcUtil<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08,
                                     ARGTYPES_09,
                                     ARGTYPES_10> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename
    bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR || k_IS_MEMOBJPTR,
                     F, FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          ARGTYPES_01,
                                                          ARGTYPES_02,
                                                          ARGTYPES_03,
                                                          ARGTYPES_04,
                                                          ARGTYPES_05,
                                                          ARGTYPES_06,
                                                          ARGTYPES_07,
                                                          ARGTYPES_08,
                                                          ARGTYPES_09,
                                                          ARGTYPES_10>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 11
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11>
struct InvokeResult_BaseCalcUtil<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08,
                                     ARGTYPES_09,
                                     ARGTYPES_10,
                                     ARGTYPES_11> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename
    bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR || k_IS_MEMOBJPTR,
                     F, FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          ARGTYPES_01,
                                                          ARGTYPES_02,
                                                          ARGTYPES_03,
                                                          ARGTYPES_04,
                                                          ARGTYPES_05,
                                                          ARGTYPES_06,
                                                          ARGTYPES_07,
                                                          ARGTYPES_08,
                                                          ARGTYPES_09,
                                                          ARGTYPES_10,
                                                          ARGTYPES_11>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 12
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11,
                    class ARGTYPES_12>
struct InvokeResult_BaseCalcUtil<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08,
                                     ARGTYPES_09,
                                     ARGTYPES_10,
                                     ARGTYPES_11,
                                     ARGTYPES_12> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename
    bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR || k_IS_MEMOBJPTR,
                     F, FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          ARGTYPES_01,
                                                          ARGTYPES_02,
                                                          ARGTYPES_03,
                                                          ARGTYPES_04,
                                                          ARGTYPES_05,
                                                          ARGTYPES_06,
                                                          ARGTYPES_07,
                                                          ARGTYPES_08,
                                                          ARGTYPES_09,
                                                          ARGTYPES_10,
                                                          ARGTYPES_11,
                                                          ARGTYPES_12>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 13
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11,
                    class ARGTYPES_12,
                    class ARGTYPES_13>
struct InvokeResult_BaseCalcUtil<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08,
                                     ARGTYPES_09,
                                     ARGTYPES_10,
                                     ARGTYPES_11,
                                     ARGTYPES_12,
                                     ARGTYPES_13> {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename
    bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR || k_IS_MEMOBJPTR,
                     F, FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          ARGTYPES_01,
                                                          ARGTYPES_02,
                                                          ARGTYPES_03,
                                                          ARGTYPES_04,
                                                          ARGTYPES_05,
                                                          ARGTYPES_06,
                                                          ARGTYPES_07,
                                                          ARGTYPES_08,
                                                          ARGTYPES_09,
                                                          ARGTYPES_10,
                                                          ARGTYPES_11,
                                                          ARGTYPES_12,
                                                          ARGTYPES_13>
        BaseType;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_C >= 13

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.

template <bool  IS_FUNCPTR,
          bool  IS_MEMFUNCPTR,
          bool  IS_MEMOBJPTR,
          class FN,
          class... ARGTYPES>
struct InvokeResult_Imp;


template <class FN, class... ARGTYPES>
struct InvokeResult_BaseCalcUtil {

  private:
    typedef typename bslmf::MovableRefUtil::Decay<FN>::type F;

    enum {
        k_IS_FUNCPTR   = BloombergLP::bslmf::IsFunctionPointer<F>::value,
        k_IS_MEMFUNCPTR= BloombergLP::bslmf::IsMemberFunctionPointer<F>::value,
        k_IS_MEMOBJPTR = bsl::is_member_object_pointer<F>::value
    };

    typedef typename
    bsl::conditional<k_IS_FUNCPTR || k_IS_MEMFUNCPTR || k_IS_MEMOBJPTR,
                     F, FN>::type FwdFn;

  public:
    typedef typename BloombergLP::bslmf::InvokeResult_Imp<k_IS_FUNCPTR,
                                                          k_IS_MEMFUNCPTR,
                                                          k_IS_MEMOBJPTR,
                                                          FwdFn,
                                                          ARGTYPES...>
        BaseType;
};

// }}} END GENERATED CODE
#endif

                        // ============================
                        // struct InvokeResult_IsBaseOf
                        // ============================

template <class BASE, class DERIVED>
struct InvokeResult_IsBaseOf
: bsl::integral_constant<
    bool,
    bsl::is_class<typename bsl::remove_cv<BASE>::type>::value
 && bsl::is_class<typename bsl::remove_cv<DERIVED>::type>::value
 && bsl::is_convertible<typename bsl::remove_cv<DERIVED>::type *,
                        typename bsl::remove_cv<BASE>::type *>::value> {
    // This component-private 'struct' template provides an implementation
    // of the 'std::is_base_of' type trait that may be used when a C++11
    // baseline library is not necessarily available.
};

               // =============================================
               // struct InvokeResult_MemberObjectPointerTraits
               // =============================================

template <class TYPE>
struct InvokeResult_MemberObjectPointerTraits;
    // This component-private utility 'struct' template provides the following
    // nested typedefs:
    //: 'ClassType': The type of the class for which the specified 'TYPE' is a
    //:              pointer to member object.
    //: 'MemberType': The type of the member object of the class for which the
    //:               specified 'TYPE' is a pointer to member object.
    // Instantiation will fail unless 'TYPE' is a pointer-to-member-object
    // type.  This primary (unspecialized) template is not defined.

template <class MEMBER_TYPE, class CLASS_TYPE>
struct InvokeResult_MemberObjectPointerTraits<MEMBER_TYPE CLASS_TYPE::*> {
    // TYPES
    typedef CLASS_TYPE ClassType;
        // 'ClassType' is an alias to the type of the class for which the
        // specified 'TYPE' is a pointer to member object.

    typedef MEMBER_TYPE MemberType;
        // 'MemberType' is an alias to the type of the member object of the
        // class for which the specified 'TYPE' is a pointer to member object.
};

                      // ===============================
                      // struct InvokeResult_VoidChecker
                      // ===============================

struct InvokeResult_VoidChecker : Tag<true> {
    // Empty type used to detect void expressions.  The size of this type is
    // the same as 'bslmf::Tag<1>'.
};

template <class TYPE>
typename bsl::enable_if<!bsl::is_void<TYPE>::value, Tag<false> >::type
operator,(const TYPE&, InvokeResult_VoidChecker);
    // Return 'InvokeResult_VoidChecker()' if the left argument is of type
    // cv-'void'; otherwise 'bslmf::Tag<false>()'.  This overload of the comma
    // operator is declared but not defined, and is intended to be used in
    // metafunctions in an unevaluated context to detect void expressions.
    // For any non-void expression 'expr', '(expr,InvokeResult_VoidChecker())',
    // will match this overload and produce a result of type
    // 'bslmf::Tag<false>'.  However, 'const TYPE&' will not match 'void', so
    // if 'expr' is a void expression, the built-in comma operator is matched
    // and the result will have type 'InvokeResult_VoidChecker' (i.e., the
    // second argument).
    //
    // Note that Sun CC incorrectly matches this overload for a void
    // expression, then fails hard.  The 'enable_if' prevents this match for
    // Sun CC and any other compilers that may similarly match 'void' and is
    // harmless for compilers that don't.

struct InvokeResult_Index {
    // Metafunction helpers for deducing the return type of an expression.

    enum {
        // Enumeration of possible return types.

        e_VOID,
        e_BOOL,
        e_CHAR,
        e_SCHAR,
        e_UCHAR,
        e_WCHAR_T,
        e_CHAR16_T,
        e_CHAR32_T,
        e_SHORT,
        e_USHORT,
        e_INT,
        e_UNSIGNED,
        e_LONG,
        e_ULONG,
        e_LONG_LONG,
        e_ULONG_LONG,
        e_FLOAT,
        e_DOUBLE,
        e_LONG_DOUBLE,

        // Pointer to void is special among pointers because it cannot be
        // dereferenced.
        e_VOIDPTR,
        e_CONST_VOIDPTR,
        e_VOLATILE_VOIDPTR,
        e_CONST_VOLATILE_VOIDPTR,

        e_NULLPTR_T,
        e_POINTER, // Any pointer type other than 'void *' or 'nullptr_t'
        e_OTHER    // Anything other than above
    };

    // CLASS METHODS
    static bslmf::Tag<e_BOOL>                   fromVal(bool&                );
    static bslmf::Tag<e_CHAR>                   fromVal(char&                );
    static bslmf::Tag<e_SCHAR>                  fromVal(signed char&         );
    static bslmf::Tag<e_UCHAR>                  fromVal(unsigned char&       );
    static bslmf::Tag<e_WCHAR_T>                fromVal(wchar_t&             );
#ifdef BSLS_COMPILERFEATURES_SUPPORT_UNICODE_CHAR_TYPES
    static bslmf::Tag<e_CHAR16_T>               fromVal(char16_t&            );
    static bslmf::Tag<e_CHAR32_T>               fromVal(char32_t&            );
#endif
    static bslmf::Tag<e_SHORT>                  fromVal(short&               );
    static bslmf::Tag<e_USHORT>                 fromVal(unsigned short&      );
    static bslmf::Tag<e_INT>                    fromVal(int&                 );
    static bslmf::Tag<e_UNSIGNED>               fromVal(unsigned&            );
    static bslmf::Tag<e_LONG>                   fromVal(long&                );
    static bslmf::Tag<e_ULONG>                  fromVal(unsigned long&       );
    static bslmf::Tag<e_LONG_LONG>              fromVal(long long&           );
    static bslmf::Tag<e_ULONG_LONG>             fromVal(unsigned long long&  );
    static bslmf::Tag<e_FLOAT>                  fromVal(float&               );
    static bslmf::Tag<e_DOUBLE>                 fromVal(double&              );
    static bslmf::Tag<e_LONG_DOUBLE>            fromVal(long double&         );
    static bslmf::Tag<e_VOIDPTR>                fromVal(void *&              );
    static bslmf::Tag<e_CONST_VOIDPTR>          fromVal(const void *&        );
    static bslmf::Tag<e_VOLATILE_VOIDPTR>       fromVal(volatile void *&     );
    static bslmf::Tag<e_CONST_VOLATILE_VOIDPTR> fromVal(const volatile void*&);
    static bslmf::Tag<e_NULLPTR_T>              fromVal(bsl::nullptr_t&      );
    template <class TP>
    static bslmf::Tag<e_POINTER>                fromVal(TP *&                );
    template <class TP>
    static bslmf::Tag<e_OTHER>                  fromVal(TP&                  );
        // Return a tag type representing the argument type.  These functions
        // are declared but not defined and are intended to be used in an
        // unevaluated context (e.g., within 'sizeof') to convert an expression
        // into a compile-time enumeration constant.
};

template <int INDEX> struct InvokeResult_Type;
    // Metafunction to convert a type index back to a type.  For each
    // specialization of this struct, the 'type' member will be the type
    // corresponding to 'index'.  For example, if 'index' is 'e_UCHAR', then
    // 'InvokeResult_Type<index>::type' is 'unsigned char'.

// Turn off bde_verify warnings for "Declaration without tag".  Pedantically,
// every 'type' declared in a metafunction should have the tag '// TYPES', but
// that breaks up the clean 3-line declaration of each specialization, making
// the pattern harder to for the eye to follow.
// BDE_VERIFY pragma: push
// BDE_VERIFY pragma: -KS00
template <>
struct InvokeResult_Type<InvokeResult_Index::e_VOID>
    { typedef void               type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_BOOL>
    { typedef bool               type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_CHAR>
    { typedef char               type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_SCHAR>
    { typedef signed char        type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_UCHAR>
    { typedef unsigned char      type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_WCHAR_T>
    { typedef wchar_t            type; };
#ifdef BSLS_COMPILERFEATURES_SUPPORT_UNICODE_CHAR_TYPES
template <>
struct InvokeResult_Type<InvokeResult_Index::e_CHAR16_T>
    { typedef char16_t           type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_CHAR32_T>
    { typedef char32_t           type; };
#endif
template <>
struct InvokeResult_Type<InvokeResult_Index::e_SHORT>
    { typedef short              type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_USHORT>
    { typedef unsigned short     type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_INT>
    { typedef int                type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_UNSIGNED>
    { typedef unsigned           type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_LONG>
    { typedef long               type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_ULONG>
    { typedef unsigned long      type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_LONG_LONG>
    { typedef long long          type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_ULONG_LONG>
    { typedef unsigned long long type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_FLOAT>
    { typedef float              type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_DOUBLE>
    { typedef double             type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_LONG_DOUBLE>
    { typedef long double        type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_VOIDPTR>
    { typedef void              *type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_CONST_VOIDPTR>
    { typedef const void        *type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_VOLATILE_VOIDPTR>
    { typedef volatile void     *type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_CONST_VOLATILE_VOIDPTR>
    { typedef const volatile void *type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_NULLPTR_T>
    { typedef bsl::nullptr_t     type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_POINTER>
    { typedef void              *type; };
template <>
struct InvokeResult_Type<InvokeResult_Index::e_OTHER>
    { typedef InvokeResultDeductionFailed type; };
// Re-enable warnings for "Declaration without tag"
// BDE_VERIFY pragma: pop

struct InvokeResult_ImpUtils
{
    // Utility metaprogramming functions inherited by other metaprogramming
    // classes.

    // TYPES
    struct AnyLvalue {
        // Type convertible from any lvalue type.  Used for overload resolution
        // in metafunctions.

        // CREATORS
        template <class TP>
        AnyLvalue(volatile TP&);
            // (Declared but not defined) Convert from any lvalue argument.
    };

    struct AnyRvalue {
        // Type convertible from any rvalue type.  Used for overload resolution
        // in metafunctions.

        // CREATORS
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
        template <class TP>
        AnyRvalue(TP&&,
                  typename bsl::enable_if<bsl::is_rvalue_reference<TP&&>::value
                                         , int>::type = 0);
            // (Declared but not defined) Convert from any rvalue argument.
#else
        template <class TP>
        AnyRvalue(TP);
            // (Declared but not defined) Convert from any rvalue argument.
            // This constructor will also match lvalue arguments, but is used
            // in a context where 'AnyLValue' is a better conversion path.
#endif
    };

    // CLASS METHODS
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    template <class SOME_TYPE>
    static typename bsl::add_rvalue_reference<SOME_TYPE>::type myDeclval();
        // Return a reference to the specified 'SOME_TYPE' template parameter
        // type; if 'SOME_TYPE' is an rvalue, then the returned reference is
        // an rvalue reference.  This function is declared but not defined and
        // is intended to be called in an unevaluated context.  Because there
        // is no definition, the available constructors for 'SOME_TYPE' are
        // irrelevant.
#else
    template <class SOME_TYPE>
    static SOME_TYPE myDeclval();
        // Return an object of the specified 'SOME_TYPE' template parameter
        // type.  This function is declared but not defined and is intended to
        // be called in an unevaluated context.  Because there is no
        // definition, the available constructors for 'SOME_TYPE' are
        // irrelevant.
#endif

    static bslmf::Tag<false>    checkLvalue(AnyRvalue, ...);
    static bslmf::Tag<true >    checkLvalue(AnyLvalue, int);
        // (Declared but not defined) Return 'bslmf::Tag<false>()' if the
        // first argument is an rvalue and 'bslmf::Tag<true>()' if it is
        // lvalue.  In actual use, the second argument is always a literal
        // 'int', which causes the second overload to be preferred in case of
        // ambiguity.

    template <class TP>
    static bslmf::Tag<false> checkConst(TP&);
    template <class TP>
    static bslmf::Tag<true > checkConst(const TP&);
        // (Declared but not defined) Return 'bslmf::Tag<true>()' if the
        // argument is 'const'-qualified and 'bslmf::Tag<false>()' otherwise.

    template <class TP>
    static bslmf::Tag<false> checkVolatile(TP&);
    template <class TP>
    static bslmf::Tag<false> checkVolatile(const TP&);
    template <class TP>
    static bslmf::Tag<true > checkVolatile(volatile TP&);
    template <class TP>
    static bslmf::Tag<true > checkVolatile(const volatile TP&);
        // (Declared but not defined) Return 'bslmf::Tag<true>()' if the
        // argument is 'volatile'-qualified and 'bslmf::Tag<false>()'
        // otherwise.  Note that if 'TP' is both const- and
        // volatile-qualified, it will not match 'volatile TP&', hence the
        // need for the const overloads.

    template <class TP>
    static TP& uncv(const TP&);
    template <class TP>
    static TP& uncv(const volatile TP&);
        // (Declared but not defined) Return the argument, with cv-qualifiers
        // removed.

    template <class TP>
    static TP& unpoint(TP&);
    template <class TP>
    static const TP& unpoint(const TP&);
    template <class TP>
    static typename bsl::enable_if<!bsl::is_void<TP>::value, TP>::type&
    unpoint(TP *&);
    template <class TP>
    static typename bsl::enable_if<!bsl::is_void<TP>::value, TP>::type&
    unpoint(TP *const&);
    template <class TP>
    static typename bsl::enable_if<!bsl::is_void<TP>::value, TP>::type&
    unpoint(TP *volatile&);
    template <class TP>
    static typename bsl::enable_if<!bsl::is_void<TP>::value, TP>::type&
    unpoint(TP *const volatile&);
        // If the argument type 'TP' is pointer to type 'X', where 'X' is not
        // cv-'void', return a reference to 'X'; otherwise return a reference
        // to 'TP'.  Note that these functions are declared but not defined and
        // are intended to be called only in an unevaluated context.
};


template <class UNQUAL_TYPE, bool IS_CONST, bool IS_VOLATILE, bool IS_LVALUE>
struct InvokeResult_AddCVRef {
    // Starting with type, 'UNQUAL_TYPE', generate a new type by applying the
    // following steps in order:
    //
    //: 1 If the specified 'IS_CONST' parameter is true, apply
    //:   'bsl::add_const'; otherwise leave unchanged.
    //: 2 If the specified 'IS_VOLATILE' parameter is true, apply
    //:   'bsl::add_volatile'; otherwise leave unchanged.
    //: 3 If the specified 'IS_LVALUE' parameter is true, apply
    //:   'bsl::add_lvalue_reference'; otherwise leave unchanged.
    //
    // Set the 'type' member to the resulting type.

  private:
    // PRIVATE TYPES
    typedef typename
    bsl::conditional<IS_CONST,
                     typename bsl::add_const<UNQUAL_TYPE>::type,
                     UNQUAL_TYPE>::type CQualType;

    typedef typename
    bsl::conditional<IS_VOLATILE,
                     typename bsl::add_volatile<CQualType>::type,
                     CQualType>::type CVQualType;

  public:
    // TYPES
    typedef typename
    bsl::conditional<IS_LVALUE,
                     typename bsl::add_lvalue_reference<CVQualType>::type,
                     CVQualType>::type type;
};

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslmf_invokeresult.h
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT 13
#endif
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT_D
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT_D BSLMF_INVOKERESULT_VARIADIC_LIMIT
#endif

#ifndef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
template <bool __Param__0,
          class FN
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 0
        , class ARGTYPES_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 1
        , class ARGTYPES_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 2
        , class ARGTYPES_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 3
        , class ARGTYPES_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 4
        , class ARGTYPES_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 5
        , class ARGTYPES_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 6
        , class ARGTYPES_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 7
        , class ARGTYPES_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 8
        , class ARGTYPES_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 9
        , class ARGTYPES_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 10
        , class ARGTYPES_10 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 11
        , class ARGTYPES_11 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 12
        , class ARGTYPES_12 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 12
        , class = BSLS_COMPILERFEATURES_NILT>
struct InvokeResult_FunctorDeduction;

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 0
template <bool __Param__0, class FN>
struct InvokeResult_FunctorDeduction<__Param__0, FN> : InvokeResult_ImpUtils {

    typedef typename bsl::decay<FN>::type F;

    enum {

        k_INDEX       = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                           uncv(myDeclval<FN>()()))),
        k_IS_POINTER  = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE   = BSLMF_TAG_TO_INT(checkLvalue(
                                myDeclval<FN>()(), 0)),
        k_IS_CONST_PTR = k_IS_POINTER && BSLMF_TAG_TO_INT(checkConst(
                                myDeclval<FN>()())),
        k_IS_VOLATILE_PTR  = k_IS_POINTER && BSLMF_TAG_TO_INT(checkVolatile(
                                myDeclval<FN>()())),
        k_TARGET_INDEX   = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                   uncv(unpoint(myDeclval<FN>()())))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                        unpoint(myDeclval<FN>()()))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                        unpoint(myDeclval<FN>()()))),
        k_CANT_DEDUCE_TYPE = (k_TARGET_INDEX==(int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 1
template <bool __Param__0, class FN, class ARGTYPES_01>
struct InvokeResult_FunctorDeduction<__Param__0, FN, ARGTYPES_01
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<FN>::type F;

    enum {

        k_INDEX       = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                           uncv(myDeclval<FN>()(myDeclval<ARGTYPES_01>())))),
        k_IS_POINTER  = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE   = BSLMF_TAG_TO_INT(checkLvalue(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER && BSLMF_TAG_TO_INT(checkConst(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>()))),
        k_IS_VOLATILE_PTR  = k_IS_POINTER && BSLMF_TAG_TO_INT(checkVolatile(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>()))),
        k_TARGET_INDEX   = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                   uncv(unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>())))),
        k_CANT_DEDUCE_TYPE = (k_TARGET_INDEX==(int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 2
template <bool __Param__0, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02>
struct InvokeResult_FunctorDeduction<__Param__0, FN, ARGTYPES_01,
                                                     ARGTYPES_02
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<FN>::type F;

    enum {

        k_INDEX       = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                           uncv(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>())))),
        k_IS_POINTER  = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE   = BSLMF_TAG_TO_INT(checkLvalue(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER && BSLMF_TAG_TO_INT(checkConst(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>()))),
        k_IS_VOLATILE_PTR  = k_IS_POINTER && BSLMF_TAG_TO_INT(checkVolatile(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>()))),
        k_TARGET_INDEX   = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                   uncv(unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>())))),
        k_CANT_DEDUCE_TYPE = (k_TARGET_INDEX==(int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 3
template <bool __Param__0, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03>
struct InvokeResult_FunctorDeduction<__Param__0, FN, ARGTYPES_01,
                                                     ARGTYPES_02,
                                                     ARGTYPES_03
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<FN>::type F;

    enum {

        k_INDEX       = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                           uncv(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>())))),
        k_IS_POINTER  = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE   = BSLMF_TAG_TO_INT(checkLvalue(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER && BSLMF_TAG_TO_INT(checkConst(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>()))),
        k_IS_VOLATILE_PTR  = k_IS_POINTER && BSLMF_TAG_TO_INT(checkVolatile(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>()))),
        k_TARGET_INDEX   = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                   uncv(unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>())))),
        k_CANT_DEDUCE_TYPE = (k_TARGET_INDEX==(int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 4
template <bool __Param__0, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04>
struct InvokeResult_FunctorDeduction<__Param__0, FN, ARGTYPES_01,
                                                     ARGTYPES_02,
                                                     ARGTYPES_03,
                                                     ARGTYPES_04
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<FN>::type F;

    enum {

        k_INDEX       = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                           uncv(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>())))),
        k_IS_POINTER  = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE   = BSLMF_TAG_TO_INT(checkLvalue(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER && BSLMF_TAG_TO_INT(checkConst(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>()))),
        k_IS_VOLATILE_PTR  = k_IS_POINTER && BSLMF_TAG_TO_INT(checkVolatile(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>()))),
        k_TARGET_INDEX   = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                   uncv(unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>())))),
        k_CANT_DEDUCE_TYPE = (k_TARGET_INDEX==(int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 5
template <bool __Param__0, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05>
struct InvokeResult_FunctorDeduction<__Param__0, FN, ARGTYPES_01,
                                                     ARGTYPES_02,
                                                     ARGTYPES_03,
                                                     ARGTYPES_04,
                                                     ARGTYPES_05
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<FN>::type F;

    enum {

        k_INDEX       = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                           uncv(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>())))),
        k_IS_POINTER  = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE   = BSLMF_TAG_TO_INT(checkLvalue(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER && BSLMF_TAG_TO_INT(checkConst(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>()))),
        k_IS_VOLATILE_PTR  = k_IS_POINTER && BSLMF_TAG_TO_INT(checkVolatile(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>()))),
        k_TARGET_INDEX   = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                   uncv(unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>())))),
        k_CANT_DEDUCE_TYPE = (k_TARGET_INDEX==(int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 6
template <bool __Param__0, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06>
struct InvokeResult_FunctorDeduction<__Param__0, FN, ARGTYPES_01,
                                                     ARGTYPES_02,
                                                     ARGTYPES_03,
                                                     ARGTYPES_04,
                                                     ARGTYPES_05,
                                                     ARGTYPES_06
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<FN>::type F;

    enum {

        k_INDEX       = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                           uncv(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>())))),
        k_IS_POINTER  = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE   = BSLMF_TAG_TO_INT(checkLvalue(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER && BSLMF_TAG_TO_INT(checkConst(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>()))),
        k_IS_VOLATILE_PTR  = k_IS_POINTER && BSLMF_TAG_TO_INT(checkVolatile(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>()))),
        k_TARGET_INDEX   = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                   uncv(unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>())))),
        k_CANT_DEDUCE_TYPE = (k_TARGET_INDEX==(int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 7
template <bool __Param__0, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07>
struct InvokeResult_FunctorDeduction<__Param__0, FN, ARGTYPES_01,
                                                     ARGTYPES_02,
                                                     ARGTYPES_03,
                                                     ARGTYPES_04,
                                                     ARGTYPES_05,
                                                     ARGTYPES_06,
                                                     ARGTYPES_07
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<FN>::type F;

    enum {

        k_INDEX       = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                           uncv(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>())))),
        k_IS_POINTER  = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE   = BSLMF_TAG_TO_INT(checkLvalue(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER && BSLMF_TAG_TO_INT(checkConst(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>()))),
        k_IS_VOLATILE_PTR  = k_IS_POINTER && BSLMF_TAG_TO_INT(checkVolatile(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>()))),
        k_TARGET_INDEX   = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                   uncv(unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>())))),
        k_CANT_DEDUCE_TYPE = (k_TARGET_INDEX==(int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 8
template <bool __Param__0, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08>
struct InvokeResult_FunctorDeduction<__Param__0, FN, ARGTYPES_01,
                                                     ARGTYPES_02,
                                                     ARGTYPES_03,
                                                     ARGTYPES_04,
                                                     ARGTYPES_05,
                                                     ARGTYPES_06,
                                                     ARGTYPES_07,
                                                     ARGTYPES_08
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<FN>::type F;

    enum {

        k_INDEX       = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                           uncv(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>())))),
        k_IS_POINTER  = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE   = BSLMF_TAG_TO_INT(checkLvalue(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER && BSLMF_TAG_TO_INT(checkConst(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>()))),
        k_IS_VOLATILE_PTR  = k_IS_POINTER && BSLMF_TAG_TO_INT(checkVolatile(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>()))),
        k_TARGET_INDEX   = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                   uncv(unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>())))),
        k_CANT_DEDUCE_TYPE = (k_TARGET_INDEX==(int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 9
template <bool __Param__0, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09>
struct InvokeResult_FunctorDeduction<__Param__0, FN, ARGTYPES_01,
                                                     ARGTYPES_02,
                                                     ARGTYPES_03,
                                                     ARGTYPES_04,
                                                     ARGTYPES_05,
                                                     ARGTYPES_06,
                                                     ARGTYPES_07,
                                                     ARGTYPES_08,
                                                     ARGTYPES_09
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<FN>::type F;

    enum {

        k_INDEX       = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                           uncv(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>())))),
        k_IS_POINTER  = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE   = BSLMF_TAG_TO_INT(checkLvalue(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER && BSLMF_TAG_TO_INT(checkConst(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>()))),
        k_IS_VOLATILE_PTR  = k_IS_POINTER && BSLMF_TAG_TO_INT(checkVolatile(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>()))),
        k_TARGET_INDEX   = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                   uncv(unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>())))),
        k_CANT_DEDUCE_TYPE = (k_TARGET_INDEX==(int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 10
template <bool __Param__0, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09,
                                     class ARGTYPES_10>
struct InvokeResult_FunctorDeduction<__Param__0, FN, ARGTYPES_01,
                                                     ARGTYPES_02,
                                                     ARGTYPES_03,
                                                     ARGTYPES_04,
                                                     ARGTYPES_05,
                                                     ARGTYPES_06,
                                                     ARGTYPES_07,
                                                     ARGTYPES_08,
                                                     ARGTYPES_09,
                                                     ARGTYPES_10
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<FN>::type F;

    enum {

        k_INDEX       = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                           uncv(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>())))),
        k_IS_POINTER  = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE   = BSLMF_TAG_TO_INT(checkLvalue(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER && BSLMF_TAG_TO_INT(checkConst(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>()))),
        k_IS_VOLATILE_PTR  = k_IS_POINTER && BSLMF_TAG_TO_INT(checkVolatile(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>()))),
        k_TARGET_INDEX   = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                   uncv(unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>())))),
        k_CANT_DEDUCE_TYPE = (k_TARGET_INDEX==(int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 11
template <bool __Param__0, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09,
                                     class ARGTYPES_10,
                                     class ARGTYPES_11>
struct InvokeResult_FunctorDeduction<__Param__0, FN, ARGTYPES_01,
                                                     ARGTYPES_02,
                                                     ARGTYPES_03,
                                                     ARGTYPES_04,
                                                     ARGTYPES_05,
                                                     ARGTYPES_06,
                                                     ARGTYPES_07,
                                                     ARGTYPES_08,
                                                     ARGTYPES_09,
                                                     ARGTYPES_10,
                                                     ARGTYPES_11
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<FN>::type F;

    enum {

        k_INDEX       = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                           uncv(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>(),
                                                myDeclval<ARGTYPES_11>())))),
        k_IS_POINTER  = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE   = BSLMF_TAG_TO_INT(checkLvalue(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>(),
                                                myDeclval<ARGTYPES_11>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER && BSLMF_TAG_TO_INT(checkConst(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>(),
                                                myDeclval<ARGTYPES_11>()))),
        k_IS_VOLATILE_PTR  = k_IS_POINTER && BSLMF_TAG_TO_INT(checkVolatile(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>(),
                                                myDeclval<ARGTYPES_11>()))),
        k_TARGET_INDEX   = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                   uncv(unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>(),
                                                myDeclval<ARGTYPES_11>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>(),
                                                myDeclval<ARGTYPES_11>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>(),
                                                myDeclval<ARGTYPES_11>())))),
        k_CANT_DEDUCE_TYPE = (k_TARGET_INDEX==(int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 12
template <bool __Param__0, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09,
                                     class ARGTYPES_10,
                                     class ARGTYPES_11,
                                     class ARGTYPES_12>
struct InvokeResult_FunctorDeduction<__Param__0, FN, ARGTYPES_01,
                                                     ARGTYPES_02,
                                                     ARGTYPES_03,
                                                     ARGTYPES_04,
                                                     ARGTYPES_05,
                                                     ARGTYPES_06,
                                                     ARGTYPES_07,
                                                     ARGTYPES_08,
                                                     ARGTYPES_09,
                                                     ARGTYPES_10,
                                                     ARGTYPES_11,
                                                     ARGTYPES_12
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<FN>::type F;

    enum {

        k_INDEX       = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                           uncv(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>(),
                                                myDeclval<ARGTYPES_11>(),
                                                myDeclval<ARGTYPES_12>())))),
        k_IS_POINTER  = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE   = BSLMF_TAG_TO_INT(checkLvalue(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>(),
                                                myDeclval<ARGTYPES_11>(),
                                                myDeclval<ARGTYPES_12>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER && BSLMF_TAG_TO_INT(checkConst(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>(),
                                                myDeclval<ARGTYPES_11>(),
                                                myDeclval<ARGTYPES_12>()))),
        k_IS_VOLATILE_PTR  = k_IS_POINTER && BSLMF_TAG_TO_INT(checkVolatile(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>(),
                                                myDeclval<ARGTYPES_11>(),
                                                myDeclval<ARGTYPES_12>()))),
        k_TARGET_INDEX   = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                   uncv(unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>(),
                                                myDeclval<ARGTYPES_11>(),
                                                myDeclval<ARGTYPES_12>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>(),
                                                myDeclval<ARGTYPES_11>(),
                                                myDeclval<ARGTYPES_12>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>(),
                                                myDeclval<ARGTYPES_11>(),
                                                myDeclval<ARGTYPES_12>())))),
        k_CANT_DEDUCE_TYPE = (k_TARGET_INDEX==(int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 13
template <bool __Param__0, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09,
                                     class ARGTYPES_10,
                                     class ARGTYPES_11,
                                     class ARGTYPES_12,
                                     class ARGTYPES_13>
struct InvokeResult_FunctorDeduction<__Param__0, FN, ARGTYPES_01,
                                                     ARGTYPES_02,
                                                     ARGTYPES_03,
                                                     ARGTYPES_04,
                                                     ARGTYPES_05,
                                                     ARGTYPES_06,
                                                     ARGTYPES_07,
                                                     ARGTYPES_08,
                                                     ARGTYPES_09,
                                                     ARGTYPES_10,
                                                     ARGTYPES_11,
                                                     ARGTYPES_12,
                                                     ARGTYPES_13
                                                    > : InvokeResult_ImpUtils {

    typedef typename bsl::decay<FN>::type F;

    enum {

        k_INDEX       = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                           uncv(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>(),
                                                myDeclval<ARGTYPES_11>(),
                                                myDeclval<ARGTYPES_12>(),
                                                myDeclval<ARGTYPES_13>())))),
        k_IS_POINTER  = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE   = BSLMF_TAG_TO_INT(checkLvalue(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>(),
                                                myDeclval<ARGTYPES_11>(),
                                                myDeclval<ARGTYPES_12>(),
                                                myDeclval<ARGTYPES_13>()), 0)),
        k_IS_CONST_PTR = k_IS_POINTER && BSLMF_TAG_TO_INT(checkConst(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>(),
                                                myDeclval<ARGTYPES_11>(),
                                                myDeclval<ARGTYPES_12>(),
                                                myDeclval<ARGTYPES_13>()))),
        k_IS_VOLATILE_PTR  = k_IS_POINTER && BSLMF_TAG_TO_INT(checkVolatile(
                                myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>(),
                                                myDeclval<ARGTYPES_11>(),
                                                myDeclval<ARGTYPES_12>(),
                                                myDeclval<ARGTYPES_13>()))),
        k_TARGET_INDEX   = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                   uncv(unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>(),
                                                myDeclval<ARGTYPES_11>(),
                                                myDeclval<ARGTYPES_12>(),
                                                myDeclval<ARGTYPES_13>()))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>(),
                                                myDeclval<ARGTYPES_11>(),
                                                myDeclval<ARGTYPES_12>(),
                                                myDeclval<ARGTYPES_13>())))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                                myDeclval<ARGTYPES_02>(),
                                                myDeclval<ARGTYPES_03>(),
                                                myDeclval<ARGTYPES_04>(),
                                                myDeclval<ARGTYPES_05>(),
                                                myDeclval<ARGTYPES_06>(),
                                                myDeclval<ARGTYPES_07>(),
                                                myDeclval<ARGTYPES_08>(),
                                                myDeclval<ARGTYPES_09>(),
                                                myDeclval<ARGTYPES_10>(),
                                                myDeclval<ARGTYPES_11>(),
                                                myDeclval<ARGTYPES_12>(),
                                                myDeclval<ARGTYPES_13>())))),
        k_CANT_DEDUCE_TYPE = (k_TARGET_INDEX==(int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 13


#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 0
template <class FN>
struct InvokeResult_FunctorDeduction<true , FN>
{

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 1
template <class FN, class ARGTYPES_01>
struct InvokeResult_FunctorDeduction<true , FN, ARGTYPES_01>
{

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 2
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02>
struct InvokeResult_FunctorDeduction<true , FN, ARGTYPES_01,
                                                ARGTYPES_02>
{

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 3
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03>
struct InvokeResult_FunctorDeduction<true , FN, ARGTYPES_01,
                                                ARGTYPES_02,
                                                ARGTYPES_03>
{

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 4
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04>
struct InvokeResult_FunctorDeduction<true , FN, ARGTYPES_01,
                                                ARGTYPES_02,
                                                ARGTYPES_03,
                                                ARGTYPES_04>
{

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 5
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05>
struct InvokeResult_FunctorDeduction<true , FN, ARGTYPES_01,
                                                ARGTYPES_02,
                                                ARGTYPES_03,
                                                ARGTYPES_04,
                                                ARGTYPES_05>
{

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 6
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06>
struct InvokeResult_FunctorDeduction<true , FN, ARGTYPES_01,
                                                ARGTYPES_02,
                                                ARGTYPES_03,
                                                ARGTYPES_04,
                                                ARGTYPES_05,
                                                ARGTYPES_06>
{

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 7
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07>
struct InvokeResult_FunctorDeduction<true , FN, ARGTYPES_01,
                                                ARGTYPES_02,
                                                ARGTYPES_03,
                                                ARGTYPES_04,
                                                ARGTYPES_05,
                                                ARGTYPES_06,
                                                ARGTYPES_07>
{

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 8
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08>
struct InvokeResult_FunctorDeduction<true , FN, ARGTYPES_01,
                                                ARGTYPES_02,
                                                ARGTYPES_03,
                                                ARGTYPES_04,
                                                ARGTYPES_05,
                                                ARGTYPES_06,
                                                ARGTYPES_07,
                                                ARGTYPES_08>
{

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 9
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09>
struct InvokeResult_FunctorDeduction<true , FN, ARGTYPES_01,
                                                ARGTYPES_02,
                                                ARGTYPES_03,
                                                ARGTYPES_04,
                                                ARGTYPES_05,
                                                ARGTYPES_06,
                                                ARGTYPES_07,
                                                ARGTYPES_08,
                                                ARGTYPES_09>
{

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 10
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10>
struct InvokeResult_FunctorDeduction<true , FN, ARGTYPES_01,
                                                ARGTYPES_02,
                                                ARGTYPES_03,
                                                ARGTYPES_04,
                                                ARGTYPES_05,
                                                ARGTYPES_06,
                                                ARGTYPES_07,
                                                ARGTYPES_08,
                                                ARGTYPES_09,
                                                ARGTYPES_10>
{

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 11
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11>
struct InvokeResult_FunctorDeduction<true , FN, ARGTYPES_01,
                                                ARGTYPES_02,
                                                ARGTYPES_03,
                                                ARGTYPES_04,
                                                ARGTYPES_05,
                                                ARGTYPES_06,
                                                ARGTYPES_07,
                                                ARGTYPES_08,
                                                ARGTYPES_09,
                                                ARGTYPES_10,
                                                ARGTYPES_11>
{

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 12
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11,
                    class ARGTYPES_12>
struct InvokeResult_FunctorDeduction<true , FN, ARGTYPES_01,
                                                ARGTYPES_02,
                                                ARGTYPES_03,
                                                ARGTYPES_04,
                                                ARGTYPES_05,
                                                ARGTYPES_06,
                                                ARGTYPES_07,
                                                ARGTYPES_08,
                                                ARGTYPES_09,
                                                ARGTYPES_10,
                                                ARGTYPES_11,
                                                ARGTYPES_12>
{

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 13
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11,
                    class ARGTYPES_12,
                    class ARGTYPES_13>
struct InvokeResult_FunctorDeduction<true , FN, ARGTYPES_01,
                                                ARGTYPES_02,
                                                ARGTYPES_03,
                                                ARGTYPES_04,
                                                ARGTYPES_05,
                                                ARGTYPES_06,
                                                ARGTYPES_07,
                                                ARGTYPES_08,
                                                ARGTYPES_09,
                                                ARGTYPES_10,
                                                ARGTYPES_11,
                                                ARGTYPES_12,
                                                ARGTYPES_13>
{

    typedef void type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_D >= 13

#endif
#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.

#ifndef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
template <bool , class FN, class... ARGTYPES>
struct InvokeResult_FunctorDeduction : InvokeResult_ImpUtils {

    typedef typename bsl::decay<FN>::type F;

    enum {

        k_INDEX       = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                           uncv(myDeclval<FN>()(myDeclval<ARGTYPES>()...)))),
        k_IS_POINTER  = (k_INDEX == InvokeResult_Index::e_POINTER),
        k_IS_LVALUE   = BSLMF_TAG_TO_INT(checkLvalue(
                                myDeclval<FN>()(myDeclval<ARGTYPES>()...), 0)),
        k_IS_CONST_PTR = k_IS_POINTER && BSLMF_TAG_TO_INT(checkConst(
                                myDeclval<FN>()(myDeclval<ARGTYPES>()...))),
        k_IS_VOLATILE_PTR  = k_IS_POINTER && BSLMF_TAG_TO_INT(checkVolatile(
                                myDeclval<FN>()(myDeclval<ARGTYPES>()...))),
        k_TARGET_INDEX   = BSLMF_TAG_TO_INT(InvokeResult_Index::fromVal(
                   uncv(unpoint(myDeclval<FN>()(myDeclval<ARGTYPES>()...))))),
        k_IS_CONST_TARGET    = BSLMF_TAG_TO_INT(checkConst(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES>()...)))),
        k_IS_VOLATILE_TARGET = BSLMF_TAG_TO_INT(checkVolatile(
                        unpoint(myDeclval<FN>()(myDeclval<ARGTYPES>()...)))),
        k_CANT_DEDUCE_TYPE = (k_TARGET_INDEX==(int)InvokeResult_Index::e_OTHER)
    };

    typedef typename bsl::conditional<
            ! k_CANT_DEDUCE_TYPE,
            typename InvokeResult_Type<k_TARGET_INDEX>::type,
            typename ResultType<F,InvokeResultDeductionFailed>::type
        >::type UnqualTargetType;

    typedef typename
    InvokeResult_AddCVRef<UnqualTargetType,
                          static_cast<bool>(k_IS_CONST_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          static_cast<bool>(k_IS_VOLATILE_TARGET)
                          && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                          false>::type CVQualTargetType;

    typedef typename
    bsl::conditional<static_cast<bool>(k_IS_POINTER)
                     && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
                     typename bsl::add_pointer<CVQualTargetType>::type,
                     CVQualTargetType>::type UnqualType;

    typedef typename
    InvokeResult_AddCVRef<
        UnqualType,
        static_cast<bool>(k_IS_CONST_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_VOLATILE_PTR)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE),
        static_cast<bool>(k_IS_LVALUE)
        && ! static_cast<bool>(k_CANT_DEDUCE_TYPE)>::type Qtype;

    typedef typename bsl::conditional<static_cast<bool>(k_IS_LVALUE), Qtype,
                      typename bsl::remove_cv<Qtype>::type>::type type;
};

template <class FN, class... ARGTYPES>
struct InvokeResult_FunctorDeduction<true , FN, ARGTYPES...>
{

    typedef void type;
};
#endif

// }}} END GENERATED CODE
#endif

template <class MEMOF_CLASS,
          class ARG_TYPE,
          bool  IS_DERIVED = bsl::is_convertible<
            typename bsl::decay<ARG_TYPE>::type*,
            typename bsl::decay<MEMOF_CLASS>::type*>::value>
struct InvokeResult_MemPtrArgQualifiers {
    // This metafunction determines which cv qualifiers and reference
    // qualifiers should be propagated from the first argument of
    // 'invoke_result'.  This primary template is instantiated when 'ARG_TYPE'
    // is the same or is derived from 'MEMOF_CLASS'.  The constant
    // 'k_IS_LVALUE' is true iff 'ARG_TYPE' is an lvalue reference; the
    // constant 'k_IS_CONST' is true iff 'ARG_TYPE' is const-qualified; and
    // the constant 'k_IS_VOLATILE' is true iff 'ARG_TYPE' is
    // volatile-qualified.

    // TYPES
    enum {
        k_IS_LVALUE    = bsl::is_lvalue_reference<ARG_TYPE>::value,
        k_IS_CONST     = bsl::is_const<
            typename bsl::remove_reference<ARG_TYPE>::type>::value,
        k_IS_VOLATILE  = bsl::is_volatile<
            typename bsl::remove_reference<ARG_TYPE>::type>::value
    };
};

template <class MEMOF_CLASS, class ARG_TYPE>
struct InvokeResult_MemPtrArgQualifiers<MEMOF_CLASS, ARG_TYPE, false>
    : InvokeResult_ImpUtils {
    // This metafunction determines which cv qualifiers and reference
    // qualifiers should be propagated from the first argument of
    // 'invoke_result'.
    //
    // This specialization is instantiated when 'ARG_TYPE' is not derived from
    // 'MEMOF_CLASS' and is assumed to be a pointer or smart pointer type.  If
    // type 'A' is the result of dereferencing an object of type 'ARG_TYPE',
    // then the constant 'k_IS_LVALUE' is true iff 'A' is an lvalue reference;
    // the constant 'k_IS_CONST' is true iff 'A' is a const-qualified
    // reference; and the constant 'k_IS_VOLATILE' is true iff 'A' is a
    // volatile-qualified reference.

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
  private:
    // CLASS METHODS
    template <class TP>
    static TP& tolvalue(TP&&);
        // (Declared but not defined.)  Return an lvalue reference
        // corresponding of the specified 'TP' type, which is deduced from the
        // specified unnamed argument.  If the argument is an lvalue, the
        // return type is identical to the argument type.  If the argument is
        // an rvalue, the return type is an lvalue to the argument type with
        // the same cv qualifiers.  This function is useful for avoiding too
        // many redundant overloads in metafunctions that determine cv
        // qualifications, etc.

  public:
    // TYPES
    enum {
        k_IS_LVALUE  = BSLMF_TAG_TO_INT(checkLvalue(*myDeclval<ARG_TYPE>(),0)),
        k_IS_CONST   = BSLMF_TAG_TO_INT(checkConst(
                                           tolvalue(*myDeclval<ARG_TYPE>()))),
        k_IS_VOLATILE= BSLMF_TAG_TO_INT(checkVolatile(
                                           tolvalue(*myDeclval<ARG_TYPE>())))
    };
#else
  public:
    // TYPES
    enum {
        k_IS_LVALUE  = BSLMF_TAG_TO_INT(checkLvalue(*myDeclval<ARG_TYPE>(),0)),
        // In C++03, cv qualifiers are discarded from rvalues.
        k_IS_CONST   = k_IS_LVALUE && BSLMF_TAG_TO_INT(checkConst(
                                                      *myDeclval<ARG_TYPE>())),
        k_IS_VOLATILE= k_IS_LVALUE && BSLMF_TAG_TO_INT(checkVolatile(
                                                      *myDeclval<ARG_TYPE>()))
    };
#endif // BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES

};

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslmf_invokeresult.h
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT 13
#endif
#ifndef BSLMF_INVOKERESULT_VARIADIC_LIMIT_E
#define BSLMF_INVOKERESULT_VARIADIC_LIMIT_E BSLMF_INVOKERESULT_VARIADIC_LIMIT
#endif

template <class VOID_TYPE,
          class FN
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
        , class ARGTYPES_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
        , class ARGTYPES_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
        , class ARGTYPES_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
        , class ARGTYPES_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
        , class ARGTYPES_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
        , class ARGTYPES_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
        , class ARGTYPES_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
        , class ARGTYPES_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
        , class ARGTYPES_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
        , class ARGTYPES_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
        , class ARGTYPES_10 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
        , class ARGTYPES_11 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
        , class ARGTYPES_12 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
        , class = BSLS_COMPILERFEATURES_NILT>
struct InvokeResult_FunctorImp;


template <class VOID_TYPE,
          class FN
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
        , class ARGTYPES_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
        , class ARGTYPES_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
        , class ARGTYPES_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
        , class ARGTYPES_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
        , class ARGTYPES_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
        , class ARGTYPES_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
        , class ARGTYPES_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
        , class ARGTYPES_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
        , class ARGTYPES_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
        , class ARGTYPES_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
        , class ARGTYPES_10 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
        , class ARGTYPES_11 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
        , class ARGTYPES_12 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
        , class = BSLS_COMPILERFEATURES_NILT>
struct InvokeResult_FuncPtrImp;


template <class FN
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
        , class ARGTYPES_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
        , class ARGTYPES_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
        , class ARGTYPES_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
        , class ARGTYPES_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
        , class ARGTYPES_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
        , class ARGTYPES_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
        , class ARGTYPES_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
        , class ARGTYPES_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
        , class ARGTYPES_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
        , class ARGTYPES_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
        , class ARGTYPES_10 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
        , class ARGTYPES_11 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
        , class ARGTYPES_12 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
        , class = BSLS_COMPILERFEATURES_NILT>
struct InvokeResult_MemFuncPtrImp;


template <class FN
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
        , class ARGTYPES_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
        , class ARGTYPES_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
        , class ARGTYPES_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
        , class ARGTYPES_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
        , class ARGTYPES_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
        , class ARGTYPES_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
        , class ARGTYPES_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
        , class ARGTYPES_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
        , class ARGTYPES_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
        , class ARGTYPES_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
        , class ARGTYPES_10 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
        , class ARGTYPES_11 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
        , class ARGTYPES_12 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
        , class = BSLS_COMPILERFEATURES_NILT>
struct InvokeResult_MemObjPtrImp;



#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <bool IS_FUNCPTR, bool IS_MEMFUNCPTR, bool IS_MEMOBJPTR, class FN>
struct InvokeResult_Imp<IS_FUNCPTR, IS_MEMFUNCPTR, IS_MEMOBJPTR, FN>
     : InvokeResult_FunctorImp<void, FN> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <bool IS_FUNCPTR, bool IS_MEMFUNCPTR, bool IS_MEMOBJPTR, class FN,
          class ARGTYPES_01>
struct InvokeResult_Imp<IS_FUNCPTR, IS_MEMFUNCPTR, IS_MEMOBJPTR, FN,
                                                                   ARGTYPES_01>
     : InvokeResult_FunctorImp<void, FN, ARGTYPES_01> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <bool IS_FUNCPTR, bool IS_MEMFUNCPTR, bool IS_MEMOBJPTR, class FN,
          class ARGTYPES_01,
          class ARGTYPES_02>
struct InvokeResult_Imp<IS_FUNCPTR, IS_MEMFUNCPTR, IS_MEMOBJPTR, FN,
                                                                   ARGTYPES_01,
                                                                   ARGTYPES_02>
     : InvokeResult_FunctorImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <bool IS_FUNCPTR, bool IS_MEMFUNCPTR, bool IS_MEMOBJPTR, class FN,
          class ARGTYPES_01,
          class ARGTYPES_02,
          class ARGTYPES_03>
struct InvokeResult_Imp<IS_FUNCPTR, IS_MEMFUNCPTR, IS_MEMOBJPTR, FN,
                                                                   ARGTYPES_01,
                                                                   ARGTYPES_02,
                                                                   ARGTYPES_03>
     : InvokeResult_FunctorImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02,
                                         ARGTYPES_03> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <bool IS_FUNCPTR, bool IS_MEMFUNCPTR, bool IS_MEMOBJPTR, class FN,
          class ARGTYPES_01,
          class ARGTYPES_02,
          class ARGTYPES_03,
          class ARGTYPES_04>
struct InvokeResult_Imp<IS_FUNCPTR, IS_MEMFUNCPTR, IS_MEMOBJPTR, FN,
                                                                   ARGTYPES_01,
                                                                   ARGTYPES_02,
                                                                   ARGTYPES_03,
                                                                   ARGTYPES_04>
     : InvokeResult_FunctorImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02,
                                         ARGTYPES_03,
                                         ARGTYPES_04> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <bool IS_FUNCPTR, bool IS_MEMFUNCPTR, bool IS_MEMOBJPTR, class FN,
          class ARGTYPES_01,
          class ARGTYPES_02,
          class ARGTYPES_03,
          class ARGTYPES_04,
          class ARGTYPES_05>
struct InvokeResult_Imp<IS_FUNCPTR, IS_MEMFUNCPTR, IS_MEMOBJPTR, FN,
                                                                   ARGTYPES_01,
                                                                   ARGTYPES_02,
                                                                   ARGTYPES_03,
                                                                   ARGTYPES_04,
                                                                   ARGTYPES_05>
     : InvokeResult_FunctorImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02,
                                         ARGTYPES_03,
                                         ARGTYPES_04,
                                         ARGTYPES_05> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <bool IS_FUNCPTR, bool IS_MEMFUNCPTR, bool IS_MEMOBJPTR, class FN,
          class ARGTYPES_01,
          class ARGTYPES_02,
          class ARGTYPES_03,
          class ARGTYPES_04,
          class ARGTYPES_05,
          class ARGTYPES_06>
struct InvokeResult_Imp<IS_FUNCPTR, IS_MEMFUNCPTR, IS_MEMOBJPTR, FN,
                                                                   ARGTYPES_01,
                                                                   ARGTYPES_02,
                                                                   ARGTYPES_03,
                                                                   ARGTYPES_04,
                                                                   ARGTYPES_05,
                                                                   ARGTYPES_06>
     : InvokeResult_FunctorImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02,
                                         ARGTYPES_03,
                                         ARGTYPES_04,
                                         ARGTYPES_05,
                                         ARGTYPES_06> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <bool IS_FUNCPTR, bool IS_MEMFUNCPTR, bool IS_MEMOBJPTR, class FN,
          class ARGTYPES_01,
          class ARGTYPES_02,
          class ARGTYPES_03,
          class ARGTYPES_04,
          class ARGTYPES_05,
          class ARGTYPES_06,
          class ARGTYPES_07>
struct InvokeResult_Imp<IS_FUNCPTR, IS_MEMFUNCPTR, IS_MEMOBJPTR, FN,
                                                                   ARGTYPES_01,
                                                                   ARGTYPES_02,
                                                                   ARGTYPES_03,
                                                                   ARGTYPES_04,
                                                                   ARGTYPES_05,
                                                                   ARGTYPES_06,
                                                                   ARGTYPES_07>
     : InvokeResult_FunctorImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02,
                                         ARGTYPES_03,
                                         ARGTYPES_04,
                                         ARGTYPES_05,
                                         ARGTYPES_06,
                                         ARGTYPES_07> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <bool IS_FUNCPTR, bool IS_MEMFUNCPTR, bool IS_MEMOBJPTR, class FN,
          class ARGTYPES_01,
          class ARGTYPES_02,
          class ARGTYPES_03,
          class ARGTYPES_04,
          class ARGTYPES_05,
          class ARGTYPES_06,
          class ARGTYPES_07,
          class ARGTYPES_08>
struct InvokeResult_Imp<IS_FUNCPTR, IS_MEMFUNCPTR, IS_MEMOBJPTR, FN,
                                                                   ARGTYPES_01,
                                                                   ARGTYPES_02,
                                                                   ARGTYPES_03,
                                                                   ARGTYPES_04,
                                                                   ARGTYPES_05,
                                                                   ARGTYPES_06,
                                                                   ARGTYPES_07,
                                                                   ARGTYPES_08>
     : InvokeResult_FunctorImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02,
                                         ARGTYPES_03,
                                         ARGTYPES_04,
                                         ARGTYPES_05,
                                         ARGTYPES_06,
                                         ARGTYPES_07,
                                         ARGTYPES_08> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <bool IS_FUNCPTR, bool IS_MEMFUNCPTR, bool IS_MEMOBJPTR, class FN,
          class ARGTYPES_01,
          class ARGTYPES_02,
          class ARGTYPES_03,
          class ARGTYPES_04,
          class ARGTYPES_05,
          class ARGTYPES_06,
          class ARGTYPES_07,
          class ARGTYPES_08,
          class ARGTYPES_09>
struct InvokeResult_Imp<IS_FUNCPTR, IS_MEMFUNCPTR, IS_MEMOBJPTR, FN,
                                                                   ARGTYPES_01,
                                                                   ARGTYPES_02,
                                                                   ARGTYPES_03,
                                                                   ARGTYPES_04,
                                                                   ARGTYPES_05,
                                                                   ARGTYPES_06,
                                                                   ARGTYPES_07,
                                                                   ARGTYPES_08,
                                                                   ARGTYPES_09>
     : InvokeResult_FunctorImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02,
                                         ARGTYPES_03,
                                         ARGTYPES_04,
                                         ARGTYPES_05,
                                         ARGTYPES_06,
                                         ARGTYPES_07,
                                         ARGTYPES_08,
                                         ARGTYPES_09> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <bool IS_FUNCPTR, bool IS_MEMFUNCPTR, bool IS_MEMOBJPTR, class FN,
          class ARGTYPES_01,
          class ARGTYPES_02,
          class ARGTYPES_03,
          class ARGTYPES_04,
          class ARGTYPES_05,
          class ARGTYPES_06,
          class ARGTYPES_07,
          class ARGTYPES_08,
          class ARGTYPES_09,
          class ARGTYPES_10>
struct InvokeResult_Imp<IS_FUNCPTR, IS_MEMFUNCPTR, IS_MEMOBJPTR, FN,
                                                                   ARGTYPES_01,
                                                                   ARGTYPES_02,
                                                                   ARGTYPES_03,
                                                                   ARGTYPES_04,
                                                                   ARGTYPES_05,
                                                                   ARGTYPES_06,
                                                                   ARGTYPES_07,
                                                                   ARGTYPES_08,
                                                                   ARGTYPES_09,
                                                                   ARGTYPES_10>
     : InvokeResult_FunctorImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02,
                                         ARGTYPES_03,
                                         ARGTYPES_04,
                                         ARGTYPES_05,
                                         ARGTYPES_06,
                                         ARGTYPES_07,
                                         ARGTYPES_08,
                                         ARGTYPES_09,
                                         ARGTYPES_10> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <bool IS_FUNCPTR, bool IS_MEMFUNCPTR, bool IS_MEMOBJPTR, class FN,
          class ARGTYPES_01,
          class ARGTYPES_02,
          class ARGTYPES_03,
          class ARGTYPES_04,
          class ARGTYPES_05,
          class ARGTYPES_06,
          class ARGTYPES_07,
          class ARGTYPES_08,
          class ARGTYPES_09,
          class ARGTYPES_10,
          class ARGTYPES_11>
struct InvokeResult_Imp<IS_FUNCPTR, IS_MEMFUNCPTR, IS_MEMOBJPTR, FN,
                                                                   ARGTYPES_01,
                                                                   ARGTYPES_02,
                                                                   ARGTYPES_03,
                                                                   ARGTYPES_04,
                                                                   ARGTYPES_05,
                                                                   ARGTYPES_06,
                                                                   ARGTYPES_07,
                                                                   ARGTYPES_08,
                                                                   ARGTYPES_09,
                                                                   ARGTYPES_10,
                                                                   ARGTYPES_11>
     : InvokeResult_FunctorImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02,
                                         ARGTYPES_03,
                                         ARGTYPES_04,
                                         ARGTYPES_05,
                                         ARGTYPES_06,
                                         ARGTYPES_07,
                                         ARGTYPES_08,
                                         ARGTYPES_09,
                                         ARGTYPES_10,
                                         ARGTYPES_11> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <bool IS_FUNCPTR, bool IS_MEMFUNCPTR, bool IS_MEMOBJPTR, class FN,
          class ARGTYPES_01,
          class ARGTYPES_02,
          class ARGTYPES_03,
          class ARGTYPES_04,
          class ARGTYPES_05,
          class ARGTYPES_06,
          class ARGTYPES_07,
          class ARGTYPES_08,
          class ARGTYPES_09,
          class ARGTYPES_10,
          class ARGTYPES_11,
          class ARGTYPES_12>
struct InvokeResult_Imp<IS_FUNCPTR, IS_MEMFUNCPTR, IS_MEMOBJPTR, FN,
                                                                   ARGTYPES_01,
                                                                   ARGTYPES_02,
                                                                   ARGTYPES_03,
                                                                   ARGTYPES_04,
                                                                   ARGTYPES_05,
                                                                   ARGTYPES_06,
                                                                   ARGTYPES_07,
                                                                   ARGTYPES_08,
                                                                   ARGTYPES_09,
                                                                   ARGTYPES_10,
                                                                   ARGTYPES_11,
                                                                   ARGTYPES_12>
     : InvokeResult_FunctorImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02,
                                         ARGTYPES_03,
                                         ARGTYPES_04,
                                         ARGTYPES_05,
                                         ARGTYPES_06,
                                         ARGTYPES_07,
                                         ARGTYPES_08,
                                         ARGTYPES_09,
                                         ARGTYPES_10,
                                         ARGTYPES_11,
                                         ARGTYPES_12> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <bool IS_FUNCPTR, bool IS_MEMFUNCPTR, bool IS_MEMOBJPTR, class FN,
          class ARGTYPES_01,
          class ARGTYPES_02,
          class ARGTYPES_03,
          class ARGTYPES_04,
          class ARGTYPES_05,
          class ARGTYPES_06,
          class ARGTYPES_07,
          class ARGTYPES_08,
          class ARGTYPES_09,
          class ARGTYPES_10,
          class ARGTYPES_11,
          class ARGTYPES_12,
          class ARGTYPES_13>
struct InvokeResult_Imp<IS_FUNCPTR, IS_MEMFUNCPTR, IS_MEMOBJPTR, FN,
                                                                   ARGTYPES_01,
                                                                   ARGTYPES_02,
                                                                   ARGTYPES_03,
                                                                   ARGTYPES_04,
                                                                   ARGTYPES_05,
                                                                   ARGTYPES_06,
                                                                   ARGTYPES_07,
                                                                   ARGTYPES_08,
                                                                   ARGTYPES_09,
                                                                   ARGTYPES_10,
                                                                   ARGTYPES_11,
                                                                   ARGTYPES_12,
                                                                   ARGTYPES_13>
     : InvokeResult_FunctorImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02,
                                         ARGTYPES_03,
                                         ARGTYPES_04,
                                         ARGTYPES_05,
                                         ARGTYPES_06,
                                         ARGTYPES_07,
                                         ARGTYPES_08,
                                         ARGTYPES_09,
                                         ARGTYPES_10,
                                         ARGTYPES_11,
                                         ARGTYPES_12,
                                         ARGTYPES_13> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13


#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class FN>
struct InvokeResult_Imp<true , false, false, FN>
     : InvokeResult_FuncPtrImp<void, FN> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class FN, class ARGTYPES_01>
struct InvokeResult_Imp<true , false, false, FN, ARGTYPES_01>
     : InvokeResult_FuncPtrImp<void, FN, ARGTYPES_01> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02>
struct InvokeResult_Imp<true , false, false, FN, ARGTYPES_01,
                                                 ARGTYPES_02>
     : InvokeResult_FuncPtrImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03>
struct InvokeResult_Imp<true , false, false, FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03>
     : InvokeResult_FuncPtrImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02,
                                         ARGTYPES_03> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04>
struct InvokeResult_Imp<true , false, false, FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04>
     : InvokeResult_FuncPtrImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02,
                                         ARGTYPES_03,
                                         ARGTYPES_04> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05>
struct InvokeResult_Imp<true , false, false, FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05>
     : InvokeResult_FuncPtrImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02,
                                         ARGTYPES_03,
                                         ARGTYPES_04,
                                         ARGTYPES_05> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06>
struct InvokeResult_Imp<true , false, false, FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06>
     : InvokeResult_FuncPtrImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02,
                                         ARGTYPES_03,
                                         ARGTYPES_04,
                                         ARGTYPES_05,
                                         ARGTYPES_06> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07>
struct InvokeResult_Imp<true , false, false, FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06,
                                                 ARGTYPES_07>
     : InvokeResult_FuncPtrImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02,
                                         ARGTYPES_03,
                                         ARGTYPES_04,
                                         ARGTYPES_05,
                                         ARGTYPES_06,
                                         ARGTYPES_07> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08>
struct InvokeResult_Imp<true , false, false, FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06,
                                                 ARGTYPES_07,
                                                 ARGTYPES_08>
     : InvokeResult_FuncPtrImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02,
                                         ARGTYPES_03,
                                         ARGTYPES_04,
                                         ARGTYPES_05,
                                         ARGTYPES_06,
                                         ARGTYPES_07,
                                         ARGTYPES_08> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09>
struct InvokeResult_Imp<true , false, false, FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06,
                                                 ARGTYPES_07,
                                                 ARGTYPES_08,
                                                 ARGTYPES_09>
     : InvokeResult_FuncPtrImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02,
                                         ARGTYPES_03,
                                         ARGTYPES_04,
                                         ARGTYPES_05,
                                         ARGTYPES_06,
                                         ARGTYPES_07,
                                         ARGTYPES_08,
                                         ARGTYPES_09> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10>
struct InvokeResult_Imp<true , false, false, FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06,
                                                 ARGTYPES_07,
                                                 ARGTYPES_08,
                                                 ARGTYPES_09,
                                                 ARGTYPES_10>
     : InvokeResult_FuncPtrImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02,
                                         ARGTYPES_03,
                                         ARGTYPES_04,
                                         ARGTYPES_05,
                                         ARGTYPES_06,
                                         ARGTYPES_07,
                                         ARGTYPES_08,
                                         ARGTYPES_09,
                                         ARGTYPES_10> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11>
struct InvokeResult_Imp<true , false, false, FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06,
                                                 ARGTYPES_07,
                                                 ARGTYPES_08,
                                                 ARGTYPES_09,
                                                 ARGTYPES_10,
                                                 ARGTYPES_11>
     : InvokeResult_FuncPtrImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02,
                                         ARGTYPES_03,
                                         ARGTYPES_04,
                                         ARGTYPES_05,
                                         ARGTYPES_06,
                                         ARGTYPES_07,
                                         ARGTYPES_08,
                                         ARGTYPES_09,
                                         ARGTYPES_10,
                                         ARGTYPES_11> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11,
                    class ARGTYPES_12>
struct InvokeResult_Imp<true , false, false, FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06,
                                                 ARGTYPES_07,
                                                 ARGTYPES_08,
                                                 ARGTYPES_09,
                                                 ARGTYPES_10,
                                                 ARGTYPES_11,
                                                 ARGTYPES_12>
     : InvokeResult_FuncPtrImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02,
                                         ARGTYPES_03,
                                         ARGTYPES_04,
                                         ARGTYPES_05,
                                         ARGTYPES_06,
                                         ARGTYPES_07,
                                         ARGTYPES_08,
                                         ARGTYPES_09,
                                         ARGTYPES_10,
                                         ARGTYPES_11,
                                         ARGTYPES_12> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11,
                    class ARGTYPES_12,
                    class ARGTYPES_13>
struct InvokeResult_Imp<true , false, false, FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06,
                                                 ARGTYPES_07,
                                                 ARGTYPES_08,
                                                 ARGTYPES_09,
                                                 ARGTYPES_10,
                                                 ARGTYPES_11,
                                                 ARGTYPES_12,
                                                 ARGTYPES_13>
     : InvokeResult_FuncPtrImp<void, FN, ARGTYPES_01,
                                         ARGTYPES_02,
                                         ARGTYPES_03,
                                         ARGTYPES_04,
                                         ARGTYPES_05,
                                         ARGTYPES_06,
                                         ARGTYPES_07,
                                         ARGTYPES_08,
                                         ARGTYPES_09,
                                         ARGTYPES_10,
                                         ARGTYPES_11,
                                         ARGTYPES_12,
                                         ARGTYPES_13> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13


#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class FN>
struct InvokeResult_Imp<false, true , false, FN>
     : InvokeResult_MemFuncPtrImp<FN> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class FN, class ARGTYPES_01>
struct InvokeResult_Imp<false, true , false, FN, ARGTYPES_01>
     : InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02>
struct InvokeResult_Imp<false, true , false, FN, ARGTYPES_01,
                                                 ARGTYPES_02>
     : InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03>
struct InvokeResult_Imp<false, true , false, FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03>
     : InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02,
                                      ARGTYPES_03> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04>
struct InvokeResult_Imp<false, true , false, FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04>
     : InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02,
                                      ARGTYPES_03,
                                      ARGTYPES_04> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05>
struct InvokeResult_Imp<false, true , false, FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05>
     : InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02,
                                      ARGTYPES_03,
                                      ARGTYPES_04,
                                      ARGTYPES_05> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06>
struct InvokeResult_Imp<false, true , false, FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06>
     : InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02,
                                      ARGTYPES_03,
                                      ARGTYPES_04,
                                      ARGTYPES_05,
                                      ARGTYPES_06> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07>
struct InvokeResult_Imp<false, true , false, FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06,
                                                 ARGTYPES_07>
     : InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02,
                                      ARGTYPES_03,
                                      ARGTYPES_04,
                                      ARGTYPES_05,
                                      ARGTYPES_06,
                                      ARGTYPES_07> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08>
struct InvokeResult_Imp<false, true , false, FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06,
                                                 ARGTYPES_07,
                                                 ARGTYPES_08>
     : InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02,
                                      ARGTYPES_03,
                                      ARGTYPES_04,
                                      ARGTYPES_05,
                                      ARGTYPES_06,
                                      ARGTYPES_07,
                                      ARGTYPES_08> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09>
struct InvokeResult_Imp<false, true , false, FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06,
                                                 ARGTYPES_07,
                                                 ARGTYPES_08,
                                                 ARGTYPES_09>
     : InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02,
                                      ARGTYPES_03,
                                      ARGTYPES_04,
                                      ARGTYPES_05,
                                      ARGTYPES_06,
                                      ARGTYPES_07,
                                      ARGTYPES_08,
                                      ARGTYPES_09> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10>
struct InvokeResult_Imp<false, true , false, FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06,
                                                 ARGTYPES_07,
                                                 ARGTYPES_08,
                                                 ARGTYPES_09,
                                                 ARGTYPES_10>
     : InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02,
                                      ARGTYPES_03,
                                      ARGTYPES_04,
                                      ARGTYPES_05,
                                      ARGTYPES_06,
                                      ARGTYPES_07,
                                      ARGTYPES_08,
                                      ARGTYPES_09,
                                      ARGTYPES_10> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11>
struct InvokeResult_Imp<false, true , false, FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06,
                                                 ARGTYPES_07,
                                                 ARGTYPES_08,
                                                 ARGTYPES_09,
                                                 ARGTYPES_10,
                                                 ARGTYPES_11>
     : InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02,
                                      ARGTYPES_03,
                                      ARGTYPES_04,
                                      ARGTYPES_05,
                                      ARGTYPES_06,
                                      ARGTYPES_07,
                                      ARGTYPES_08,
                                      ARGTYPES_09,
                                      ARGTYPES_10,
                                      ARGTYPES_11> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11,
                    class ARGTYPES_12>
struct InvokeResult_Imp<false, true , false, FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06,
                                                 ARGTYPES_07,
                                                 ARGTYPES_08,
                                                 ARGTYPES_09,
                                                 ARGTYPES_10,
                                                 ARGTYPES_11,
                                                 ARGTYPES_12>
     : InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02,
                                      ARGTYPES_03,
                                      ARGTYPES_04,
                                      ARGTYPES_05,
                                      ARGTYPES_06,
                                      ARGTYPES_07,
                                      ARGTYPES_08,
                                      ARGTYPES_09,
                                      ARGTYPES_10,
                                      ARGTYPES_11,
                                      ARGTYPES_12> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11,
                    class ARGTYPES_12,
                    class ARGTYPES_13>
struct InvokeResult_Imp<false, true , false, FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06,
                                                 ARGTYPES_07,
                                                 ARGTYPES_08,
                                                 ARGTYPES_09,
                                                 ARGTYPES_10,
                                                 ARGTYPES_11,
                                                 ARGTYPES_12,
                                                 ARGTYPES_13>
     : InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02,
                                      ARGTYPES_03,
                                      ARGTYPES_04,
                                      ARGTYPES_05,
                                      ARGTYPES_06,
                                      ARGTYPES_07,
                                      ARGTYPES_08,
                                      ARGTYPES_09,
                                      ARGTYPES_10,
                                      ARGTYPES_11,
                                      ARGTYPES_12,
                                      ARGTYPES_13> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13


#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class FN>
struct InvokeResult_Imp<false, false, true , FN>
     : InvokeResult_MemObjPtrImp<FN> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class FN, class ARGTYPES_01>
struct InvokeResult_Imp<false, false, true , FN, ARGTYPES_01>
     : InvokeResult_MemObjPtrImp<FN, ARGTYPES_01> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02>
struct InvokeResult_Imp<false, false, true , FN, ARGTYPES_01,
                                                 ARGTYPES_02>
     : InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03>
struct InvokeResult_Imp<false, false, true , FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03>
     : InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04>
struct InvokeResult_Imp<false, false, true , FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04>
     : InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05>
struct InvokeResult_Imp<false, false, true , FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05>
     : InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06>
struct InvokeResult_Imp<false, false, true , FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06>
     : InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07>
struct InvokeResult_Imp<false, false, true , FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06,
                                                 ARGTYPES_07>
     : InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08>
struct InvokeResult_Imp<false, false, true , FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06,
                                                 ARGTYPES_07,
                                                 ARGTYPES_08>
     : InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09>
struct InvokeResult_Imp<false, false, true , FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06,
                                                 ARGTYPES_07,
                                                 ARGTYPES_08,
                                                 ARGTYPES_09>
     : InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08,
                                     ARGTYPES_09> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10>
struct InvokeResult_Imp<false, false, true , FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06,
                                                 ARGTYPES_07,
                                                 ARGTYPES_08,
                                                 ARGTYPES_09,
                                                 ARGTYPES_10>
     : InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08,
                                     ARGTYPES_09,
                                     ARGTYPES_10> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11>
struct InvokeResult_Imp<false, false, true , FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06,
                                                 ARGTYPES_07,
                                                 ARGTYPES_08,
                                                 ARGTYPES_09,
                                                 ARGTYPES_10,
                                                 ARGTYPES_11>
     : InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08,
                                     ARGTYPES_09,
                                     ARGTYPES_10,
                                     ARGTYPES_11> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11,
                    class ARGTYPES_12>
struct InvokeResult_Imp<false, false, true , FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06,
                                                 ARGTYPES_07,
                                                 ARGTYPES_08,
                                                 ARGTYPES_09,
                                                 ARGTYPES_10,
                                                 ARGTYPES_11,
                                                 ARGTYPES_12>
     : InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08,
                                     ARGTYPES_09,
                                     ARGTYPES_10,
                                     ARGTYPES_11,
                                     ARGTYPES_12> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11,
                    class ARGTYPES_12,
                    class ARGTYPES_13>
struct InvokeResult_Imp<false, false, true , FN, ARGTYPES_01,
                                                 ARGTYPES_02,
                                                 ARGTYPES_03,
                                                 ARGTYPES_04,
                                                 ARGTYPES_05,
                                                 ARGTYPES_06,
                                                 ARGTYPES_07,
                                                 ARGTYPES_08,
                                                 ARGTYPES_09,
                                                 ARGTYPES_10,
                                                 ARGTYPES_11,
                                                 ARGTYPES_12,
                                                 ARGTYPES_13>
     : InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08,
                                     ARGTYPES_09,
                                     ARGTYPES_10,
                                     ARGTYPES_11,
                                     ARGTYPES_12,
                                     ARGTYPES_13> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13



#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class VOID_TYPE, class FN>
struct InvokeResult_FunctorImp<VOID_TYPE, FN> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class VOID_TYPE, class FN, class ARGTYPES_01>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08,
                                              ARGTYPES_09> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09,
                                     class ARGTYPES_10>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08,
                                              ARGTYPES_09,
                                              ARGTYPES_10> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09,
                                     class ARGTYPES_10,
                                     class ARGTYPES_11>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08,
                                              ARGTYPES_09,
                                              ARGTYPES_10,
                                              ARGTYPES_11> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09,
                                     class ARGTYPES_10,
                                     class ARGTYPES_11,
                                     class ARGTYPES_12>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08,
                                              ARGTYPES_09,
                                              ARGTYPES_10,
                                              ARGTYPES_11,
                                              ARGTYPES_12> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09,
                                     class ARGTYPES_10,
                                     class ARGTYPES_11,
                                     class ARGTYPES_12,
                                     class ARGTYPES_13>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08,
                                              ARGTYPES_09,
                                              ARGTYPES_10,
                                              ARGTYPES_11,
                                              ARGTYPES_12,
                                              ARGTYPES_13> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13


#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class FN>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        ))>::type,
    FN> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()()) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class FN, class ARGTYPES_01>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>()))>::type,
    FN,
    ARGTYPES_01> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>(),
                                     myDeclval<ARGTYPES_03>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>(),
                                     myDeclval<ARGTYPES_03>(),
                                     myDeclval<ARGTYPES_04>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>(),
                                     myDeclval<ARGTYPES_03>(),
                                     myDeclval<ARGTYPES_04>(),
                                     myDeclval<ARGTYPES_05>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>(),
                                     myDeclval<ARGTYPES_03>(),
                                     myDeclval<ARGTYPES_04>(),
                                     myDeclval<ARGTYPES_05>(),
                                     myDeclval<ARGTYPES_06>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>(),
                                     myDeclval<ARGTYPES_03>(),
                                     myDeclval<ARGTYPES_04>(),
                                     myDeclval<ARGTYPES_05>(),
                                     myDeclval<ARGTYPES_06>(),
                                     myDeclval<ARGTYPES_07>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>(),
                                     myDeclval<ARGTYPES_03>(),
                                     myDeclval<ARGTYPES_04>(),
                                     myDeclval<ARGTYPES_05>(),
                                     myDeclval<ARGTYPES_06>(),
                                     myDeclval<ARGTYPES_07>(),
                                     myDeclval<ARGTYPES_08>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>(),
                                     myDeclval<ARGTYPES_03>(),
                                     myDeclval<ARGTYPES_04>(),
                                     myDeclval<ARGTYPES_05>(),
                                     myDeclval<ARGTYPES_06>(),
                                     myDeclval<ARGTYPES_07>(),
                                     myDeclval<ARGTYPES_08>(),
                                     myDeclval<ARGTYPES_09>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_10>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09,
    ARGTYPES_10> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>(),
                                     myDeclval<ARGTYPES_03>(),
                                     myDeclval<ARGTYPES_04>(),
                                     myDeclval<ARGTYPES_05>(),
                                     myDeclval<ARGTYPES_06>(),
                                     myDeclval<ARGTYPES_07>(),
                                     myDeclval<ARGTYPES_08>(),
                                     myDeclval<ARGTYPES_09>(),
                                     myDeclval<ARGTYPES_10>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_10>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_11>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09,
    ARGTYPES_10,
    ARGTYPES_11> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>(),
                                     myDeclval<ARGTYPES_03>(),
                                     myDeclval<ARGTYPES_04>(),
                                     myDeclval<ARGTYPES_05>(),
                                     myDeclval<ARGTYPES_06>(),
                                     myDeclval<ARGTYPES_07>(),
                                     myDeclval<ARGTYPES_08>(),
                                     myDeclval<ARGTYPES_09>(),
                                     myDeclval<ARGTYPES_10>(),
                                     myDeclval<ARGTYPES_11>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11,
                    class ARGTYPES_12>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_10>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_11>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_12>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09,
    ARGTYPES_10,
    ARGTYPES_11,
    ARGTYPES_12> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>(),
                                     myDeclval<ARGTYPES_03>(),
                                     myDeclval<ARGTYPES_04>(),
                                     myDeclval<ARGTYPES_05>(),
                                     myDeclval<ARGTYPES_06>(),
                                     myDeclval<ARGTYPES_07>(),
                                     myDeclval<ARGTYPES_08>(),
                                     myDeclval<ARGTYPES_09>(),
                                     myDeclval<ARGTYPES_10>(),
                                     myDeclval<ARGTYPES_11>(),
                                     myDeclval<ARGTYPES_12>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11,
                    class ARGTYPES_12,
                    class ARGTYPES_13>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_10>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_11>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_12>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_13>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09,
    ARGTYPES_10,
    ARGTYPES_11,
    ARGTYPES_12,
    ARGTYPES_13> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>(),
                                     myDeclval<ARGTYPES_03>(),
                                     myDeclval<ARGTYPES_04>(),
                                     myDeclval<ARGTYPES_05>(),
                                     myDeclval<ARGTYPES_06>(),
                                     myDeclval<ARGTYPES_07>(),
                                     myDeclval<ARGTYPES_08>(),
                                     myDeclval<ARGTYPES_09>(),
                                     myDeclval<ARGTYPES_10>(),
                                     myDeclval<ARGTYPES_11>(),
                                     myDeclval<ARGTYPES_12>(),
                                     myDeclval<ARGTYPES_13>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13

#else
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class VOID_TYPE, class FN>
struct InvokeResult_FunctorImp<VOID_TYPE, FN> : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID =
            BSLMF_TAG_TO_INT((myDeclval<FN>()(),
                              InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   FN>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class VOID_TYPE, class FN, class ARGTYPES_01>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01
                                              > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID =
            BSLMF_TAG_TO_INT((myDeclval<FN>()(myDeclval<ARGTYPES_01>()),
                              InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   FN,
                                                   ARGTYPES_01>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02
                                              > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID =
            BSLMF_TAG_TO_INT((myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>()),
                              InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   FN,
                                                   ARGTYPES_01,
                                                   ARGTYPES_02>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03
                                              > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID =
            BSLMF_TAG_TO_INT((myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>(),
                                              myDeclval<ARGTYPES_03>()),
                              InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   FN,
                                                   ARGTYPES_01,
                                                   ARGTYPES_02,
                                                   ARGTYPES_03>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04
                                              > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID =
            BSLMF_TAG_TO_INT((myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>(),
                                              myDeclval<ARGTYPES_03>(),
                                              myDeclval<ARGTYPES_04>()),
                              InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   FN,
                                                   ARGTYPES_01,
                                                   ARGTYPES_02,
                                                   ARGTYPES_03,
                                                   ARGTYPES_04>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05
                                              > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID =
            BSLMF_TAG_TO_INT((myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>(),
                                              myDeclval<ARGTYPES_03>(),
                                              myDeclval<ARGTYPES_04>(),
                                              myDeclval<ARGTYPES_05>()),
                              InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   FN,
                                                   ARGTYPES_01,
                                                   ARGTYPES_02,
                                                   ARGTYPES_03,
                                                   ARGTYPES_04,
                                                   ARGTYPES_05>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06
                                              > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID =
            BSLMF_TAG_TO_INT((myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>(),
                                              myDeclval<ARGTYPES_03>(),
                                              myDeclval<ARGTYPES_04>(),
                                              myDeclval<ARGTYPES_05>(),
                                              myDeclval<ARGTYPES_06>()),
                              InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   FN,
                                                   ARGTYPES_01,
                                                   ARGTYPES_02,
                                                   ARGTYPES_03,
                                                   ARGTYPES_04,
                                                   ARGTYPES_05,
                                                   ARGTYPES_06>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07
                                              > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID =
            BSLMF_TAG_TO_INT((myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>(),
                                              myDeclval<ARGTYPES_03>(),
                                              myDeclval<ARGTYPES_04>(),
                                              myDeclval<ARGTYPES_05>(),
                                              myDeclval<ARGTYPES_06>(),
                                              myDeclval<ARGTYPES_07>()),
                              InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   FN,
                                                   ARGTYPES_01,
                                                   ARGTYPES_02,
                                                   ARGTYPES_03,
                                                   ARGTYPES_04,
                                                   ARGTYPES_05,
                                                   ARGTYPES_06,
                                                   ARGTYPES_07>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08
                                              > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID =
            BSLMF_TAG_TO_INT((myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>(),
                                              myDeclval<ARGTYPES_03>(),
                                              myDeclval<ARGTYPES_04>(),
                                              myDeclval<ARGTYPES_05>(),
                                              myDeclval<ARGTYPES_06>(),
                                              myDeclval<ARGTYPES_07>(),
                                              myDeclval<ARGTYPES_08>()),
                              InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   FN,
                                                   ARGTYPES_01,
                                                   ARGTYPES_02,
                                                   ARGTYPES_03,
                                                   ARGTYPES_04,
                                                   ARGTYPES_05,
                                                   ARGTYPES_06,
                                                   ARGTYPES_07,
                                                   ARGTYPES_08>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08,
                                              ARGTYPES_09
                                              > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID =
            BSLMF_TAG_TO_INT((myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>(),
                                              myDeclval<ARGTYPES_03>(),
                                              myDeclval<ARGTYPES_04>(),
                                              myDeclval<ARGTYPES_05>(),
                                              myDeclval<ARGTYPES_06>(),
                                              myDeclval<ARGTYPES_07>(),
                                              myDeclval<ARGTYPES_08>(),
                                              myDeclval<ARGTYPES_09>()),
                              InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   FN,
                                                   ARGTYPES_01,
                                                   ARGTYPES_02,
                                                   ARGTYPES_03,
                                                   ARGTYPES_04,
                                                   ARGTYPES_05,
                                                   ARGTYPES_06,
                                                   ARGTYPES_07,
                                                   ARGTYPES_08,
                                                   ARGTYPES_09>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09,
                                     class ARGTYPES_10>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08,
                                              ARGTYPES_09,
                                              ARGTYPES_10
                                              > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID =
            BSLMF_TAG_TO_INT((myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>(),
                                              myDeclval<ARGTYPES_03>(),
                                              myDeclval<ARGTYPES_04>(),
                                              myDeclval<ARGTYPES_05>(),
                                              myDeclval<ARGTYPES_06>(),
                                              myDeclval<ARGTYPES_07>(),
                                              myDeclval<ARGTYPES_08>(),
                                              myDeclval<ARGTYPES_09>(),
                                              myDeclval<ARGTYPES_10>()),
                              InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   FN,
                                                   ARGTYPES_01,
                                                   ARGTYPES_02,
                                                   ARGTYPES_03,
                                                   ARGTYPES_04,
                                                   ARGTYPES_05,
                                                   ARGTYPES_06,
                                                   ARGTYPES_07,
                                                   ARGTYPES_08,
                                                   ARGTYPES_09,
                                                   ARGTYPES_10>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09,
                                     class ARGTYPES_10,
                                     class ARGTYPES_11>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08,
                                              ARGTYPES_09,
                                              ARGTYPES_10,
                                              ARGTYPES_11
                                              > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID =
            BSLMF_TAG_TO_INT((myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>(),
                                              myDeclval<ARGTYPES_03>(),
                                              myDeclval<ARGTYPES_04>(),
                                              myDeclval<ARGTYPES_05>(),
                                              myDeclval<ARGTYPES_06>(),
                                              myDeclval<ARGTYPES_07>(),
                                              myDeclval<ARGTYPES_08>(),
                                              myDeclval<ARGTYPES_09>(),
                                              myDeclval<ARGTYPES_10>(),
                                              myDeclval<ARGTYPES_11>()),
                              InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   FN,
                                                   ARGTYPES_01,
                                                   ARGTYPES_02,
                                                   ARGTYPES_03,
                                                   ARGTYPES_04,
                                                   ARGTYPES_05,
                                                   ARGTYPES_06,
                                                   ARGTYPES_07,
                                                   ARGTYPES_08,
                                                   ARGTYPES_09,
                                                   ARGTYPES_10,
                                                   ARGTYPES_11>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09,
                                     class ARGTYPES_10,
                                     class ARGTYPES_11,
                                     class ARGTYPES_12>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08,
                                              ARGTYPES_09,
                                              ARGTYPES_10,
                                              ARGTYPES_11,
                                              ARGTYPES_12
                                              > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID =
            BSLMF_TAG_TO_INT((myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>(),
                                              myDeclval<ARGTYPES_03>(),
                                              myDeclval<ARGTYPES_04>(),
                                              myDeclval<ARGTYPES_05>(),
                                              myDeclval<ARGTYPES_06>(),
                                              myDeclval<ARGTYPES_07>(),
                                              myDeclval<ARGTYPES_08>(),
                                              myDeclval<ARGTYPES_09>(),
                                              myDeclval<ARGTYPES_10>(),
                                              myDeclval<ARGTYPES_11>(),
                                              myDeclval<ARGTYPES_12>()),
                              InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   FN,
                                                   ARGTYPES_01,
                                                   ARGTYPES_02,
                                                   ARGTYPES_03,
                                                   ARGTYPES_04,
                                                   ARGTYPES_05,
                                                   ARGTYPES_06,
                                                   ARGTYPES_07,
                                                   ARGTYPES_08,
                                                   ARGTYPES_09,
                                                   ARGTYPES_10,
                                                   ARGTYPES_11,
                                                   ARGTYPES_12>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09,
                                     class ARGTYPES_10,
                                     class ARGTYPES_11,
                                     class ARGTYPES_12,
                                     class ARGTYPES_13>
struct InvokeResult_FunctorImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08,
                                              ARGTYPES_09,
                                              ARGTYPES_10,
                                              ARGTYPES_11,
                                              ARGTYPES_12,
                                              ARGTYPES_13
                                              > : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID =
            BSLMF_TAG_TO_INT((myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>(),
                                              myDeclval<ARGTYPES_03>(),
                                              myDeclval<ARGTYPES_04>(),
                                              myDeclval<ARGTYPES_05>(),
                                              myDeclval<ARGTYPES_06>(),
                                              myDeclval<ARGTYPES_07>(),
                                              myDeclval<ARGTYPES_08>(),
                                              myDeclval<ARGTYPES_09>(),
                                              myDeclval<ARGTYPES_10>(),
                                              myDeclval<ARGTYPES_11>(),
                                              myDeclval<ARGTYPES_12>(),
                                              myDeclval<ARGTYPES_13>()),
                              InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   FN,
                                                   ARGTYPES_01,
                                                   ARGTYPES_02,
                                                   ARGTYPES_03,
                                                   ARGTYPES_04,
                                                   ARGTYPES_05,
                                                   ARGTYPES_06,
                                                   ARGTYPES_07,
                                                   ARGTYPES_08,
                                                   ARGTYPES_09,
                                                   ARGTYPES_10,
                                                   ARGTYPES_11,
                                                   ARGTYPES_12,
                                                   ARGTYPES_13>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13

#endif


#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class VOID_TYPE, class FN>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class VOID_TYPE, class FN, class ARGTYPES_01>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08,
                                              ARGTYPES_09> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09,
                                     class ARGTYPES_10>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08,
                                              ARGTYPES_09,
                                              ARGTYPES_10> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09,
                                     class ARGTYPES_10,
                                     class ARGTYPES_11>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08,
                                              ARGTYPES_09,
                                              ARGTYPES_10,
                                              ARGTYPES_11> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09,
                                     class ARGTYPES_10,
                                     class ARGTYPES_11,
                                     class ARGTYPES_12>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08,
                                              ARGTYPES_09,
                                              ARGTYPES_10,
                                              ARGTYPES_11,
                                              ARGTYPES_12> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09,
                                     class ARGTYPES_10,
                                     class ARGTYPES_11,
                                     class ARGTYPES_12,
                                     class ARGTYPES_13>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08,
                                              ARGTYPES_09,
                                              ARGTYPES_10,
                                              ARGTYPES_11,
                                              ARGTYPES_12,
                                              ARGTYPES_13> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13


#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class FN>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        ))>::type,
    FN> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()()) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class FN, class ARGTYPES_01>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>()))>::type,
    FN,
    ARGTYPES_01> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>(),
                                     myDeclval<ARGTYPES_03>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>(),
                                     myDeclval<ARGTYPES_03>(),
                                     myDeclval<ARGTYPES_04>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>(),
                                     myDeclval<ARGTYPES_03>(),
                                     myDeclval<ARGTYPES_04>(),
                                     myDeclval<ARGTYPES_05>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>(),
                                     myDeclval<ARGTYPES_03>(),
                                     myDeclval<ARGTYPES_04>(),
                                     myDeclval<ARGTYPES_05>(),
                                     myDeclval<ARGTYPES_06>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>(),
                                     myDeclval<ARGTYPES_03>(),
                                     myDeclval<ARGTYPES_04>(),
                                     myDeclval<ARGTYPES_05>(),
                                     myDeclval<ARGTYPES_06>(),
                                     myDeclval<ARGTYPES_07>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>(),
                                     myDeclval<ARGTYPES_03>(),
                                     myDeclval<ARGTYPES_04>(),
                                     myDeclval<ARGTYPES_05>(),
                                     myDeclval<ARGTYPES_06>(),
                                     myDeclval<ARGTYPES_07>(),
                                     myDeclval<ARGTYPES_08>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>(),
                                     myDeclval<ARGTYPES_03>(),
                                     myDeclval<ARGTYPES_04>(),
                                     myDeclval<ARGTYPES_05>(),
                                     myDeclval<ARGTYPES_06>(),
                                     myDeclval<ARGTYPES_07>(),
                                     myDeclval<ARGTYPES_08>(),
                                     myDeclval<ARGTYPES_09>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_10>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09,
    ARGTYPES_10> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>(),
                                     myDeclval<ARGTYPES_03>(),
                                     myDeclval<ARGTYPES_04>(),
                                     myDeclval<ARGTYPES_05>(),
                                     myDeclval<ARGTYPES_06>(),
                                     myDeclval<ARGTYPES_07>(),
                                     myDeclval<ARGTYPES_08>(),
                                     myDeclval<ARGTYPES_09>(),
                                     myDeclval<ARGTYPES_10>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_10>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_11>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09,
    ARGTYPES_10,
    ARGTYPES_11> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>(),
                                     myDeclval<ARGTYPES_03>(),
                                     myDeclval<ARGTYPES_04>(),
                                     myDeclval<ARGTYPES_05>(),
                                     myDeclval<ARGTYPES_06>(),
                                     myDeclval<ARGTYPES_07>(),
                                     myDeclval<ARGTYPES_08>(),
                                     myDeclval<ARGTYPES_09>(),
                                     myDeclval<ARGTYPES_10>(),
                                     myDeclval<ARGTYPES_11>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11,
                    class ARGTYPES_12>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_10>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_11>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_12>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09,
    ARGTYPES_10,
    ARGTYPES_11,
    ARGTYPES_12> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>(),
                                     myDeclval<ARGTYPES_03>(),
                                     myDeclval<ARGTYPES_04>(),
                                     myDeclval<ARGTYPES_05>(),
                                     myDeclval<ARGTYPES_06>(),
                                     myDeclval<ARGTYPES_07>(),
                                     myDeclval<ARGTYPES_08>(),
                                     myDeclval<ARGTYPES_09>(),
                                     myDeclval<ARGTYPES_10>(),
                                     myDeclval<ARGTYPES_11>(),
                                     myDeclval<ARGTYPES_12>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11,
                    class ARGTYPES_12,
                    class ARGTYPES_13>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_10>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_11>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_12>(),
        InvokeResult_ImpUtils::myDeclval<ARGTYPES_13>()))>::type,
    FN,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09,
    ARGTYPES_10,
    ARGTYPES_11,
    ARGTYPES_12,
    ARGTYPES_13> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES_01>(),
                                     myDeclval<ARGTYPES_02>(),
                                     myDeclval<ARGTYPES_03>(),
                                     myDeclval<ARGTYPES_04>(),
                                     myDeclval<ARGTYPES_05>(),
                                     myDeclval<ARGTYPES_06>(),
                                     myDeclval<ARGTYPES_07>(),
                                     myDeclval<ARGTYPES_08>(),
                                     myDeclval<ARGTYPES_09>(),
                                     myDeclval<ARGTYPES_10>(),
                                     myDeclval<ARGTYPES_11>(),
                                     myDeclval<ARGTYPES_12>(),
                                     myDeclval<ARGTYPES_13>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13

#else
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class VOID_TYPE, class FN>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN> {

    typedef typename
      bslmf::FunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class VOID_TYPE, class FN, class ARGTYPES_01>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01> {

    typedef typename
      bslmf::FunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02> {

    typedef typename
      bslmf::FunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03> {

    typedef typename
      bslmf::FunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04> {

    typedef typename
      bslmf::FunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05> {

    typedef typename
      bslmf::FunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06> {

    typedef typename
      bslmf::FunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07> {

    typedef typename
      bslmf::FunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08> {

    typedef typename
      bslmf::FunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08,
                                              ARGTYPES_09> {

    typedef typename
      bslmf::FunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09,
                                     class ARGTYPES_10>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08,
                                              ARGTYPES_09,
                                              ARGTYPES_10> {

    typedef typename
      bslmf::FunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09,
                                     class ARGTYPES_10,
                                     class ARGTYPES_11>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08,
                                              ARGTYPES_09,
                                              ARGTYPES_10,
                                              ARGTYPES_11> {

    typedef typename
      bslmf::FunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09,
                                     class ARGTYPES_10,
                                     class ARGTYPES_11,
                                     class ARGTYPES_12>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08,
                                              ARGTYPES_09,
                                              ARGTYPES_10,
                                              ARGTYPES_11,
                                              ARGTYPES_12> {

    typedef typename
      bslmf::FunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class VOID_TYPE, class FN, class ARGTYPES_01,
                                     class ARGTYPES_02,
                                     class ARGTYPES_03,
                                     class ARGTYPES_04,
                                     class ARGTYPES_05,
                                     class ARGTYPES_06,
                                     class ARGTYPES_07,
                                     class ARGTYPES_08,
                                     class ARGTYPES_09,
                                     class ARGTYPES_10,
                                     class ARGTYPES_11,
                                     class ARGTYPES_12,
                                     class ARGTYPES_13>
struct InvokeResult_FuncPtrImp<VOID_TYPE, FN, ARGTYPES_01,
                                              ARGTYPES_02,
                                              ARGTYPES_03,
                                              ARGTYPES_04,
                                              ARGTYPES_05,
                                              ARGTYPES_06,
                                              ARGTYPES_07,
                                              ARGTYPES_08,
                                              ARGTYPES_09,
                                              ARGTYPES_10,
                                              ARGTYPES_11,
                                              ARGTYPES_12,
                                              ARGTYPES_13> {

    typedef typename
      bslmf::FunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13

#endif


#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
template <class VOID_TYPE,
          bool ARG1_DERIVES_FROM_CLASS,
          bool ARG1_IS_REFERENCE_WRAPPER,
          class FN,
          class ARG1TYPE
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
        , class ARGTYPES_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
        , class ARGTYPES_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
        , class ARGTYPES_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
        , class ARGTYPES_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
        , class ARGTYPES_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
        , class ARGTYPES_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
        , class ARGTYPES_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
        , class ARGTYPES_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
        , class ARGTYPES_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
        , class ARGTYPES_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
        , class ARGTYPES_10 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
        , class ARGTYPES_11 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
        , class ARGTYPES_12 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
        , class = BSLS_COMPILERFEATURES_NILT>
struct InvokeResult_MemFuncPtrImpDispatch;


template <class FN>
struct InvokeResult_MemFuncPtrImp<FN> {
};

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class FN, class ARG1TYPE>
struct InvokeResult_MemFuncPtrImp<FN, ARG1TYPE>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      InvokeResult_IsBaseOf<
          typename MemberFunctionPointerTraits<FN>::ClassType,
          typename bsl::remove_reference<ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<ARG1TYPE>::type>::type>::value,
      FN,
      ARG1TYPE> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class FN, class ARG1TYPE, class ARGTYPES_01>
struct InvokeResult_MemFuncPtrImp<FN, ARG1TYPE, ARGTYPES_01>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      InvokeResult_IsBaseOf<
          typename MemberFunctionPointerTraits<FN>::ClassType,
          typename bsl::remove_reference<ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<ARG1TYPE>::type>::type>::value,
      FN,
      ARG1TYPE,
      ARGTYPES_01> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02>
struct InvokeResult_MemFuncPtrImp<FN, ARG1TYPE, ARGTYPES_01,
                                                ARGTYPES_02>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      InvokeResult_IsBaseOf<
          typename MemberFunctionPointerTraits<FN>::ClassType,
          typename bsl::remove_reference<ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<ARG1TYPE>::type>::type>::value,
      FN,
      ARG1TYPE,
      ARGTYPES_01,
      ARGTYPES_02> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03>
struct InvokeResult_MemFuncPtrImp<FN, ARG1TYPE, ARGTYPES_01,
                                                ARGTYPES_02,
                                                ARGTYPES_03>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      InvokeResult_IsBaseOf<
          typename MemberFunctionPointerTraits<FN>::ClassType,
          typename bsl::remove_reference<ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<ARG1TYPE>::type>::type>::value,
      FN,
      ARG1TYPE,
      ARGTYPES_01,
      ARGTYPES_02,
      ARGTYPES_03> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04>
struct InvokeResult_MemFuncPtrImp<FN, ARG1TYPE, ARGTYPES_01,
                                                ARGTYPES_02,
                                                ARGTYPES_03,
                                                ARGTYPES_04>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      InvokeResult_IsBaseOf<
          typename MemberFunctionPointerTraits<FN>::ClassType,
          typename bsl::remove_reference<ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<ARG1TYPE>::type>::type>::value,
      FN,
      ARG1TYPE,
      ARGTYPES_01,
      ARGTYPES_02,
      ARGTYPES_03,
      ARGTYPES_04> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05>
struct InvokeResult_MemFuncPtrImp<FN, ARG1TYPE, ARGTYPES_01,
                                                ARGTYPES_02,
                                                ARGTYPES_03,
                                                ARGTYPES_04,
                                                ARGTYPES_05>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      InvokeResult_IsBaseOf<
          typename MemberFunctionPointerTraits<FN>::ClassType,
          typename bsl::remove_reference<ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<ARG1TYPE>::type>::type>::value,
      FN,
      ARG1TYPE,
      ARGTYPES_01,
      ARGTYPES_02,
      ARGTYPES_03,
      ARGTYPES_04,
      ARGTYPES_05> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06>
struct InvokeResult_MemFuncPtrImp<FN, ARG1TYPE, ARGTYPES_01,
                                                ARGTYPES_02,
                                                ARGTYPES_03,
                                                ARGTYPES_04,
                                                ARGTYPES_05,
                                                ARGTYPES_06>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      InvokeResult_IsBaseOf<
          typename MemberFunctionPointerTraits<FN>::ClassType,
          typename bsl::remove_reference<ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<ARG1TYPE>::type>::type>::value,
      FN,
      ARG1TYPE,
      ARGTYPES_01,
      ARGTYPES_02,
      ARGTYPES_03,
      ARGTYPES_04,
      ARGTYPES_05,
      ARGTYPES_06> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07>
struct InvokeResult_MemFuncPtrImp<FN, ARG1TYPE, ARGTYPES_01,
                                                ARGTYPES_02,
                                                ARGTYPES_03,
                                                ARGTYPES_04,
                                                ARGTYPES_05,
                                                ARGTYPES_06,
                                                ARGTYPES_07>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      InvokeResult_IsBaseOf<
          typename MemberFunctionPointerTraits<FN>::ClassType,
          typename bsl::remove_reference<ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<ARG1TYPE>::type>::type>::value,
      FN,
      ARG1TYPE,
      ARGTYPES_01,
      ARGTYPES_02,
      ARGTYPES_03,
      ARGTYPES_04,
      ARGTYPES_05,
      ARGTYPES_06,
      ARGTYPES_07> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08>
struct InvokeResult_MemFuncPtrImp<FN, ARG1TYPE, ARGTYPES_01,
                                                ARGTYPES_02,
                                                ARGTYPES_03,
                                                ARGTYPES_04,
                                                ARGTYPES_05,
                                                ARGTYPES_06,
                                                ARGTYPES_07,
                                                ARGTYPES_08>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      InvokeResult_IsBaseOf<
          typename MemberFunctionPointerTraits<FN>::ClassType,
          typename bsl::remove_reference<ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<ARG1TYPE>::type>::type>::value,
      FN,
      ARG1TYPE,
      ARGTYPES_01,
      ARGTYPES_02,
      ARGTYPES_03,
      ARGTYPES_04,
      ARGTYPES_05,
      ARGTYPES_06,
      ARGTYPES_07,
      ARGTYPES_08> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08,
                                    class ARGTYPES_09>
struct InvokeResult_MemFuncPtrImp<FN, ARG1TYPE, ARGTYPES_01,
                                                ARGTYPES_02,
                                                ARGTYPES_03,
                                                ARGTYPES_04,
                                                ARGTYPES_05,
                                                ARGTYPES_06,
                                                ARGTYPES_07,
                                                ARGTYPES_08,
                                                ARGTYPES_09>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      InvokeResult_IsBaseOf<
          typename MemberFunctionPointerTraits<FN>::ClassType,
          typename bsl::remove_reference<ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<ARG1TYPE>::type>::type>::value,
      FN,
      ARG1TYPE,
      ARGTYPES_01,
      ARGTYPES_02,
      ARGTYPES_03,
      ARGTYPES_04,
      ARGTYPES_05,
      ARGTYPES_06,
      ARGTYPES_07,
      ARGTYPES_08,
      ARGTYPES_09> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08,
                                    class ARGTYPES_09,
                                    class ARGTYPES_10>
struct InvokeResult_MemFuncPtrImp<FN, ARG1TYPE, ARGTYPES_01,
                                                ARGTYPES_02,
                                                ARGTYPES_03,
                                                ARGTYPES_04,
                                                ARGTYPES_05,
                                                ARGTYPES_06,
                                                ARGTYPES_07,
                                                ARGTYPES_08,
                                                ARGTYPES_09,
                                                ARGTYPES_10>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      InvokeResult_IsBaseOf<
          typename MemberFunctionPointerTraits<FN>::ClassType,
          typename bsl::remove_reference<ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<ARG1TYPE>::type>::type>::value,
      FN,
      ARG1TYPE,
      ARGTYPES_01,
      ARGTYPES_02,
      ARGTYPES_03,
      ARGTYPES_04,
      ARGTYPES_05,
      ARGTYPES_06,
      ARGTYPES_07,
      ARGTYPES_08,
      ARGTYPES_09,
      ARGTYPES_10> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08,
                                    class ARGTYPES_09,
                                    class ARGTYPES_10,
                                    class ARGTYPES_11>
struct InvokeResult_MemFuncPtrImp<FN, ARG1TYPE, ARGTYPES_01,
                                                ARGTYPES_02,
                                                ARGTYPES_03,
                                                ARGTYPES_04,
                                                ARGTYPES_05,
                                                ARGTYPES_06,
                                                ARGTYPES_07,
                                                ARGTYPES_08,
                                                ARGTYPES_09,
                                                ARGTYPES_10,
                                                ARGTYPES_11>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      InvokeResult_IsBaseOf<
          typename MemberFunctionPointerTraits<FN>::ClassType,
          typename bsl::remove_reference<ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<ARG1TYPE>::type>::type>::value,
      FN,
      ARG1TYPE,
      ARGTYPES_01,
      ARGTYPES_02,
      ARGTYPES_03,
      ARGTYPES_04,
      ARGTYPES_05,
      ARGTYPES_06,
      ARGTYPES_07,
      ARGTYPES_08,
      ARGTYPES_09,
      ARGTYPES_10,
      ARGTYPES_11> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08,
                                    class ARGTYPES_09,
                                    class ARGTYPES_10,
                                    class ARGTYPES_11,
                                    class ARGTYPES_12>
struct InvokeResult_MemFuncPtrImp<FN, ARG1TYPE, ARGTYPES_01,
                                                ARGTYPES_02,
                                                ARGTYPES_03,
                                                ARGTYPES_04,
                                                ARGTYPES_05,
                                                ARGTYPES_06,
                                                ARGTYPES_07,
                                                ARGTYPES_08,
                                                ARGTYPES_09,
                                                ARGTYPES_10,
                                                ARGTYPES_11,
                                                ARGTYPES_12>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      InvokeResult_IsBaseOf<
          typename MemberFunctionPointerTraits<FN>::ClassType,
          typename bsl::remove_reference<ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<ARG1TYPE>::type>::type>::value,
      FN,
      ARG1TYPE,
      ARGTYPES_01,
      ARGTYPES_02,
      ARGTYPES_03,
      ARGTYPES_04,
      ARGTYPES_05,
      ARGTYPES_06,
      ARGTYPES_07,
      ARGTYPES_08,
      ARGTYPES_09,
      ARGTYPES_10,
      ARGTYPES_11,
      ARGTYPES_12> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08,
                                    class ARGTYPES_09,
                                    class ARGTYPES_10,
                                    class ARGTYPES_11,
                                    class ARGTYPES_12,
                                    class ARGTYPES_13>
struct InvokeResult_MemFuncPtrImp<FN, ARG1TYPE, ARGTYPES_01,
                                                ARGTYPES_02,
                                                ARGTYPES_03,
                                                ARGTYPES_04,
                                                ARGTYPES_05,
                                                ARGTYPES_06,
                                                ARGTYPES_07,
                                                ARGTYPES_08,
                                                ARGTYPES_09,
                                                ARGTYPES_10,
                                                ARGTYPES_11,
                                                ARGTYPES_12,
                                                ARGTYPES_13>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      InvokeResult_IsBaseOf<
          typename MemberFunctionPointerTraits<FN>::ClassType,
          typename bsl::remove_reference<ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<ARG1TYPE>::type>::type>::value,
      FN,
      ARG1TYPE,
      ARGTYPES_01,
      ARGTYPES_02,
      ARGTYPES_03,
      ARGTYPES_04,
      ARGTYPES_05,
      ARGTYPES_06,
      ARGTYPES_07,
      ARGTYPES_08,
      ARGTYPES_09,
      ARGTYPES_10,
      ARGTYPES_11,
      ARGTYPES_12,
      ARGTYPES_13> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13

#else
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class FN>
struct InvokeResult_MemFuncPtrImp<FN> {

    typedef typename MemberFunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class FN, class ARGTYPES_01>
struct InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01> {

    typedef typename MemberFunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02>
struct InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02> {

    typedef typename MemberFunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03>
struct InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02,
                                      ARGTYPES_03> {

    typedef typename MemberFunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04>
struct InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02,
                                      ARGTYPES_03,
                                      ARGTYPES_04> {

    typedef typename MemberFunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05>
struct InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02,
                                      ARGTYPES_03,
                                      ARGTYPES_04,
                                      ARGTYPES_05> {

    typedef typename MemberFunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06>
struct InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02,
                                      ARGTYPES_03,
                                      ARGTYPES_04,
                                      ARGTYPES_05,
                                      ARGTYPES_06> {

    typedef typename MemberFunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07>
struct InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02,
                                      ARGTYPES_03,
                                      ARGTYPES_04,
                                      ARGTYPES_05,
                                      ARGTYPES_06,
                                      ARGTYPES_07> {

    typedef typename MemberFunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08>
struct InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02,
                                      ARGTYPES_03,
                                      ARGTYPES_04,
                                      ARGTYPES_05,
                                      ARGTYPES_06,
                                      ARGTYPES_07,
                                      ARGTYPES_08> {

    typedef typename MemberFunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09>
struct InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02,
                                      ARGTYPES_03,
                                      ARGTYPES_04,
                                      ARGTYPES_05,
                                      ARGTYPES_06,
                                      ARGTYPES_07,
                                      ARGTYPES_08,
                                      ARGTYPES_09> {

    typedef typename MemberFunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10>
struct InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02,
                                      ARGTYPES_03,
                                      ARGTYPES_04,
                                      ARGTYPES_05,
                                      ARGTYPES_06,
                                      ARGTYPES_07,
                                      ARGTYPES_08,
                                      ARGTYPES_09,
                                      ARGTYPES_10> {

    typedef typename MemberFunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11>
struct InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02,
                                      ARGTYPES_03,
                                      ARGTYPES_04,
                                      ARGTYPES_05,
                                      ARGTYPES_06,
                                      ARGTYPES_07,
                                      ARGTYPES_08,
                                      ARGTYPES_09,
                                      ARGTYPES_10,
                                      ARGTYPES_11> {

    typedef typename MemberFunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11,
                    class ARGTYPES_12>
struct InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02,
                                      ARGTYPES_03,
                                      ARGTYPES_04,
                                      ARGTYPES_05,
                                      ARGTYPES_06,
                                      ARGTYPES_07,
                                      ARGTYPES_08,
                                      ARGTYPES_09,
                                      ARGTYPES_10,
                                      ARGTYPES_11,
                                      ARGTYPES_12> {

    typedef typename MemberFunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11,
                    class ARGTYPES_12,
                    class ARGTYPES_13>
struct InvokeResult_MemFuncPtrImp<FN, ARGTYPES_01,
                                      ARGTYPES_02,
                                      ARGTYPES_03,
                                      ARGTYPES_04,
                                      ARGTYPES_05,
                                      ARGTYPES_06,
                                      ARGTYPES_07,
                                      ARGTYPES_08,
                                      ARGTYPES_09,
                                      ARGTYPES_10,
                                      ARGTYPES_11,
                                      ARGTYPES_12,
                                      ARGTYPES_13> {

    typedef typename MemberFunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13

#endif


#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class VOID_TYPE, bool ARG1_DERIVES_FROM_CLASS,
          bool ARG1_IS_REFERENCE_WRAPPER, class FN, class ARG1TYPE>
struct InvokeResult_MemFuncPtrImpDispatch<VOID_TYPE, ARG1_DERIVES_FROM_CLASS, ARG1_IS_REFERENCE_WRAPPER, FN, ARG1TYPE> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class VOID_TYPE, bool ARG1_DERIVES_FROM_CLASS,
          bool ARG1_IS_REFERENCE_WRAPPER, class FN, class ARG1TYPE,
          class ARGTYPES_01>
struct InvokeResult_MemFuncPtrImpDispatch<VOID_TYPE, ARG1_DERIVES_FROM_CLASS, ARG1_IS_REFERENCE_WRAPPER, FN, ARG1TYPE,
                                                                 ARGTYPES_01> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class VOID_TYPE, bool ARG1_DERIVES_FROM_CLASS,
          bool ARG1_IS_REFERENCE_WRAPPER, class FN, class ARG1TYPE,
          class ARGTYPES_01,
          class ARGTYPES_02>
struct InvokeResult_MemFuncPtrImpDispatch<VOID_TYPE, ARG1_DERIVES_FROM_CLASS, ARG1_IS_REFERENCE_WRAPPER, FN, ARG1TYPE,
                                                                 ARGTYPES_01,
                                                                 ARGTYPES_02> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class VOID_TYPE, bool ARG1_DERIVES_FROM_CLASS,
          bool ARG1_IS_REFERENCE_WRAPPER, class FN, class ARG1TYPE,
          class ARGTYPES_01,
          class ARGTYPES_02,
          class ARGTYPES_03>
struct InvokeResult_MemFuncPtrImpDispatch<VOID_TYPE, ARG1_DERIVES_FROM_CLASS, ARG1_IS_REFERENCE_WRAPPER, FN, ARG1TYPE,
                                                                 ARGTYPES_01,
                                                                 ARGTYPES_02,
                                                                 ARGTYPES_03> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class VOID_TYPE, bool ARG1_DERIVES_FROM_CLASS,
          bool ARG1_IS_REFERENCE_WRAPPER, class FN, class ARG1TYPE,
          class ARGTYPES_01,
          class ARGTYPES_02,
          class ARGTYPES_03,
          class ARGTYPES_04>
struct InvokeResult_MemFuncPtrImpDispatch<VOID_TYPE, ARG1_DERIVES_FROM_CLASS, ARG1_IS_REFERENCE_WRAPPER, FN, ARG1TYPE,
                                                                 ARGTYPES_01,
                                                                 ARGTYPES_02,
                                                                 ARGTYPES_03,
                                                                 ARGTYPES_04> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class VOID_TYPE, bool ARG1_DERIVES_FROM_CLASS,
          bool ARG1_IS_REFERENCE_WRAPPER, class FN, class ARG1TYPE,
          class ARGTYPES_01,
          class ARGTYPES_02,
          class ARGTYPES_03,
          class ARGTYPES_04,
          class ARGTYPES_05>
struct InvokeResult_MemFuncPtrImpDispatch<VOID_TYPE, ARG1_DERIVES_FROM_CLASS, ARG1_IS_REFERENCE_WRAPPER, FN, ARG1TYPE,
                                                                 ARGTYPES_01,
                                                                 ARGTYPES_02,
                                                                 ARGTYPES_03,
                                                                 ARGTYPES_04,
                                                                 ARGTYPES_05> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class VOID_TYPE, bool ARG1_DERIVES_FROM_CLASS,
          bool ARG1_IS_REFERENCE_WRAPPER, class FN, class ARG1TYPE,
          class ARGTYPES_01,
          class ARGTYPES_02,
          class ARGTYPES_03,
          class ARGTYPES_04,
          class ARGTYPES_05,
          class ARGTYPES_06>
struct InvokeResult_MemFuncPtrImpDispatch<VOID_TYPE, ARG1_DERIVES_FROM_CLASS, ARG1_IS_REFERENCE_WRAPPER, FN, ARG1TYPE,
                                                                 ARGTYPES_01,
                                                                 ARGTYPES_02,
                                                                 ARGTYPES_03,
                                                                 ARGTYPES_04,
                                                                 ARGTYPES_05,
                                                                 ARGTYPES_06> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class VOID_TYPE, bool ARG1_DERIVES_FROM_CLASS,
          bool ARG1_IS_REFERENCE_WRAPPER, class FN, class ARG1TYPE,
          class ARGTYPES_01,
          class ARGTYPES_02,
          class ARGTYPES_03,
          class ARGTYPES_04,
          class ARGTYPES_05,
          class ARGTYPES_06,
          class ARGTYPES_07>
struct InvokeResult_MemFuncPtrImpDispatch<VOID_TYPE, ARG1_DERIVES_FROM_CLASS, ARG1_IS_REFERENCE_WRAPPER, FN, ARG1TYPE,
                                                                 ARGTYPES_01,
                                                                 ARGTYPES_02,
                                                                 ARGTYPES_03,
                                                                 ARGTYPES_04,
                                                                 ARGTYPES_05,
                                                                 ARGTYPES_06,
                                                                 ARGTYPES_07> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class VOID_TYPE, bool ARG1_DERIVES_FROM_CLASS,
          bool ARG1_IS_REFERENCE_WRAPPER, class FN, class ARG1TYPE,
          class ARGTYPES_01,
          class ARGTYPES_02,
          class ARGTYPES_03,
          class ARGTYPES_04,
          class ARGTYPES_05,
          class ARGTYPES_06,
          class ARGTYPES_07,
          class ARGTYPES_08>
struct InvokeResult_MemFuncPtrImpDispatch<VOID_TYPE, ARG1_DERIVES_FROM_CLASS, ARG1_IS_REFERENCE_WRAPPER, FN, ARG1TYPE,
                                                                 ARGTYPES_01,
                                                                 ARGTYPES_02,
                                                                 ARGTYPES_03,
                                                                 ARGTYPES_04,
                                                                 ARGTYPES_05,
                                                                 ARGTYPES_06,
                                                                 ARGTYPES_07,
                                                                 ARGTYPES_08> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class VOID_TYPE, bool ARG1_DERIVES_FROM_CLASS,
          bool ARG1_IS_REFERENCE_WRAPPER, class FN, class ARG1TYPE,
          class ARGTYPES_01,
          class ARGTYPES_02,
          class ARGTYPES_03,
          class ARGTYPES_04,
          class ARGTYPES_05,
          class ARGTYPES_06,
          class ARGTYPES_07,
          class ARGTYPES_08,
          class ARGTYPES_09>
struct InvokeResult_MemFuncPtrImpDispatch<VOID_TYPE, ARG1_DERIVES_FROM_CLASS, ARG1_IS_REFERENCE_WRAPPER, FN, ARG1TYPE,
                                                                 ARGTYPES_01,
                                                                 ARGTYPES_02,
                                                                 ARGTYPES_03,
                                                                 ARGTYPES_04,
                                                                 ARGTYPES_05,
                                                                 ARGTYPES_06,
                                                                 ARGTYPES_07,
                                                                 ARGTYPES_08,
                                                                 ARGTYPES_09> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class VOID_TYPE, bool ARG1_DERIVES_FROM_CLASS,
          bool ARG1_IS_REFERENCE_WRAPPER, class FN, class ARG1TYPE,
          class ARGTYPES_01,
          class ARGTYPES_02,
          class ARGTYPES_03,
          class ARGTYPES_04,
          class ARGTYPES_05,
          class ARGTYPES_06,
          class ARGTYPES_07,
          class ARGTYPES_08,
          class ARGTYPES_09,
          class ARGTYPES_10>
struct InvokeResult_MemFuncPtrImpDispatch<VOID_TYPE, ARG1_DERIVES_FROM_CLASS, ARG1_IS_REFERENCE_WRAPPER, FN, ARG1TYPE,
                                                                 ARGTYPES_01,
                                                                 ARGTYPES_02,
                                                                 ARGTYPES_03,
                                                                 ARGTYPES_04,
                                                                 ARGTYPES_05,
                                                                 ARGTYPES_06,
                                                                 ARGTYPES_07,
                                                                 ARGTYPES_08,
                                                                 ARGTYPES_09,
                                                                 ARGTYPES_10> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class VOID_TYPE, bool ARG1_DERIVES_FROM_CLASS,
          bool ARG1_IS_REFERENCE_WRAPPER, class FN, class ARG1TYPE,
          class ARGTYPES_01,
          class ARGTYPES_02,
          class ARGTYPES_03,
          class ARGTYPES_04,
          class ARGTYPES_05,
          class ARGTYPES_06,
          class ARGTYPES_07,
          class ARGTYPES_08,
          class ARGTYPES_09,
          class ARGTYPES_10,
          class ARGTYPES_11>
struct InvokeResult_MemFuncPtrImpDispatch<VOID_TYPE, ARG1_DERIVES_FROM_CLASS, ARG1_IS_REFERENCE_WRAPPER, FN, ARG1TYPE,
                                                                 ARGTYPES_01,
                                                                 ARGTYPES_02,
                                                                 ARGTYPES_03,
                                                                 ARGTYPES_04,
                                                                 ARGTYPES_05,
                                                                 ARGTYPES_06,
                                                                 ARGTYPES_07,
                                                                 ARGTYPES_08,
                                                                 ARGTYPES_09,
                                                                 ARGTYPES_10,
                                                                 ARGTYPES_11> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class VOID_TYPE, bool ARG1_DERIVES_FROM_CLASS,
          bool ARG1_IS_REFERENCE_WRAPPER, class FN, class ARG1TYPE,
          class ARGTYPES_01,
          class ARGTYPES_02,
          class ARGTYPES_03,
          class ARGTYPES_04,
          class ARGTYPES_05,
          class ARGTYPES_06,
          class ARGTYPES_07,
          class ARGTYPES_08,
          class ARGTYPES_09,
          class ARGTYPES_10,
          class ARGTYPES_11,
          class ARGTYPES_12>
struct InvokeResult_MemFuncPtrImpDispatch<VOID_TYPE, ARG1_DERIVES_FROM_CLASS, ARG1_IS_REFERENCE_WRAPPER, FN, ARG1TYPE,
                                                                 ARGTYPES_01,
                                                                 ARGTYPES_02,
                                                                 ARGTYPES_03,
                                                                 ARGTYPES_04,
                                                                 ARGTYPES_05,
                                                                 ARGTYPES_06,
                                                                 ARGTYPES_07,
                                                                 ARGTYPES_08,
                                                                 ARGTYPES_09,
                                                                 ARGTYPES_10,
                                                                 ARGTYPES_11,
                                                                 ARGTYPES_12> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class VOID_TYPE, bool ARG1_DERIVES_FROM_CLASS,
          bool ARG1_IS_REFERENCE_WRAPPER, class FN, class ARG1TYPE,
          class ARGTYPES_01,
          class ARGTYPES_02,
          class ARGTYPES_03,
          class ARGTYPES_04,
          class ARGTYPES_05,
          class ARGTYPES_06,
          class ARGTYPES_07,
          class ARGTYPES_08,
          class ARGTYPES_09,
          class ARGTYPES_10,
          class ARGTYPES_11,
          class ARGTYPES_12,
          class ARGTYPES_13>
struct InvokeResult_MemFuncPtrImpDispatch<VOID_TYPE, ARG1_DERIVES_FROM_CLASS, ARG1_IS_REFERENCE_WRAPPER, FN, ARG1TYPE,
                                                                 ARGTYPES_01,
                                                                 ARGTYPES_02,
                                                                 ARGTYPES_03,
                                                                 ARGTYPES_04,
                                                                 ARGTYPES_05,
                                                                 ARGTYPES_06,
                                                                 ARGTYPES_07,
                                                                 ARGTYPES_08,
                                                                 ARGTYPES_09,
                                                                 ARGTYPES_10,
                                                                 ARGTYPES_11,
                                                                 ARGTYPES_12,
                                                                 ARGTYPES_13> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13


#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class FN, class ARG1TYPE>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        ((*InvokeResult_ImpUtils::myDeclval<ARG1TYPE>()).*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            ))>::type,
false,
false,
    FN,
    ARG1TYPE> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<ARG1TYPE>()).*
                      myDeclval<FN>())()) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class FN, class ARG1TYPE, class ARGTYPES_01>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        ((*InvokeResult_ImpUtils::myDeclval<ARG1TYPE>()).*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>()))>::type,
false,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<ARG1TYPE>()).*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        ((*InvokeResult_ImpUtils::myDeclval<ARG1TYPE>()).*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>()))>::type,
false,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<ARG1TYPE>()).*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        ((*InvokeResult_ImpUtils::myDeclval<ARG1TYPE>()).*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>()))>::type,
false,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<ARG1TYPE>()).*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>(),
                                       myDeclval<ARGTYPES_03>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        ((*InvokeResult_ImpUtils::myDeclval<ARG1TYPE>()).*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>()))>::type,
false,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<ARG1TYPE>()).*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>(),
                                       myDeclval<ARGTYPES_03>(),
                                       myDeclval<ARGTYPES_04>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        ((*InvokeResult_ImpUtils::myDeclval<ARG1TYPE>()).*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>()))>::type,
false,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<ARG1TYPE>()).*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>(),
                                       myDeclval<ARGTYPES_03>(),
                                       myDeclval<ARGTYPES_04>(),
                                       myDeclval<ARGTYPES_05>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        ((*InvokeResult_ImpUtils::myDeclval<ARG1TYPE>()).*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>()))>::type,
false,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<ARG1TYPE>()).*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>(),
                                       myDeclval<ARGTYPES_03>(),
                                       myDeclval<ARGTYPES_04>(),
                                       myDeclval<ARGTYPES_05>(),
                                       myDeclval<ARGTYPES_06>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        ((*InvokeResult_ImpUtils::myDeclval<ARG1TYPE>()).*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>()))>::type,
false,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<ARG1TYPE>()).*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>(),
                                       myDeclval<ARGTYPES_03>(),
                                       myDeclval<ARGTYPES_04>(),
                                       myDeclval<ARGTYPES_05>(),
                                       myDeclval<ARGTYPES_06>(),
                                       myDeclval<ARGTYPES_07>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        ((*InvokeResult_ImpUtils::myDeclval<ARG1TYPE>()).*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>()))>::type,
false,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<ARG1TYPE>()).*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>(),
                                       myDeclval<ARGTYPES_03>(),
                                       myDeclval<ARGTYPES_04>(),
                                       myDeclval<ARGTYPES_05>(),
                                       myDeclval<ARGTYPES_06>(),
                                       myDeclval<ARGTYPES_07>(),
                                       myDeclval<ARGTYPES_08>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08,
                                    class ARGTYPES_09>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        ((*InvokeResult_ImpUtils::myDeclval<ARG1TYPE>()).*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>()))>::type,
false,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<ARG1TYPE>()).*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>(),
                                       myDeclval<ARGTYPES_03>(),
                                       myDeclval<ARGTYPES_04>(),
                                       myDeclval<ARGTYPES_05>(),
                                       myDeclval<ARGTYPES_06>(),
                                       myDeclval<ARGTYPES_07>(),
                                       myDeclval<ARGTYPES_08>(),
                                       myDeclval<ARGTYPES_09>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08,
                                    class ARGTYPES_09,
                                    class ARGTYPES_10>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        ((*InvokeResult_ImpUtils::myDeclval<ARG1TYPE>()).*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_10>()))>::type,
false,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09,
    ARGTYPES_10> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<ARG1TYPE>()).*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>(),
                                       myDeclval<ARGTYPES_03>(),
                                       myDeclval<ARGTYPES_04>(),
                                       myDeclval<ARGTYPES_05>(),
                                       myDeclval<ARGTYPES_06>(),
                                       myDeclval<ARGTYPES_07>(),
                                       myDeclval<ARGTYPES_08>(),
                                       myDeclval<ARGTYPES_09>(),
                                       myDeclval<ARGTYPES_10>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08,
                                    class ARGTYPES_09,
                                    class ARGTYPES_10,
                                    class ARGTYPES_11>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        ((*InvokeResult_ImpUtils::myDeclval<ARG1TYPE>()).*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_10>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_11>()))>::type,
false,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09,
    ARGTYPES_10,
    ARGTYPES_11> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<ARG1TYPE>()).*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>(),
                                       myDeclval<ARGTYPES_03>(),
                                       myDeclval<ARGTYPES_04>(),
                                       myDeclval<ARGTYPES_05>(),
                                       myDeclval<ARGTYPES_06>(),
                                       myDeclval<ARGTYPES_07>(),
                                       myDeclval<ARGTYPES_08>(),
                                       myDeclval<ARGTYPES_09>(),
                                       myDeclval<ARGTYPES_10>(),
                                       myDeclval<ARGTYPES_11>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08,
                                    class ARGTYPES_09,
                                    class ARGTYPES_10,
                                    class ARGTYPES_11,
                                    class ARGTYPES_12>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        ((*InvokeResult_ImpUtils::myDeclval<ARG1TYPE>()).*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_10>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_11>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_12>()))>::type,
false,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09,
    ARGTYPES_10,
    ARGTYPES_11,
    ARGTYPES_12> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<ARG1TYPE>()).*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>(),
                                       myDeclval<ARGTYPES_03>(),
                                       myDeclval<ARGTYPES_04>(),
                                       myDeclval<ARGTYPES_05>(),
                                       myDeclval<ARGTYPES_06>(),
                                       myDeclval<ARGTYPES_07>(),
                                       myDeclval<ARGTYPES_08>(),
                                       myDeclval<ARGTYPES_09>(),
                                       myDeclval<ARGTYPES_10>(),
                                       myDeclval<ARGTYPES_11>(),
                                       myDeclval<ARGTYPES_12>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08,
                                    class ARGTYPES_09,
                                    class ARGTYPES_10,
                                    class ARGTYPES_11,
                                    class ARGTYPES_12,
                                    class ARGTYPES_13>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        ((*InvokeResult_ImpUtils::myDeclval<ARG1TYPE>()).*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_10>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_11>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_12>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_13>()))>::type,
false,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09,
    ARGTYPES_10,
    ARGTYPES_11,
    ARGTYPES_12,
    ARGTYPES_13> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<ARG1TYPE>()).*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>(),
                                       myDeclval<ARGTYPES_03>(),
                                       myDeclval<ARGTYPES_04>(),
                                       myDeclval<ARGTYPES_05>(),
                                       myDeclval<ARGTYPES_06>(),
                                       myDeclval<ARGTYPES_07>(),
                                       myDeclval<ARGTYPES_08>(),
                                       myDeclval<ARGTYPES_09>(),
                                       myDeclval<ARGTYPES_10>(),
                                       myDeclval<ARGTYPES_11>(),
                                       myDeclval<ARGTYPES_12>(),
                                       myDeclval<ARGTYPES_13>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13


#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class FN, class ARG1TYPE>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            ))>::type,
true,
false,
    FN,
    ARG1TYPE> : InvokeResult_ImpUtils {

    typedef decltype(
     (myDeclval<ARG1TYPE>().*myDeclval<FN>())()) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class FN, class ARG1TYPE, class ARGTYPES_01>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>()))>::type,
true,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01> : InvokeResult_ImpUtils {

    typedef decltype(
     (myDeclval<ARG1TYPE>().*myDeclval<FN>())(myDeclval<ARGTYPES_01>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>()))>::type,
true,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02> : InvokeResult_ImpUtils {

    typedef decltype(
     (myDeclval<ARG1TYPE>().*myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>()))>::type,
true,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03> : InvokeResult_ImpUtils {

    typedef decltype(
     (myDeclval<ARG1TYPE>().*myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>(),
                                              myDeclval<ARGTYPES_03>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>()))>::type,
true,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04> : InvokeResult_ImpUtils {

    typedef decltype(
     (myDeclval<ARG1TYPE>().*myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>(),
                                              myDeclval<ARGTYPES_03>(),
                                              myDeclval<ARGTYPES_04>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>()))>::type,
true,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05> : InvokeResult_ImpUtils {

    typedef decltype(
     (myDeclval<ARG1TYPE>().*myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>(),
                                              myDeclval<ARGTYPES_03>(),
                                              myDeclval<ARGTYPES_04>(),
                                              myDeclval<ARGTYPES_05>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>()))>::type,
true,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06> : InvokeResult_ImpUtils {

    typedef decltype(
     (myDeclval<ARG1TYPE>().*myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>(),
                                              myDeclval<ARGTYPES_03>(),
                                              myDeclval<ARGTYPES_04>(),
                                              myDeclval<ARGTYPES_05>(),
                                              myDeclval<ARGTYPES_06>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>()))>::type,
true,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07> : InvokeResult_ImpUtils {

    typedef decltype(
     (myDeclval<ARG1TYPE>().*myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>(),
                                              myDeclval<ARGTYPES_03>(),
                                              myDeclval<ARGTYPES_04>(),
                                              myDeclval<ARGTYPES_05>(),
                                              myDeclval<ARGTYPES_06>(),
                                              myDeclval<ARGTYPES_07>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>()))>::type,
true,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08> : InvokeResult_ImpUtils {

    typedef decltype(
     (myDeclval<ARG1TYPE>().*myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>(),
                                              myDeclval<ARGTYPES_03>(),
                                              myDeclval<ARGTYPES_04>(),
                                              myDeclval<ARGTYPES_05>(),
                                              myDeclval<ARGTYPES_06>(),
                                              myDeclval<ARGTYPES_07>(),
                                              myDeclval<ARGTYPES_08>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08,
                                    class ARGTYPES_09>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>()))>::type,
true,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09> : InvokeResult_ImpUtils {

    typedef decltype(
     (myDeclval<ARG1TYPE>().*myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>(),
                                              myDeclval<ARGTYPES_03>(),
                                              myDeclval<ARGTYPES_04>(),
                                              myDeclval<ARGTYPES_05>(),
                                              myDeclval<ARGTYPES_06>(),
                                              myDeclval<ARGTYPES_07>(),
                                              myDeclval<ARGTYPES_08>(),
                                              myDeclval<ARGTYPES_09>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08,
                                    class ARGTYPES_09,
                                    class ARGTYPES_10>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_10>()))>::type,
true,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09,
    ARGTYPES_10> : InvokeResult_ImpUtils {

    typedef decltype(
     (myDeclval<ARG1TYPE>().*myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>(),
                                              myDeclval<ARGTYPES_03>(),
                                              myDeclval<ARGTYPES_04>(),
                                              myDeclval<ARGTYPES_05>(),
                                              myDeclval<ARGTYPES_06>(),
                                              myDeclval<ARGTYPES_07>(),
                                              myDeclval<ARGTYPES_08>(),
                                              myDeclval<ARGTYPES_09>(),
                                              myDeclval<ARGTYPES_10>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08,
                                    class ARGTYPES_09,
                                    class ARGTYPES_10,
                                    class ARGTYPES_11>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_10>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_11>()))>::type,
true,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09,
    ARGTYPES_10,
    ARGTYPES_11> : InvokeResult_ImpUtils {

    typedef decltype(
     (myDeclval<ARG1TYPE>().*myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>(),
                                              myDeclval<ARGTYPES_03>(),
                                              myDeclval<ARGTYPES_04>(),
                                              myDeclval<ARGTYPES_05>(),
                                              myDeclval<ARGTYPES_06>(),
                                              myDeclval<ARGTYPES_07>(),
                                              myDeclval<ARGTYPES_08>(),
                                              myDeclval<ARGTYPES_09>(),
                                              myDeclval<ARGTYPES_10>(),
                                              myDeclval<ARGTYPES_11>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08,
                                    class ARGTYPES_09,
                                    class ARGTYPES_10,
                                    class ARGTYPES_11,
                                    class ARGTYPES_12>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_10>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_11>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_12>()))>::type,
true,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09,
    ARGTYPES_10,
    ARGTYPES_11,
    ARGTYPES_12> : InvokeResult_ImpUtils {

    typedef decltype(
     (myDeclval<ARG1TYPE>().*myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>(),
                                              myDeclval<ARGTYPES_03>(),
                                              myDeclval<ARGTYPES_04>(),
                                              myDeclval<ARGTYPES_05>(),
                                              myDeclval<ARGTYPES_06>(),
                                              myDeclval<ARGTYPES_07>(),
                                              myDeclval<ARGTYPES_08>(),
                                              myDeclval<ARGTYPES_09>(),
                                              myDeclval<ARGTYPES_10>(),
                                              myDeclval<ARGTYPES_11>(),
                                              myDeclval<ARGTYPES_12>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08,
                                    class ARGTYPES_09,
                                    class ARGTYPES_10,
                                    class ARGTYPES_11,
                                    class ARGTYPES_12,
                                    class ARGTYPES_13>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_10>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_11>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_12>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_13>()))>::type,
true,
false,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09,
    ARGTYPES_10,
    ARGTYPES_11,
    ARGTYPES_12,
    ARGTYPES_13> : InvokeResult_ImpUtils {

    typedef decltype(
     (myDeclval<ARG1TYPE>().*myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                              myDeclval<ARGTYPES_02>(),
                                              myDeclval<ARGTYPES_03>(),
                                              myDeclval<ARGTYPES_04>(),
                                              myDeclval<ARGTYPES_05>(),
                                              myDeclval<ARGTYPES_06>(),
                                              myDeclval<ARGTYPES_07>(),
                                              myDeclval<ARGTYPES_08>(),
                                              myDeclval<ARGTYPES_09>(),
                                              myDeclval<ARGTYPES_10>(),
                                              myDeclval<ARGTYPES_11>(),
                                              myDeclval<ARGTYPES_12>(),
                                              myDeclval<ARGTYPES_13>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13


#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class FN, class ARG1TYPE>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().get().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            ))>::type,
false,
true,
    FN,
    ARG1TYPE> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<ARG1TYPE>().get().*
                      myDeclval<FN>())()) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class FN, class ARG1TYPE, class ARGTYPES_01>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().get().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>()))>::type,
false,
true,
    FN,
    ARG1TYPE,
    ARGTYPES_01> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<ARG1TYPE>().get().*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().get().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>()))>::type,
false,
true,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<ARG1TYPE>().get().*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().get().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>()))>::type,
false,
true,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<ARG1TYPE>().get().*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>(),
                                       myDeclval<ARGTYPES_03>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().get().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>()))>::type,
false,
true,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<ARG1TYPE>().get().*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>(),
                                       myDeclval<ARGTYPES_03>(),
                                       myDeclval<ARGTYPES_04>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().get().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>()))>::type,
false,
true,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<ARG1TYPE>().get().*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>(),
                                       myDeclval<ARGTYPES_03>(),
                                       myDeclval<ARGTYPES_04>(),
                                       myDeclval<ARGTYPES_05>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().get().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>()))>::type,
false,
true,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<ARG1TYPE>().get().*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>(),
                                       myDeclval<ARGTYPES_03>(),
                                       myDeclval<ARGTYPES_04>(),
                                       myDeclval<ARGTYPES_05>(),
                                       myDeclval<ARGTYPES_06>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().get().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>()))>::type,
false,
true,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<ARG1TYPE>().get().*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>(),
                                       myDeclval<ARGTYPES_03>(),
                                       myDeclval<ARGTYPES_04>(),
                                       myDeclval<ARGTYPES_05>(),
                                       myDeclval<ARGTYPES_06>(),
                                       myDeclval<ARGTYPES_07>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().get().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>()))>::type,
false,
true,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<ARG1TYPE>().get().*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>(),
                                       myDeclval<ARGTYPES_03>(),
                                       myDeclval<ARGTYPES_04>(),
                                       myDeclval<ARGTYPES_05>(),
                                       myDeclval<ARGTYPES_06>(),
                                       myDeclval<ARGTYPES_07>(),
                                       myDeclval<ARGTYPES_08>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08,
                                    class ARGTYPES_09>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().get().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>()))>::type,
false,
true,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<ARG1TYPE>().get().*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>(),
                                       myDeclval<ARGTYPES_03>(),
                                       myDeclval<ARGTYPES_04>(),
                                       myDeclval<ARGTYPES_05>(),
                                       myDeclval<ARGTYPES_06>(),
                                       myDeclval<ARGTYPES_07>(),
                                       myDeclval<ARGTYPES_08>(),
                                       myDeclval<ARGTYPES_09>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08,
                                    class ARGTYPES_09,
                                    class ARGTYPES_10>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().get().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_10>()))>::type,
false,
true,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09,
    ARGTYPES_10> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<ARG1TYPE>().get().*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>(),
                                       myDeclval<ARGTYPES_03>(),
                                       myDeclval<ARGTYPES_04>(),
                                       myDeclval<ARGTYPES_05>(),
                                       myDeclval<ARGTYPES_06>(),
                                       myDeclval<ARGTYPES_07>(),
                                       myDeclval<ARGTYPES_08>(),
                                       myDeclval<ARGTYPES_09>(),
                                       myDeclval<ARGTYPES_10>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08,
                                    class ARGTYPES_09,
                                    class ARGTYPES_10,
                                    class ARGTYPES_11>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().get().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_10>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_11>()))>::type,
false,
true,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09,
    ARGTYPES_10,
    ARGTYPES_11> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<ARG1TYPE>().get().*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>(),
                                       myDeclval<ARGTYPES_03>(),
                                       myDeclval<ARGTYPES_04>(),
                                       myDeclval<ARGTYPES_05>(),
                                       myDeclval<ARGTYPES_06>(),
                                       myDeclval<ARGTYPES_07>(),
                                       myDeclval<ARGTYPES_08>(),
                                       myDeclval<ARGTYPES_09>(),
                                       myDeclval<ARGTYPES_10>(),
                                       myDeclval<ARGTYPES_11>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08,
                                    class ARGTYPES_09,
                                    class ARGTYPES_10,
                                    class ARGTYPES_11,
                                    class ARGTYPES_12>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().get().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_10>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_11>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_12>()))>::type,
false,
true,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09,
    ARGTYPES_10,
    ARGTYPES_11,
    ARGTYPES_12> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<ARG1TYPE>().get().*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>(),
                                       myDeclval<ARGTYPES_03>(),
                                       myDeclval<ARGTYPES_04>(),
                                       myDeclval<ARGTYPES_05>(),
                                       myDeclval<ARGTYPES_06>(),
                                       myDeclval<ARGTYPES_07>(),
                                       myDeclval<ARGTYPES_08>(),
                                       myDeclval<ARGTYPES_09>(),
                                       myDeclval<ARGTYPES_10>(),
                                       myDeclval<ARGTYPES_11>(),
                                       myDeclval<ARGTYPES_12>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class FN, class ARG1TYPE, class ARGTYPES_01,
                                    class ARGTYPES_02,
                                    class ARGTYPES_03,
                                    class ARGTYPES_04,
                                    class ARGTYPES_05,
                                    class ARGTYPES_06,
                                    class ARGTYPES_07,
                                    class ARGTYPES_08,
                                    class ARGTYPES_09,
                                    class ARGTYPES_10,
                                    class ARGTYPES_11,
                                    class ARGTYPES_12,
                                    class ARGTYPES_13>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().get().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_01>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_02>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_03>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_04>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_05>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_06>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_07>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_08>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_09>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_10>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_11>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_12>(),
            InvokeResult_ImpUtils::myDeclval<ARGTYPES_13>()))>::type,
false,
true,
    FN,
    ARG1TYPE,
    ARGTYPES_01,
    ARGTYPES_02,
    ARGTYPES_03,
    ARGTYPES_04,
    ARGTYPES_05,
    ARGTYPES_06,
    ARGTYPES_07,
    ARGTYPES_08,
    ARGTYPES_09,
    ARGTYPES_10,
    ARGTYPES_11,
    ARGTYPES_12,
    ARGTYPES_13> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<ARG1TYPE>().get().*
                      myDeclval<FN>())(myDeclval<ARGTYPES_01>(),
                                       myDeclval<ARGTYPES_02>(),
                                       myDeclval<ARGTYPES_03>(),
                                       myDeclval<ARGTYPES_04>(),
                                       myDeclval<ARGTYPES_05>(),
                                       myDeclval<ARGTYPES_06>(),
                                       myDeclval<ARGTYPES_07>(),
                                       myDeclval<ARGTYPES_08>(),
                                       myDeclval<ARGTYPES_09>(),
                                       myDeclval<ARGTYPES_10>(),
                                       myDeclval<ARGTYPES_11>(),
                                       myDeclval<ARGTYPES_12>(),
                                       myDeclval<ARGTYPES_13>())) type;
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13


#endif


#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
template <class VOID_TYPE,
          bool ARG_DERIVES_FROM_CLASS,
          bool ARG_IS_REFERENCE_WRAPPER,
          class FN,
          class ARGTYPE>
struct InvokeResult_MemObjPtrImpDispatch;

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class FN>
struct InvokeResult_MemObjPtrImp<FN> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class FN, class ARGTYPES_01>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08,
                                     ARGTYPES_09> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08,
                                     ARGTYPES_09,
                                     ARGTYPES_10> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08,
                                     ARGTYPES_09,
                                     ARGTYPES_10,
                                     ARGTYPES_11> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11,
                    class ARGTYPES_12>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08,
                                     ARGTYPES_09,
                                     ARGTYPES_10,
                                     ARGTYPES_11,
                                     ARGTYPES_12> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11,
                    class ARGTYPES_12,
                    class ARGTYPES_13>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08,
                                     ARGTYPES_09,
                                     ARGTYPES_10,
                                     ARGTYPES_11,
                                     ARGTYPES_12,
                                     ARGTYPES_13> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13


template <class FN, class ARGTYPE>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPE>
: InvokeResult_MemObjPtrImpDispatch<
      void,
      InvokeResult_IsBaseOf<
          typename InvokeResult_MemberObjectPointerTraits<FN>::ClassType,
          typename bsl::remove_reference<ARGTYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<ARGTYPE>::type>::type>::value,
      FN,
      ARGTYPE> {
};

#else

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0
template <class FN>
struct InvokeResult_MemObjPtrImp<FN> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 0

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1
template <class FN, class ARGTYPES_01>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 1

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 2

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 3

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 4

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 5

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 6

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 7

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 8

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08,
                                     ARGTYPES_09> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 9

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08,
                                     ARGTYPES_09,
                                     ARGTYPES_10> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 10

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08,
                                     ARGTYPES_09,
                                     ARGTYPES_10,
                                     ARGTYPES_11> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 11

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11,
                    class ARGTYPES_12>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08,
                                     ARGTYPES_09,
                                     ARGTYPES_10,
                                     ARGTYPES_11,
                                     ARGTYPES_12> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 12

#if BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13
template <class FN, class ARGTYPES_01,
                    class ARGTYPES_02,
                    class ARGTYPES_03,
                    class ARGTYPES_04,
                    class ARGTYPES_05,
                    class ARGTYPES_06,
                    class ARGTYPES_07,
                    class ARGTYPES_08,
                    class ARGTYPES_09,
                    class ARGTYPES_10,
                    class ARGTYPES_11,
                    class ARGTYPES_12,
                    class ARGTYPES_13>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPES_01,
                                     ARGTYPES_02,
                                     ARGTYPES_03,
                                     ARGTYPES_04,
                                     ARGTYPES_05,
                                     ARGTYPES_06,
                                     ARGTYPES_07,
                                     ARGTYPES_08,
                                     ARGTYPES_09,
                                     ARGTYPES_10,
                                     ARGTYPES_11,
                                     ARGTYPES_12,
                                     ARGTYPES_13> {
};
#endif  // BSLMF_INVOKERESULT_VARIADIC_LIMIT_E >= 13


template <class CLASS, class RET, class ARGTYPE>
struct InvokeResult_MemObjPtrImp<RET CLASS::*, ARGTYPE> {

  private:
    typedef InvokeResult_MemPtrArgQualifiers<CLASS, ARGTYPE> ArgQualifiers;

    typedef typename InvokeResult_AddCVRef<RET,
                                           ArgQualifiers::k_IS_CONST,
                                           ArgQualifiers::k_IS_VOLATILE,
                                           ArgQualifiers::k_IS_LVALUE>::type
        cvtype;

  public:
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    typedef typename bsl::conditional<
        ArgQualifiers::k_IS_LVALUE,
        cvtype,
        typename bsl::add_rvalue_reference<cvtype>::type>::type type;
#else
    typedef cvtype type;
#endif
};
#endif


#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
template <class VOID_TYPE,
          bool ARG_DERIVES_FROM_CLASS,
          bool ARG_IS_REFERENCE_WRAPPER,
          class FN,
          class ARGTYPE>
struct InvokeResult_MemObjPtrImpDispatch {
};

template <class FN, class ARGTYPE>
struct InvokeResult_MemObjPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (*InvokeResult_ImpUtils::myDeclval<ARGTYPE>()).*
        InvokeResult_ImpUtils::myDeclval<FN>())>::type,
false,
false,
    FN,
    ARGTYPE> : InvokeResult_ImpUtils {

    typedef decltype((*myDeclval<ARGTYPE>()).*myDeclval<FN>()) type;
};

template <class FN, class ARGTYPE>
struct InvokeResult_MemObjPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        InvokeResult_ImpUtils::myDeclval<ARGTYPE>().*
        InvokeResult_ImpUtils::myDeclval<FN>())>::type,
true,
false,
    FN,
    ARGTYPE> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<ARGTYPE>().*myDeclval<FN>()) type;
};

template <class FN, class ARGTYPE>
struct InvokeResult_MemObjPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        InvokeResult_ImpUtils::myDeclval<ARGTYPE>().get().*
        InvokeResult_ImpUtils::myDeclval<FN>())>::type,
false,
true,
    FN,
    ARGTYPE> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<ARGTYPE>().get().*myDeclval<FN>()) type;
};

#endif
#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.

template <class VOID_TYPE, class FN, class... ARGTYPES>
struct InvokeResult_FunctorImp;

template <class VOID_TYPE, class FN, class... ARGTYPES>
struct InvokeResult_FuncPtrImp;

template <class FN, class... ARGTYPES>
struct InvokeResult_MemFuncPtrImp;

template <class FN, class... ARGTYPES>
struct InvokeResult_MemObjPtrImp;


template <bool IS_FUNCPTR,
          bool IS_MEMFUNCPTR,
          bool IS_MEMOBJPTR,
          class FN,
          class... ARGTYPES>
struct InvokeResult_Imp
     : InvokeResult_FunctorImp<void, FN, ARGTYPES...> {
};

template <class FN, class... ARGTYPES>
struct InvokeResult_Imp<true , false, false, FN, ARGTYPES...>
     : InvokeResult_FuncPtrImp<void, FN, ARGTYPES...> {
};

template <class FN, class... ARGTYPES>
struct InvokeResult_Imp<false, true , false, FN, ARGTYPES...>
     : InvokeResult_MemFuncPtrImp<FN, ARGTYPES...> {
};

template <class FN, class... ARGTYPES>
struct InvokeResult_Imp<false, false, true , FN, ARGTYPES...>
     : InvokeResult_MemObjPtrImp<FN, ARGTYPES...> {
};


#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
template <class VOID_TYPE, class FN, class... ARGTYPES>
struct InvokeResult_FunctorImp {
};

template <class FN, class... ARGTYPES>
struct InvokeResult_FunctorImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES>()...))>::type,
    FN,
    ARGTYPES...> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES>()...)) type;
};
#else
template <class VOID_TYPE, class FN, class... ARGTYPES>
struct InvokeResult_FunctorImp : InvokeResult_ImpUtils {

    enum {
        k_IS_VOID =
            BSLMF_TAG_TO_INT((myDeclval<FN>()(myDeclval<ARGTYPES>()...),
                              InvokeResult_VoidChecker()))
    };

    typedef typename InvokeResult_FunctorDeduction<k_IS_VOID,
                                                   FN,
                                                   ARGTYPES...>::type type;
};
#endif


#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
template <class VOID_TYPE, class FN, class... ARGTYPES>
struct InvokeResult_FuncPtrImp {
};

template <class FN, class... ARGTYPES>
struct InvokeResult_FuncPtrImp<
    typename bslmf::VoidType<decltype(InvokeResult_ImpUtils::myDeclval<FN>()(
        InvokeResult_ImpUtils::myDeclval<ARGTYPES>()...))>::type,
    FN,
    ARGTYPES...> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<FN>()(myDeclval<ARGTYPES>()...)) type;
};
#else
template <class VOID_TYPE, class FN, class... ARGTYPES>
struct InvokeResult_FuncPtrImp {

    typedef typename
      bslmf::FunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif


#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
template <class VOID_TYPE,
          bool ARG1_DERIVES_FROM_CLASS,
          bool ARG1_IS_REFERENCE_WRAPPER,
          class FN,
          class ARG1TYPE,
          class... ARGTYPES>
struct InvokeResult_MemFuncPtrImpDispatch;

template <class FN>
struct InvokeResult_MemFuncPtrImp<FN> {
};

template <class FN, class ARG1TYPE, class... ARGTYPES>
struct InvokeResult_MemFuncPtrImp<FN, ARG1TYPE, ARGTYPES...>
: InvokeResult_MemFuncPtrImpDispatch<
      void,
      InvokeResult_IsBaseOf<
          typename MemberFunctionPointerTraits<FN>::ClassType,
          typename bsl::remove_reference<ARG1TYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<ARG1TYPE>::type>::type>::value,
      FN,
      ARG1TYPE,
      ARGTYPES...> {
};
#else
template <class FN, class... ARGTYPES>
struct InvokeResult_MemFuncPtrImp<FN, ARGTYPES...> {

    typedef typename MemberFunctionPointerTraits<FN>::ResultType QType;

    typedef typename
      bsl::conditional<bsl::is_reference<QType>::value ||
                       bsl::is_class<QType>::value,
                       QType, typename bsl::remove_cv<QType>::type>::type type;
};
#endif


#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
template <class VOID_TYPE,
          bool ARG1_DERIVES_FROM_CLASS,
          bool ARG1_IS_REFERENCE_WRAPPER,
          class FN,
          class ARG1TYPE,
          class... ARGTYPES>
struct InvokeResult_MemFuncPtrImpDispatch {
};

template <class FN, class ARG1TYPE, class... ARGTYPES>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        ((*InvokeResult_ImpUtils::myDeclval<ARG1TYPE>()).*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES>()...))>::type,
false,
false,
    FN,
    ARG1TYPE,
    ARGTYPES...> : InvokeResult_ImpUtils {

    typedef decltype(((*myDeclval<ARG1TYPE>()).*
                      myDeclval<FN>())(myDeclval<ARGTYPES>()...)) type;
};

template <class FN, class ARG1TYPE, class... ARGTYPES>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES>()...))>::type,
true,
false,
    FN,
    ARG1TYPE,
    ARGTYPES...> : InvokeResult_ImpUtils {

    typedef decltype(
     (myDeclval<ARG1TYPE>().*myDeclval<FN>())(myDeclval<ARGTYPES>()...)) type;
};

template <class FN, class ARG1TYPE, class... ARGTYPES>
struct InvokeResult_MemFuncPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (InvokeResult_ImpUtils::myDeclval<ARG1TYPE>().get().*
         InvokeResult_ImpUtils::myDeclval<FN>())(
            InvokeResult_ImpUtils::myDeclval<ARGTYPES>()...))>::type,
false,
true,
    FN,
    ARG1TYPE,
    ARGTYPES...> : InvokeResult_ImpUtils {

    typedef decltype((myDeclval<ARG1TYPE>().get().*
                      myDeclval<FN>())(myDeclval<ARGTYPES>()...)) type;
};

#endif


#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
template <class VOID_TYPE,
          bool ARG_DERIVES_FROM_CLASS,
          bool ARG_IS_REFERENCE_WRAPPER,
          class FN,
          class ARGTYPE>
struct InvokeResult_MemObjPtrImpDispatch;

template <class FN, class... ARGTYPES>
struct InvokeResult_MemObjPtrImp {
};

template <class FN, class ARGTYPE>
struct InvokeResult_MemObjPtrImp<FN, ARGTYPE>
: InvokeResult_MemObjPtrImpDispatch<
      void,
      InvokeResult_IsBaseOf<
          typename InvokeResult_MemberObjectPointerTraits<FN>::ClassType,
          typename bsl::remove_reference<ARGTYPE>::type>::value,
      IsReferenceWrapper<typename bsl::remove_const<
          typename bsl::remove_reference<ARGTYPE>::type>::type>::value,
      FN,
      ARGTYPE> {
};

#else

template <class FN, class... ARGTYPES>
struct InvokeResult_MemObjPtrImp {
};

template <class CLASS, class RET, class ARGTYPE>
struct InvokeResult_MemObjPtrImp<RET CLASS::*, ARGTYPE> {

  private:
    typedef InvokeResult_MemPtrArgQualifiers<CLASS, ARGTYPE> ArgQualifiers;

    typedef typename InvokeResult_AddCVRef<RET,
                                           ArgQualifiers::k_IS_CONST,
                                           ArgQualifiers::k_IS_VOLATILE,
                                           ArgQualifiers::k_IS_LVALUE>::type
        cvtype;

  public:
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    typedef typename bsl::conditional<
        ArgQualifiers::k_IS_LVALUE,
        cvtype,
        typename bsl::add_rvalue_reference<cvtype>::type>::type type;
#else
    typedef cvtype type;
#endif
};
#endif


#ifdef BSLMF_INVOKERESULT_SUPPORT_CPP17_SEMANTICS
template <class VOID_TYPE,
          bool ARG_DERIVES_FROM_CLASS,
          bool ARG_IS_REFERENCE_WRAPPER,
          class FN,
          class ARGTYPE>
struct InvokeResult_MemObjPtrImpDispatch {
};

template <class FN, class ARGTYPE>
struct InvokeResult_MemObjPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        (*InvokeResult_ImpUtils::myDeclval<ARGTYPE>()).*
        InvokeResult_ImpUtils::myDeclval<FN>())>::type,
false,
false,
    FN,
    ARGTYPE> : InvokeResult_ImpUtils {

    typedef decltype((*myDeclval<ARGTYPE>()).*myDeclval<FN>()) type;
};

template <class FN, class ARGTYPE>
struct InvokeResult_MemObjPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        InvokeResult_ImpUtils::myDeclval<ARGTYPE>().*
        InvokeResult_ImpUtils::myDeclval<FN>())>::type,
true,
false,
    FN,
    ARGTYPE> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<ARGTYPE>().*myDeclval<FN>()) type;
};

template <class FN, class ARGTYPE>
struct InvokeResult_MemObjPtrImpDispatch<
    typename bslmf::VoidType<decltype(
        InvokeResult_ImpUtils::myDeclval<ARGTYPE>().get().*
        InvokeResult_ImpUtils::myDeclval<FN>())>::type,
false,
true,
    FN,
    ARGTYPE> : InvokeResult_ImpUtils {

    typedef decltype(myDeclval<ARGTYPE>().get().*myDeclval<FN>()) type;
};

#endif

// }}} END GENERATED CODE
#endif

}  // close package namespace
}  // close enterprise namespace

#else // if ! defined(DEFINED_BSLMF_INVOKERESULT_H)
# error Not valid except when included from bslmf_invokeresult.h
#endif // ! defined(COMPILING_BSLMF_INVOKERESULT_H)

#endif // ! defined(INCLUDED_BSLMF_INVOKERESULT_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2021 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
