// bslstl_variant_cpp03.h                                             -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BSLSTL_VARIANT_CPP03
#define INCLUDED_BSLSTL_VARIANT_CPP03

//@PURPOSE: Provide C++03 implementation for bslstl_variant.h
//
//@CLASSES: See bslstl_variant.h for list of classes
//
//@SEE_ALSO: bslstl_variant
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Wed Sep 20 13:35:03 2023
// Command line: sim_cpp11_features.pl bslstl_variant.h

#ifdef COMPILING_BSLSTL_VARIANT_H

// When generating the expansion of a variadic template, the
// sim_cpp11_features.pl script currently expands the primary template by the
// required number of template arguments.  If there is a partial specialization
// that adds a non variadic template parameter, the generated primary template
// will no longer match the expansion of such specialization.  In the case of
// 'variant' metafunction helpers, such additional template argument is always
// a type parameter.  To work around this issue, a dummy template type
// parameter is added to the primary template and defaulted to
// 'BSLSTL_VARIANT_NOT_A_TYPE'.
#define BSLSTL_VARIANT_NOT_A_TYPE void

namespace bsl {

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_variant.h
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT
#define BSLSTL_VARIANT_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT_A
#define BSLSTL_VARIANT_VARIADIC_LIMIT_A BSLSTL_VARIANT_VARIADIC_LIMIT
#endif
template <class HEAD
#if BSLSTL_VARIANT_VARIADIC_LIMIT_A >= 0
        , class TAIL_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_A >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_A >= 1
        , class TAIL_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_A >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_A >= 2
        , class TAIL_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_A >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_A >= 3
        , class TAIL_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_A >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_A >= 4
        , class TAIL_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_A >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_A >= 5
        , class TAIL_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_A >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_A >= 6
        , class TAIL_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_A >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_A >= 7
        , class TAIL_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_A >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_A >= 8
        , class TAIL_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_A >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_A >= 9
        , class TAIL_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_A >= 9
        , class = BSLS_COMPILERFEATURES_NILT>
class variant;

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class HEAD, class... TAIL>
class variant;
// }}} END GENERATED CODE
#endif

// TRAITS

                            // ===================
                            // struct variant_size
                            // ===================

template <class BSL_VARIANT>
struct variant_size;
    // This metafunction calculates the number of alternatives in the (possibly
    // cv-qualified) 'bsl::variant' type of (template parameter)
    // 'BSL_VARIANT'.  The primary template is not defined.

template <class BSL_VARIANT>
struct variant_size<const BSL_VARIANT> : variant_size<BSL_VARIANT> {
};

template <class BSL_VARIANT>
struct variant_size<volatile BSL_VARIANT> : variant_size<BSL_VARIANT> {
};

template <class BSL_VARIANT>
struct variant_size<const volatile BSL_VARIANT> : variant_size<BSL_VARIANT> {
};

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_variant.h
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT
#define BSLSTL_VARIANT_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT_B
#define BSLSTL_VARIANT_VARIADIC_LIMIT_B BSLSTL_VARIANT_VARIADIC_LIMIT
#endif
#if BSLSTL_VARIANT_VARIADIC_LIMIT_B >= 0
template <class HEAD>
struct variant_size<variant<HEAD> >
: bsl::integral_constant<size_t, 1 +  0u> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_B >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_B >= 1
template <class HEAD, class TAIL_01>
struct variant_size<variant<HEAD, TAIL_01> >
: bsl::integral_constant<size_t, 1 +  1u> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_B >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_B >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
struct variant_size<variant<HEAD, TAIL_01,
                                  TAIL_02> >
: bsl::integral_constant<size_t, 1 +  2u> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_B >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_B >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
struct variant_size<variant<HEAD, TAIL_01,
                                  TAIL_02,
                                  TAIL_03> >
: bsl::integral_constant<size_t, 1 +  3u> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_B >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_B >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
struct variant_size<variant<HEAD, TAIL_01,
                                  TAIL_02,
                                  TAIL_03,
                                  TAIL_04> >
: bsl::integral_constant<size_t, 1 +  4u> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_B >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_B >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
struct variant_size<variant<HEAD, TAIL_01,
                                  TAIL_02,
                                  TAIL_03,
                                  TAIL_04,
                                  TAIL_05> >
: bsl::integral_constant<size_t, 1 +  5u> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_B >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_B >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
struct variant_size<variant<HEAD, TAIL_01,
                                  TAIL_02,
                                  TAIL_03,
                                  TAIL_04,
                                  TAIL_05,
                                  TAIL_06> >
: bsl::integral_constant<size_t, 1 +  6u> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_B >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_B >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
struct variant_size<variant<HEAD, TAIL_01,
                                  TAIL_02,
                                  TAIL_03,
                                  TAIL_04,
                                  TAIL_05,
                                  TAIL_06,
                                  TAIL_07> >
: bsl::integral_constant<size_t, 1 +  7u> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_B >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_B >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
struct variant_size<variant<HEAD, TAIL_01,
                                  TAIL_02,
                                  TAIL_03,
                                  TAIL_04,
                                  TAIL_05,
                                  TAIL_06,
                                  TAIL_07,
                                  TAIL_08> >
: bsl::integral_constant<size_t, 1 +  8u> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_B >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_B >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
struct variant_size<variant<HEAD, TAIL_01,
                                  TAIL_02,
                                  TAIL_03,
                                  TAIL_04,
                                  TAIL_05,
                                  TAIL_06,
                                  TAIL_07,
                                  TAIL_08,
                                  TAIL_09> >
: bsl::integral_constant<size_t, 1 +  9u> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_B >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_B >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
struct variant_size<variant<HEAD, TAIL_01,
                                  TAIL_02,
                                  TAIL_03,
                                  TAIL_04,
                                  TAIL_05,
                                  TAIL_06,
                                  TAIL_07,
                                  TAIL_08,
                                  TAIL_09,
                                  TAIL_10> >
: bsl::integral_constant<size_t, 1 + 10u> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_B >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class HEAD, class... TAIL>
struct variant_size<variant<HEAD, TAIL...> >
: bsl::integral_constant<size_t, 1 + sizeof...(TAIL)> {
};
// }}} END GENERATED CODE
#endif

#ifdef BSLS_COMPILERFEATURES_SUPPORT_VARIABLE_TEMPLATES
template <class BSL_VARIANT>
BSLS_KEYWORD_INLINE_VARIABLE constexpr size_t variant_size_v =
    variant_size<BSL_VARIANT>::value;
    // This variable template represents the result value of the
    // 'bsl::variant_size' metafunction.
#endif  // BSLS_COMPILERFEATURES_SUPPORT_VARIABLE_TEMPLATES

BSLS_KEYWORD_INLINE_CONSTEXPR size_t variant_npos = -1;
    // This value is returned by 'bsl::variant::index()' if
    // 'valueless_by_exception()' is 'true'.

                         // ==========================
                         // struct variant_alternative
                         // ==========================

template <size_t INDEX, class TYPE>
struct variant_alternative;
    // This metafunction calculates the type of the alternative whose index is
    // (template parameter) 'INDEX' in the possibly cv-qualified
    // 'bsl::variant' type of (template parameter) 'TYPE'.  If 'TYPE' is
    // cv-qualified, its cv-qualifiers are applied to the alternative.

template <size_t INDEX, class TYPE>
struct variant_alternative<INDEX, const TYPE> {
    typedef typename variant_alternative<INDEX, TYPE>::type const type;
};

template <size_t INDEX, class TYPE>
struct variant_alternative<INDEX, volatile TYPE> {
    typedef typename variant_alternative<INDEX, TYPE>::type volatile type;
};

template <size_t INDEX, class TYPE>
struct variant_alternative<INDEX, const volatile TYPE> {
    typedef
        typename variant_alternative<INDEX, TYPE>::type const volatile type;
};

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_variant.h
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT
#define BSLSTL_VARIANT_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT_C
#define BSLSTL_VARIANT_VARIADIC_LIMIT_C BSLSTL_VARIANT_VARIADIC_LIMIT
#endif
template <size_t INDEX,
          class HEAD = BSLSTL_VARIANT_NOT_A_TYPE
#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 0
        , class TAIL_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 1
        , class TAIL_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 2
        , class TAIL_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 3
        , class TAIL_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 4
        , class TAIL_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 5
        , class TAIL_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 6
        , class TAIL_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 7
        , class TAIL_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 8
        , class TAIL_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 9
        , class TAIL_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 9
        , class = BSLS_COMPILERFEATURES_NILT>
struct Variant_VariantAlternativeImpl;

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 0
template <size_t INDEX, class HEAD>
struct Variant_VariantAlternativeImpl<INDEX, HEAD>
: Variant_VariantAlternativeImpl<INDEX - 1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 1
template <size_t INDEX, class HEAD, class TAIL_01>
struct Variant_VariantAlternativeImpl<INDEX, HEAD, TAIL_01>
: Variant_VariantAlternativeImpl<INDEX - 1, TAIL_01> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 2
template <size_t INDEX, class HEAD, class TAIL_01,
                                    class TAIL_02>
struct Variant_VariantAlternativeImpl<INDEX, HEAD, TAIL_01,
                                                   TAIL_02>
: Variant_VariantAlternativeImpl<INDEX - 1, TAIL_01,
                                            TAIL_02> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 3
template <size_t INDEX, class HEAD, class TAIL_01,
                                    class TAIL_02,
                                    class TAIL_03>
struct Variant_VariantAlternativeImpl<INDEX, HEAD, TAIL_01,
                                                   TAIL_02,
                                                   TAIL_03>
: Variant_VariantAlternativeImpl<INDEX - 1, TAIL_01,
                                            TAIL_02,
                                            TAIL_03> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 4
template <size_t INDEX, class HEAD, class TAIL_01,
                                    class TAIL_02,
                                    class TAIL_03,
                                    class TAIL_04>
struct Variant_VariantAlternativeImpl<INDEX, HEAD, TAIL_01,
                                                   TAIL_02,
                                                   TAIL_03,
                                                   TAIL_04>
: Variant_VariantAlternativeImpl<INDEX - 1, TAIL_01,
                                            TAIL_02,
                                            TAIL_03,
                                            TAIL_04> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 5
template <size_t INDEX, class HEAD, class TAIL_01,
                                    class TAIL_02,
                                    class TAIL_03,
                                    class TAIL_04,
                                    class TAIL_05>
struct Variant_VariantAlternativeImpl<INDEX, HEAD, TAIL_01,
                                                   TAIL_02,
                                                   TAIL_03,
                                                   TAIL_04,
                                                   TAIL_05>
: Variant_VariantAlternativeImpl<INDEX - 1, TAIL_01,
                                            TAIL_02,
                                            TAIL_03,
                                            TAIL_04,
                                            TAIL_05> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 6
template <size_t INDEX, class HEAD, class TAIL_01,
                                    class TAIL_02,
                                    class TAIL_03,
                                    class TAIL_04,
                                    class TAIL_05,
                                    class TAIL_06>
struct Variant_VariantAlternativeImpl<INDEX, HEAD, TAIL_01,
                                                   TAIL_02,
                                                   TAIL_03,
                                                   TAIL_04,
                                                   TAIL_05,
                                                   TAIL_06>
: Variant_VariantAlternativeImpl<INDEX - 1, TAIL_01,
                                            TAIL_02,
                                            TAIL_03,
                                            TAIL_04,
                                            TAIL_05,
                                            TAIL_06> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 7
template <size_t INDEX, class HEAD, class TAIL_01,
                                    class TAIL_02,
                                    class TAIL_03,
                                    class TAIL_04,
                                    class TAIL_05,
                                    class TAIL_06,
                                    class TAIL_07>
struct Variant_VariantAlternativeImpl<INDEX, HEAD, TAIL_01,
                                                   TAIL_02,
                                                   TAIL_03,
                                                   TAIL_04,
                                                   TAIL_05,
                                                   TAIL_06,
                                                   TAIL_07>
: Variant_VariantAlternativeImpl<INDEX - 1, TAIL_01,
                                            TAIL_02,
                                            TAIL_03,
                                            TAIL_04,
                                            TAIL_05,
                                            TAIL_06,
                                            TAIL_07> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 8
template <size_t INDEX, class HEAD, class TAIL_01,
                                    class TAIL_02,
                                    class TAIL_03,
                                    class TAIL_04,
                                    class TAIL_05,
                                    class TAIL_06,
                                    class TAIL_07,
                                    class TAIL_08>
struct Variant_VariantAlternativeImpl<INDEX, HEAD, TAIL_01,
                                                   TAIL_02,
                                                   TAIL_03,
                                                   TAIL_04,
                                                   TAIL_05,
                                                   TAIL_06,
                                                   TAIL_07,
                                                   TAIL_08>
: Variant_VariantAlternativeImpl<INDEX - 1, TAIL_01,
                                            TAIL_02,
                                            TAIL_03,
                                            TAIL_04,
                                            TAIL_05,
                                            TAIL_06,
                                            TAIL_07,
                                            TAIL_08> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 9
template <size_t INDEX, class HEAD, class TAIL_01,
                                    class TAIL_02,
                                    class TAIL_03,
                                    class TAIL_04,
                                    class TAIL_05,
                                    class TAIL_06,
                                    class TAIL_07,
                                    class TAIL_08,
                                    class TAIL_09>
struct Variant_VariantAlternativeImpl<INDEX, HEAD, TAIL_01,
                                                   TAIL_02,
                                                   TAIL_03,
                                                   TAIL_04,
                                                   TAIL_05,
                                                   TAIL_06,
                                                   TAIL_07,
                                                   TAIL_08,
                                                   TAIL_09>
: Variant_VariantAlternativeImpl<INDEX - 1, TAIL_01,
                                            TAIL_02,
                                            TAIL_03,
                                            TAIL_04,
                                            TAIL_05,
                                            TAIL_06,
                                            TAIL_07,
                                            TAIL_08,
                                            TAIL_09> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 10
template <size_t INDEX, class HEAD, class TAIL_01,
                                    class TAIL_02,
                                    class TAIL_03,
                                    class TAIL_04,
                                    class TAIL_05,
                                    class TAIL_06,
                                    class TAIL_07,
                                    class TAIL_08,
                                    class TAIL_09,
                                    class TAIL_10>
struct Variant_VariantAlternativeImpl<INDEX, HEAD, TAIL_01,
                                                   TAIL_02,
                                                   TAIL_03,
                                                   TAIL_04,
                                                   TAIL_05,
                                                   TAIL_06,
                                                   TAIL_07,
                                                   TAIL_08,
                                                   TAIL_09,
                                                   TAIL_10>
: Variant_VariantAlternativeImpl<INDEX - 1, TAIL_01,
                                            TAIL_02,
                                            TAIL_03,
                                            TAIL_04,
                                            TAIL_05,
                                            TAIL_06,
                                            TAIL_07,
                                            TAIL_08,
                                            TAIL_09,
                                            TAIL_10> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 10


template <size_t INDEX>
struct Variant_VariantAlternativeImpl<INDEX, BSLSTL_VARIANT_NOT_A_TYPE> {
};

template <>
struct Variant_VariantAlternativeImpl<0, BSLSTL_VARIANT_NOT_A_TYPE> {
};

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 0
template <class HEAD>
struct Variant_VariantAlternativeImpl<0, HEAD> {
    typedef HEAD type;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 1
template <class HEAD, class TAIL_01>
struct Variant_VariantAlternativeImpl<0, HEAD, TAIL_01> {
    typedef HEAD type;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
struct Variant_VariantAlternativeImpl<0, HEAD, TAIL_01,
                                               TAIL_02> {
    typedef HEAD type;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
struct Variant_VariantAlternativeImpl<0, HEAD, TAIL_01,
                                               TAIL_02,
                                               TAIL_03> {
    typedef HEAD type;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
struct Variant_VariantAlternativeImpl<0, HEAD, TAIL_01,
                                               TAIL_02,
                                               TAIL_03,
                                               TAIL_04> {
    typedef HEAD type;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
struct Variant_VariantAlternativeImpl<0, HEAD, TAIL_01,
                                               TAIL_02,
                                               TAIL_03,
                                               TAIL_04,
                                               TAIL_05> {
    typedef HEAD type;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
struct Variant_VariantAlternativeImpl<0, HEAD, TAIL_01,
                                               TAIL_02,
                                               TAIL_03,
                                               TAIL_04,
                                               TAIL_05,
                                               TAIL_06> {
    typedef HEAD type;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
struct Variant_VariantAlternativeImpl<0, HEAD, TAIL_01,
                                               TAIL_02,
                                               TAIL_03,
                                               TAIL_04,
                                               TAIL_05,
                                               TAIL_06,
                                               TAIL_07> {
    typedef HEAD type;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
struct Variant_VariantAlternativeImpl<0, HEAD, TAIL_01,
                                               TAIL_02,
                                               TAIL_03,
                                               TAIL_04,
                                               TAIL_05,
                                               TAIL_06,
                                               TAIL_07,
                                               TAIL_08> {
    typedef HEAD type;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
struct Variant_VariantAlternativeImpl<0, HEAD, TAIL_01,
                                               TAIL_02,
                                               TAIL_03,
                                               TAIL_04,
                                               TAIL_05,
                                               TAIL_06,
                                               TAIL_07,
                                               TAIL_08,
                                               TAIL_09> {
    typedef HEAD type;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
struct Variant_VariantAlternativeImpl<0, HEAD, TAIL_01,
                                               TAIL_02,
                                               TAIL_03,
                                               TAIL_04,
                                               TAIL_05,
                                               TAIL_06,
                                               TAIL_07,
                                               TAIL_08,
                                               TAIL_09,
                                               TAIL_10> {
    typedef HEAD type;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 0
template <size_t INDEX, class HEAD>
struct variant_alternative<INDEX, variant<HEAD> >
: Variant_VariantAlternativeImpl<INDEX, HEAD> {
    BSLMF_ASSERT((INDEX < bsl::variant_size<variant<HEAD> >::value));
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 1
template <size_t INDEX, class HEAD, class TAIL_01>
struct variant_alternative<INDEX, variant<HEAD, TAIL_01> >
: Variant_VariantAlternativeImpl<INDEX, HEAD, TAIL_01> {
    BSLMF_ASSERT((INDEX < bsl::variant_size<variant<HEAD, TAIL_01> >::value));
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 2
template <size_t INDEX, class HEAD, class TAIL_01,
                                    class TAIL_02>
struct variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                TAIL_02> >
: Variant_VariantAlternativeImpl<INDEX, HEAD, TAIL_01,
                                              TAIL_02> {
    BSLMF_ASSERT((INDEX < bsl::variant_size<variant<HEAD, TAIL_01,
                                                          TAIL_02> >::value));
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 3
template <size_t INDEX, class HEAD, class TAIL_01,
                                    class TAIL_02,
                                    class TAIL_03>
struct variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03> >
: Variant_VariantAlternativeImpl<INDEX, HEAD, TAIL_01,
                                              TAIL_02,
                                              TAIL_03> {
    BSLMF_ASSERT((INDEX < bsl::variant_size<variant<HEAD, TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03> >::value));
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 4
template <size_t INDEX, class HEAD, class TAIL_01,
                                    class TAIL_02,
                                    class TAIL_03,
                                    class TAIL_04>
struct variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                TAIL_04> >
: Variant_VariantAlternativeImpl<INDEX, HEAD, TAIL_01,
                                              TAIL_02,
                                              TAIL_03,
                                              TAIL_04> {
    BSLMF_ASSERT((INDEX < bsl::variant_size<variant<HEAD, TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04> >::value));
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 5
template <size_t INDEX, class HEAD, class TAIL_01,
                                    class TAIL_02,
                                    class TAIL_03,
                                    class TAIL_04,
                                    class TAIL_05>
struct variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                TAIL_04,
                                                TAIL_05> >
: Variant_VariantAlternativeImpl<INDEX, HEAD, TAIL_01,
                                              TAIL_02,
                                              TAIL_03,
                                              TAIL_04,
                                              TAIL_05> {
    BSLMF_ASSERT((INDEX < bsl::variant_size<variant<HEAD, TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05> >::value));
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 6
template <size_t INDEX, class HEAD, class TAIL_01,
                                    class TAIL_02,
                                    class TAIL_03,
                                    class TAIL_04,
                                    class TAIL_05,
                                    class TAIL_06>
struct variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                TAIL_04,
                                                TAIL_05,
                                                TAIL_06> >
: Variant_VariantAlternativeImpl<INDEX, HEAD, TAIL_01,
                                              TAIL_02,
                                              TAIL_03,
                                              TAIL_04,
                                              TAIL_05,
                                              TAIL_06> {
    BSLMF_ASSERT((INDEX < bsl::variant_size<variant<HEAD, TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06> >::value));
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 7
template <size_t INDEX, class HEAD, class TAIL_01,
                                    class TAIL_02,
                                    class TAIL_03,
                                    class TAIL_04,
                                    class TAIL_05,
                                    class TAIL_06,
                                    class TAIL_07>
struct variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                TAIL_04,
                                                TAIL_05,
                                                TAIL_06,
                                                TAIL_07> >
: Variant_VariantAlternativeImpl<INDEX, HEAD, TAIL_01,
                                              TAIL_02,
                                              TAIL_03,
                                              TAIL_04,
                                              TAIL_05,
                                              TAIL_06,
                                              TAIL_07> {
    BSLMF_ASSERT((INDEX < bsl::variant_size<variant<HEAD, TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07> >::value));
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 8
template <size_t INDEX, class HEAD, class TAIL_01,
                                    class TAIL_02,
                                    class TAIL_03,
                                    class TAIL_04,
                                    class TAIL_05,
                                    class TAIL_06,
                                    class TAIL_07,
                                    class TAIL_08>
struct variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                TAIL_04,
                                                TAIL_05,
                                                TAIL_06,
                                                TAIL_07,
                                                TAIL_08> >
: Variant_VariantAlternativeImpl<INDEX, HEAD, TAIL_01,
                                              TAIL_02,
                                              TAIL_03,
                                              TAIL_04,
                                              TAIL_05,
                                              TAIL_06,
                                              TAIL_07,
                                              TAIL_08> {
    BSLMF_ASSERT((INDEX < bsl::variant_size<variant<HEAD, TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07,
                                                          TAIL_08> >::value));
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 9
template <size_t INDEX, class HEAD, class TAIL_01,
                                    class TAIL_02,
                                    class TAIL_03,
                                    class TAIL_04,
                                    class TAIL_05,
                                    class TAIL_06,
                                    class TAIL_07,
                                    class TAIL_08,
                                    class TAIL_09>
struct variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                TAIL_04,
                                                TAIL_05,
                                                TAIL_06,
                                                TAIL_07,
                                                TAIL_08,
                                                TAIL_09> >
: Variant_VariantAlternativeImpl<INDEX, HEAD, TAIL_01,
                                              TAIL_02,
                                              TAIL_03,
                                              TAIL_04,
                                              TAIL_05,
                                              TAIL_06,
                                              TAIL_07,
                                              TAIL_08,
                                              TAIL_09> {
    BSLMF_ASSERT((INDEX < bsl::variant_size<variant<HEAD, TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07,
                                                          TAIL_08,
                                                          TAIL_09> >::value));
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 10
template <size_t INDEX, class HEAD, class TAIL_01,
                                    class TAIL_02,
                                    class TAIL_03,
                                    class TAIL_04,
                                    class TAIL_05,
                                    class TAIL_06,
                                    class TAIL_07,
                                    class TAIL_08,
                                    class TAIL_09,
                                    class TAIL_10>
struct variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                TAIL_04,
                                                TAIL_05,
                                                TAIL_06,
                                                TAIL_07,
                                                TAIL_08,
                                                TAIL_09,
                                                TAIL_10> >
: Variant_VariantAlternativeImpl<INDEX, HEAD, TAIL_01,
                                              TAIL_02,
                                              TAIL_03,
                                              TAIL_04,
                                              TAIL_05,
                                              TAIL_06,
                                              TAIL_07,
                                              TAIL_08,
                                              TAIL_09,
                                              TAIL_10> {
    BSLMF_ASSERT((INDEX < bsl::variant_size<variant<HEAD, TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07,
                                                          TAIL_08,
                                                          TAIL_09,
                                                          TAIL_10> >::value));
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 10


#ifdef BSLS_COMPILERFEATURES_SUPPORT_ALIAS_TEMPLATES
template <size_t INDEX, class TYPE>
using variant_alternative_t = typename variant_alternative<INDEX, TYPE>::type;
#endif

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 0
template <class HEAD>
void swap(bsl::variant<HEAD>& lhs, bsl::variant<HEAD>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 1
template <class HEAD, class TAIL_01>
void swap(bsl::variant<HEAD, TAIL_01>& lhs, bsl::variant<HEAD, TAIL_01>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
void swap(bsl::variant<HEAD, TAIL_01,
                             TAIL_02>& lhs, bsl::variant<HEAD, TAIL_01,
                                                               TAIL_02>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
void swap(bsl::variant<HEAD, TAIL_01,
                             TAIL_02,
                             TAIL_03>& lhs, bsl::variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
void swap(bsl::variant<HEAD, TAIL_01,
                             TAIL_02,
                             TAIL_03,
                             TAIL_04>& lhs, bsl::variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03,
                                                               TAIL_04>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
void swap(bsl::variant<HEAD, TAIL_01,
                             TAIL_02,
                             TAIL_03,
                             TAIL_04,
                             TAIL_05>& lhs, bsl::variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03,
                                                               TAIL_04,
                                                               TAIL_05>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
void swap(bsl::variant<HEAD, TAIL_01,
                             TAIL_02,
                             TAIL_03,
                             TAIL_04,
                             TAIL_05,
                             TAIL_06>& lhs, bsl::variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03,
                                                               TAIL_04,
                                                               TAIL_05,
                                                               TAIL_06>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
void swap(bsl::variant<HEAD, TAIL_01,
                             TAIL_02,
                             TAIL_03,
                             TAIL_04,
                             TAIL_05,
                             TAIL_06,
                             TAIL_07>& lhs, bsl::variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03,
                                                               TAIL_04,
                                                               TAIL_05,
                                                               TAIL_06,
                                                               TAIL_07>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
void swap(bsl::variant<HEAD, TAIL_01,
                             TAIL_02,
                             TAIL_03,
                             TAIL_04,
                             TAIL_05,
                             TAIL_06,
                             TAIL_07,
                             TAIL_08>& lhs, bsl::variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03,
                                                               TAIL_04,
                                                               TAIL_05,
                                                               TAIL_06,
                                                               TAIL_07,
                                                               TAIL_08>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
void swap(bsl::variant<HEAD, TAIL_01,
                             TAIL_02,
                             TAIL_03,
                             TAIL_04,
                             TAIL_05,
                             TAIL_06,
                             TAIL_07,
                             TAIL_08,
                             TAIL_09>& lhs, bsl::variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03,
                                                               TAIL_04,
                                                               TAIL_05,
                                                               TAIL_06,
                                                               TAIL_07,
                                                               TAIL_08,
                                                               TAIL_09>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
void swap(bsl::variant<HEAD, TAIL_01,
                             TAIL_02,
                             TAIL_03,
                             TAIL_04,
                             TAIL_05,
                             TAIL_06,
                             TAIL_07,
                             TAIL_08,
                             TAIL_09,
                             TAIL_10>& lhs, bsl::variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03,
                                                               TAIL_04,
                                                               TAIL_05,
                                                               TAIL_06,
                                                               TAIL_07,
                                                               TAIL_08,
                                                               TAIL_09,
                                                               TAIL_10>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 0
template <class HASHALG, class HEAD>
void hashAppend(HASHALG& hashAlg, const variant<HEAD>& input);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 1
template <class HASHALG, class HEAD, class TAIL_01>
void hashAppend(HASHALG& hashAlg, const variant<HEAD, TAIL_01>& input);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 2
template <class HASHALG, class HEAD, class TAIL_01,
                                     class TAIL_02>
void hashAppend(HASHALG& hashAlg, const variant<HEAD, TAIL_01,
                                                      TAIL_02>& input);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 3
template <class HASHALG, class HEAD, class TAIL_01,
                                     class TAIL_02,
                                     class TAIL_03>
void hashAppend(HASHALG& hashAlg, const variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03>& input);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 4
template <class HASHALG, class HEAD, class TAIL_01,
                                     class TAIL_02,
                                     class TAIL_03,
                                     class TAIL_04>
void hashAppend(HASHALG& hashAlg, const variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04>& input);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 5
template <class HASHALG, class HEAD, class TAIL_01,
                                     class TAIL_02,
                                     class TAIL_03,
                                     class TAIL_04,
                                     class TAIL_05>
void hashAppend(HASHALG& hashAlg, const variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05>& input);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 6
template <class HASHALG, class HEAD, class TAIL_01,
                                     class TAIL_02,
                                     class TAIL_03,
                                     class TAIL_04,
                                     class TAIL_05,
                                     class TAIL_06>
void hashAppend(HASHALG& hashAlg, const variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06>& input);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 7
template <class HASHALG, class HEAD, class TAIL_01,
                                     class TAIL_02,
                                     class TAIL_03,
                                     class TAIL_04,
                                     class TAIL_05,
                                     class TAIL_06,
                                     class TAIL_07>
void hashAppend(HASHALG& hashAlg, const variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07>& input);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 8
template <class HASHALG, class HEAD, class TAIL_01,
                                     class TAIL_02,
                                     class TAIL_03,
                                     class TAIL_04,
                                     class TAIL_05,
                                     class TAIL_06,
                                     class TAIL_07,
                                     class TAIL_08>
void hashAppend(HASHALG& hashAlg, const variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08>& input);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 9
template <class HASHALG, class HEAD, class TAIL_01,
                                     class TAIL_02,
                                     class TAIL_03,
                                     class TAIL_04,
                                     class TAIL_05,
                                     class TAIL_06,
                                     class TAIL_07,
                                     class TAIL_08,
                                     class TAIL_09>
void hashAppend(HASHALG& hashAlg, const variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08,
                                                      TAIL_09>& input);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 10
template <class HASHALG, class HEAD, class TAIL_01,
                                     class TAIL_02,
                                     class TAIL_03,
                                     class TAIL_04,
                                     class TAIL_05,
                                     class TAIL_06,
                                     class TAIL_07,
                                     class TAIL_08,
                                     class TAIL_09,
                                     class TAIL_10>
void hashAppend(HASHALG& hashAlg, const variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08,
                                                      TAIL_09,
                                                      TAIL_10>& input);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 0
template <class TYPE, class HEAD>
bool holds_alternative(
                      const variant<HEAD>& obj) BSLS_KEYWORD_NOEXCEPT;
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 1
template <class TYPE, class HEAD, class TAIL_01>
bool holds_alternative(
                      const variant<HEAD, TAIL_01>& obj) BSLS_KEYWORD_NOEXCEPT;
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 2
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02>
bool holds_alternative(
                      const variant<HEAD, TAIL_01,
                                          TAIL_02>& obj) BSLS_KEYWORD_NOEXCEPT;
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 3
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03>
bool holds_alternative(
                      const variant<HEAD, TAIL_01,
                                          TAIL_02,
                                          TAIL_03>& obj) BSLS_KEYWORD_NOEXCEPT;
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 4
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04>
bool holds_alternative(
                      const variant<HEAD, TAIL_01,
                                          TAIL_02,
                                          TAIL_03,
                                          TAIL_04>& obj) BSLS_KEYWORD_NOEXCEPT;
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 5
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05>
bool holds_alternative(
                      const variant<HEAD, TAIL_01,
                                          TAIL_02,
                                          TAIL_03,
                                          TAIL_04,
                                          TAIL_05>& obj) BSLS_KEYWORD_NOEXCEPT;
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 6
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06>
bool holds_alternative(
                      const variant<HEAD, TAIL_01,
                                          TAIL_02,
                                          TAIL_03,
                                          TAIL_04,
                                          TAIL_05,
                                          TAIL_06>& obj) BSLS_KEYWORD_NOEXCEPT;
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 7
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07>
bool holds_alternative(
                      const variant<HEAD, TAIL_01,
                                          TAIL_02,
                                          TAIL_03,
                                          TAIL_04,
                                          TAIL_05,
                                          TAIL_06,
                                          TAIL_07>& obj) BSLS_KEYWORD_NOEXCEPT;
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 8
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08>
bool holds_alternative(
                      const variant<HEAD, TAIL_01,
                                          TAIL_02,
                                          TAIL_03,
                                          TAIL_04,
                                          TAIL_05,
                                          TAIL_06,
                                          TAIL_07,
                                          TAIL_08>& obj) BSLS_KEYWORD_NOEXCEPT;
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 9
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08,
                                  class TAIL_09>
bool holds_alternative(
                      const variant<HEAD, TAIL_01,
                                          TAIL_02,
                                          TAIL_03,
                                          TAIL_04,
                                          TAIL_05,
                                          TAIL_06,
                                          TAIL_07,
                                          TAIL_08,
                                          TAIL_09>& obj) BSLS_KEYWORD_NOEXCEPT;
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 10
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08,
                                  class TAIL_09,
                                  class TAIL_10>
bool holds_alternative(
                      const variant<HEAD, TAIL_01,
                                          TAIL_02,
                                          TAIL_03,
                                          TAIL_04,
                                          TAIL_05,
                                          TAIL_06,
                                          TAIL_07,
                                          TAIL_08,
                                          TAIL_09,
                                          TAIL_10>& obj) BSLS_KEYWORD_NOEXCEPT;
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_C >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <size_t INDEX, class HEAD = BSLSTL_VARIANT_NOT_A_TYPE, class... TAIL>
struct Variant_VariantAlternativeImpl
: Variant_VariantAlternativeImpl<INDEX - 1, TAIL...> {
};

template <size_t INDEX>
struct Variant_VariantAlternativeImpl<INDEX, BSLSTL_VARIANT_NOT_A_TYPE> {
};

template <>
struct Variant_VariantAlternativeImpl<0, BSLSTL_VARIANT_NOT_A_TYPE> {
};

template <class HEAD, class... TAIL>
struct Variant_VariantAlternativeImpl<0, HEAD, TAIL...> {
    typedef HEAD type;
};

template <size_t INDEX, class HEAD, class... TAIL>
struct variant_alternative<INDEX, variant<HEAD, TAIL...> >
: Variant_VariantAlternativeImpl<INDEX, HEAD, TAIL...> {
    BSLMF_ASSERT((INDEX < bsl::variant_size<variant<HEAD, TAIL...> >::value));
};

#ifdef BSLS_COMPILERFEATURES_SUPPORT_ALIAS_TEMPLATES
template <size_t INDEX, class TYPE>
using variant_alternative_t = typename variant_alternative<INDEX, TYPE>::type;
#endif

template <class HEAD, class... TAIL>
void swap(bsl::variant<HEAD, TAIL...>& lhs, bsl::variant<HEAD, TAIL...>& rhs);

template <class HASHALG, class HEAD, class... TAIL>
void hashAppend(HASHALG& hashAlg, const variant<HEAD, TAIL...>& input);

template <class TYPE, class HEAD, class... TAIL>
bool holds_alternative(
                      const variant<HEAD, TAIL...>& obj) BSLS_KEYWORD_NOEXCEPT;
// }}} END GENERATED CODE
#endif
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
template <size_t INDEX, class HEAD, class... TAIL>
typename variant_alternative<INDEX, variant<HEAD, TAIL...> >::type& get(
                                                  variant<HEAD, TAIL...>& obj);
template <size_t INDEX, class HEAD, class... TAIL>
const typename variant_alternative<INDEX, variant<HEAD, TAIL...> >::type& get(
                                            const variant<HEAD, TAIL...>& obj);
template <size_t INDEX, class HEAD, class... TAIL>
typename variant_alternative<INDEX, variant<HEAD, TAIL...> >::type&& get(
                                                 variant<HEAD, TAIL...>&& obj);
template <size_t INDEX, class HEAD, class... TAIL>
const typename variant_alternative<INDEX, variant<HEAD, TAIL...> >::type&& get(
                                           const variant<HEAD, TAIL...>&& obj);
    // Return a reference to the alternative object at index (template
    // parameter) 'INDEX' in the specified 'obj'.  If 'INDEX' is not the index
    // of the currently active alternative, an exception of type
    // 'bad_variant_access' is thrown.  'INDEX' shall be a valid index for the
    // variant type of 'obj'.

template <class TYPE, class HEAD, class... TAIL>
TYPE& get(variant<HEAD, TAIL...>& obj);
template <class TYPE, class HEAD, class... TAIL>
const TYPE& get(const variant<HEAD, TAIL...>& obj);
template <class TYPE, class HEAD, class... TAIL>
TYPE&& get(variant<HEAD, TAIL...>&& obj);
template <class TYPE, class HEAD, class... TAIL>
const TYPE&& get(const variant<HEAD, TAIL...>&& obj);
    // Return a reference to the alternative object with type (template
    // parameter) 'TYPE' in the specified 'obj'.  If 'TYPE' is not the type of
    // the currently active alternative, an exception of type
    // 'bad_variant_access' is thrown.  'TYPE' shall appear exactly once in the
    // variant's list of alternatives.

template <size_t INDEX, class HEAD, class... TAIL>
typename add_pointer<
    typename variant_alternative<INDEX, variant<HEAD, TAIL...> >::type>::type
get_if(variant<HEAD, TAIL...> *obj) BSLS_KEYWORD_NOEXCEPT;
template <size_t INDEX, class HEAD, class... TAIL>
typename add_pointer<
    const typename variant_alternative<INDEX,
                                       variant<HEAD, TAIL...> >::type>::type
get_if(const variant<HEAD, TAIL...> *obj) BSLS_KEYWORD_NOEXCEPT;
    // Return a pointer to the alternative object with index (template
    // parameter) 'INDEX' in the specified 'obj', or a null pointer if 'obj' is
    // a null pointer or if 'INDEX' is not the index of the currently active
    // alternative.  'INDEX' shall be a valid alternative index.

template <class TYPE, class HEAD, class... TAIL>
typename add_pointer<TYPE>::type get_if(
                            variant<HEAD, TAIL...> *obj) BSLS_KEYWORD_NOEXCEPT;
template <class TYPE, class HEAD, class... TAIL>
typename add_pointer<const TYPE>::type get_if(
                      const variant<HEAD, TAIL...> *obj) BSLS_KEYWORD_NOEXCEPT;
    // Return a pointer to the alternative object with type (template
    // parameter) 'TYPE' in the specified 'obj', or a null pointer if 'obj' is
    // a null pointer or if 'TYPE' is not the type of the currently active
    // alternative.  'TYPE' shall appear exactly once in the variant's list of
    // alternatives.
#else  // BSL_VARIANT_FULL_IMPLEMENTATION
#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_variant.h
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT
#define BSLSTL_VARIANT_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT_D
#define BSLSTL_VARIANT_VARIADIC_LIMIT_D BSLSTL_VARIANT_VARIADIC_LIMIT
#endif

template <class TYPE,
          class HEAD
#if BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 0
        , class TAIL_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 1
        , class TAIL_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 2
        , class TAIL_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 3
        , class TAIL_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 4
        , class TAIL_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 5
        , class TAIL_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 6
        , class TAIL_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 7
        , class TAIL_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 8
        , class TAIL_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 9
        , class TAIL_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 9
        , class = BSLS_COMPILERFEATURES_NILT>
struct Variant_ReturnType;


#if BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 0
template <class TYPE, class HEAD>
struct Variant_ReturnType<TYPE, bsl::variant<HEAD> > {
    typedef TYPE                             type;
    typedef typename add_pointer<TYPE>::type pointer;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 1
template <class TYPE, class HEAD, class TAIL_01>
struct Variant_ReturnType<TYPE, bsl::variant<HEAD, TAIL_01> > {
    typedef TYPE                             type;
    typedef typename add_pointer<TYPE>::type pointer;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 2
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02>
struct Variant_ReturnType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                   TAIL_02> > {
    typedef TYPE                             type;
    typedef typename add_pointer<TYPE>::type pointer;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 3
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03>
struct Variant_ReturnType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                   TAIL_02,
                                                   TAIL_03> > {
    typedef TYPE                             type;
    typedef typename add_pointer<TYPE>::type pointer;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 4
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04>
struct Variant_ReturnType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                   TAIL_02,
                                                   TAIL_03,
                                                   TAIL_04> > {
    typedef TYPE                             type;
    typedef typename add_pointer<TYPE>::type pointer;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 5
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05>
struct Variant_ReturnType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                   TAIL_02,
                                                   TAIL_03,
                                                   TAIL_04,
                                                   TAIL_05> > {
    typedef TYPE                             type;
    typedef typename add_pointer<TYPE>::type pointer;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 6
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06>
struct Variant_ReturnType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                   TAIL_02,
                                                   TAIL_03,
                                                   TAIL_04,
                                                   TAIL_05,
                                                   TAIL_06> > {
    typedef TYPE                             type;
    typedef typename add_pointer<TYPE>::type pointer;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 7
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07>
struct Variant_ReturnType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                   TAIL_02,
                                                   TAIL_03,
                                                   TAIL_04,
                                                   TAIL_05,
                                                   TAIL_06,
                                                   TAIL_07> > {
    typedef TYPE                             type;
    typedef typename add_pointer<TYPE>::type pointer;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 8
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08>
struct Variant_ReturnType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                   TAIL_02,
                                                   TAIL_03,
                                                   TAIL_04,
                                                   TAIL_05,
                                                   TAIL_06,
                                                   TAIL_07,
                                                   TAIL_08> > {
    typedef TYPE                             type;
    typedef typename add_pointer<TYPE>::type pointer;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 9
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08,
                                  class TAIL_09>
struct Variant_ReturnType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                   TAIL_02,
                                                   TAIL_03,
                                                   TAIL_04,
                                                   TAIL_05,
                                                   TAIL_06,
                                                   TAIL_07,
                                                   TAIL_08,
                                                   TAIL_09> > {
    typedef TYPE                             type;
    typedef typename add_pointer<TYPE>::type pointer;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 10
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08,
                                  class TAIL_09,
                                  class TAIL_10>
struct Variant_ReturnType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                   TAIL_02,
                                                   TAIL_03,
                                                   TAIL_04,
                                                   TAIL_05,
                                                   TAIL_06,
                                                   TAIL_07,
                                                   TAIL_08,
                                                   TAIL_09,
                                                   TAIL_10> > {
    typedef TYPE                             type;
    typedef typename add_pointer<TYPE>::type pointer;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_D >= 10


template <size_t INDEX, class VARIANT>
typename Variant_ReturnType<
    typename variant_alternative<INDEX, VARIANT>::type&,
    VARIANT>::type
get(VARIANT&                                obj);
template <size_t INDEX, class VARIANT>
typename Variant_ReturnType<
    const typename variant_alternative<INDEX, VARIANT>::type&,
    VARIANT>::type
get(const VARIANT&                          obj);
template <size_t INDEX, class VARIANT>
typename Variant_ReturnType<
    BloombergLP::bslmf::MovableRef<
        typename variant_alternative<INDEX, VARIANT>::type>,
    VARIANT>::type
get(BloombergLP::bslmf::MovableRef<VARIANT> obj);

template <class TYPE, class VARIANT>
typename Variant_ReturnType<TYPE&, VARIANT>::type
get(VARIANT&                                obj);
template <class TYPE, class VARIANT>
typename Variant_ReturnType<const TYPE&, VARIANT>::type
get(const VARIANT&                          obj);
template <class TYPE, class VARIANT>
typename Variant_ReturnType<BloombergLP::bslmf::MovableRef<TYPE>,
                            VARIANT>::type
get(BloombergLP::bslmf::MovableRef<VARIANT> obj);

template <size_t INDEX, class VARIANT>
typename Variant_ReturnType<typename variant_alternative<INDEX, VARIANT>::type,
                            VARIANT>::pointer
get_if(VARIANT       *obj) BSLS_KEYWORD_NOEXCEPT;
template <size_t INDEX, class VARIANT>
typename Variant_ReturnType<
    const typename variant_alternative<INDEX, VARIANT>::type,
    VARIANT>::pointer
get_if(const VARIANT *obj) BSLS_KEYWORD_NOEXCEPT;

template <class TYPE, class VARIANT>
typename Variant_ReturnType<TYPE, VARIANT>::pointer       get_if(
                                                            VARIANT       *obj)
                                                         BSLS_KEYWORD_NOEXCEPT;
template <class TYPE, class VARIANT>
typename Variant_ReturnType<const TYPE, VARIANT>::pointer get_if(
                                                            const VARIANT *obj)
                                                         BSLS_KEYWORD_NOEXCEPT;
#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.

template <class TYPE, class HEAD, class... TAIL>
struct Variant_ReturnType;

template <class TYPE, class HEAD, class... TAIL>
struct Variant_ReturnType<TYPE, bsl::variant<HEAD, TAIL...> > {
    typedef TYPE                             type;
    typedef typename add_pointer<TYPE>::type pointer;
};

template <size_t INDEX, class VARIANT>
typename Variant_ReturnType<
    typename variant_alternative<INDEX, VARIANT>::type&,
    VARIANT>::type
get(VARIANT&                                obj);
template <size_t INDEX, class VARIANT>
typename Variant_ReturnType<
    const typename variant_alternative<INDEX, VARIANT>::type&,
    VARIANT>::type
get(const VARIANT&                          obj);
template <size_t INDEX, class VARIANT>
typename Variant_ReturnType<
    BloombergLP::bslmf::MovableRef<
        typename variant_alternative<INDEX, VARIANT>::type>,
    VARIANT>::type
get(BloombergLP::bslmf::MovableRef<VARIANT> obj);

template <class TYPE, class VARIANT>
typename Variant_ReturnType<TYPE&, VARIANT>::type
get(VARIANT&                                obj);
template <class TYPE, class VARIANT>
typename Variant_ReturnType<const TYPE&, VARIANT>::type
get(const VARIANT&                          obj);
template <class TYPE, class VARIANT>
typename Variant_ReturnType<BloombergLP::bslmf::MovableRef<TYPE>,
                            VARIANT>::type
get(BloombergLP::bslmf::MovableRef<VARIANT> obj);

template <size_t INDEX, class VARIANT>
typename Variant_ReturnType<typename variant_alternative<INDEX, VARIANT>::type,
                            VARIANT>::pointer
get_if(VARIANT       *obj) BSLS_KEYWORD_NOEXCEPT;
template <size_t INDEX, class VARIANT>
typename Variant_ReturnType<
    const typename variant_alternative<INDEX, VARIANT>::type,
    VARIANT>::pointer
get_if(const VARIANT *obj) BSLS_KEYWORD_NOEXCEPT;

template <class TYPE, class VARIANT>
typename Variant_ReturnType<TYPE, VARIANT>::pointer       get_if(
                                                            VARIANT       *obj)
                                                         BSLS_KEYWORD_NOEXCEPT;
template <class TYPE, class VARIANT>
typename Variant_ReturnType<const TYPE, VARIANT>::pointer get_if(
                                                            const VARIANT *obj)
                                                         BSLS_KEYWORD_NOEXCEPT;
// }}} END GENERATED CODE
#endif
#endif  // BSL_VARIANT_FULL_IMPLEMENTATION
// FREE OPERATORS

// 20.7.6, relational operators
#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_variant.h
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT
#define BSLSTL_VARIANT_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT_E
#define BSLSTL_VARIANT_VARIADIC_LIMIT_E BSLSTL_VARIANT_VARIADIC_LIMIT
#endif
#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0
template <class HEAD>
bool operator==(const variant<HEAD>& lhs,
                const variant<HEAD>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1
template <class HEAD, class TAIL_01>
bool operator==(const variant<HEAD, TAIL_01>& lhs,
                const variant<HEAD, TAIL_01>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
bool operator==(const variant<HEAD, TAIL_01,
                                    TAIL_02>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
bool operator==(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
bool operator==(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
bool operator==(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
bool operator==(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
bool operator==(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
bool operator==(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
bool operator==(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
bool operator==(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09,
                                    TAIL_10>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09,
                                    TAIL_10>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0
template <class HEAD>
bool operator!=(const variant<HEAD>& lhs,
                const variant<HEAD>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1
template <class HEAD, class TAIL_01>
bool operator!=(const variant<HEAD, TAIL_01>& lhs,
                const variant<HEAD, TAIL_01>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
bool operator!=(const variant<HEAD, TAIL_01,
                                    TAIL_02>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
bool operator!=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
bool operator!=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
bool operator!=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
bool operator!=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
bool operator!=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
bool operator!=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
bool operator!=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
bool operator!=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09,
                                    TAIL_10>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09,
                                    TAIL_10>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0
template <class HEAD>
bool operator<(const variant<HEAD>& lhs,
               const variant<HEAD>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1
template <class HEAD, class TAIL_01>
bool operator<(const variant<HEAD, TAIL_01>& lhs,
               const variant<HEAD, TAIL_01>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
bool operator<(const variant<HEAD, TAIL_01,
                                   TAIL_02>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
bool operator<(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
bool operator<(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
bool operator<(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
bool operator<(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
bool operator<(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
bool operator<(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
bool operator<(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08,
                                   TAIL_09>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08,
                                   TAIL_09>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
bool operator<(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08,
                                   TAIL_09,
                                   TAIL_10>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08,
                                   TAIL_09,
                                   TAIL_10>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0
template <class HEAD>
bool operator>(const variant<HEAD>& lhs,
               const variant<HEAD>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1
template <class HEAD, class TAIL_01>
bool operator>(const variant<HEAD, TAIL_01>& lhs,
               const variant<HEAD, TAIL_01>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
bool operator>(const variant<HEAD, TAIL_01,
                                   TAIL_02>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
bool operator>(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
bool operator>(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
bool operator>(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
bool operator>(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
bool operator>(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
bool operator>(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
bool operator>(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08,
                                   TAIL_09>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08,
                                   TAIL_09>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
bool operator>(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08,
                                   TAIL_09,
                                   TAIL_10>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08,
                                   TAIL_09,
                                   TAIL_10>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0
template <class HEAD>
bool operator<=(const variant<HEAD>& lhs,
                const variant<HEAD>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1
template <class HEAD, class TAIL_01>
bool operator<=(const variant<HEAD, TAIL_01>& lhs,
                const variant<HEAD, TAIL_01>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
bool operator<=(const variant<HEAD, TAIL_01,
                                    TAIL_02>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
bool operator<=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
bool operator<=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
bool operator<=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
bool operator<=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
bool operator<=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
bool operator<=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
bool operator<=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
bool operator<=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09,
                                    TAIL_10>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09,
                                    TAIL_10>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0
template <class HEAD>
bool operator>=(const variant<HEAD>& lhs,
                const variant<HEAD>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1
template <class HEAD, class TAIL_01>
bool operator>=(const variant<HEAD, TAIL_01>& lhs,
                const variant<HEAD, TAIL_01>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
bool operator>=(const variant<HEAD, TAIL_01,
                                    TAIL_02>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
bool operator>=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
bool operator>=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
bool operator>=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
bool operator>=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
bool operator>=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
bool operator>=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
bool operator>=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
bool operator>=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09,
                                    TAIL_10>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09,
                                    TAIL_10>& rhs);
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10

}

namespace BloombergLP {
namespace bslstl {

template <class TYPE = BSLSTL_VARIANT_NOT_A_TYPE
#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0
        , class OTHER_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1
        , class OTHER_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2
        , class OTHER_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3
        , class OTHER_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4
        , class OTHER_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5
        , class OTHER_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6
        , class OTHER_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7
        , class OTHER_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8
        , class OTHER_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
        , class OTHER_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
        , class = BSLS_COMPILERFEATURES_NILT>
struct Variant_UsesBslmaAllocatorAny;


template <>
struct Variant_UsesBslmaAllocatorAny<BSLSTL_VARIANT_NOT_A_TYPE>
: bsl::false_type {
};

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0
template <class TYPE>
struct Variant_UsesBslmaAllocatorAny<TYPE>
: bsl::integral_constant<
      bool,
      BloombergLP::bslma::UsesBslmaAllocator<TYPE>::value ||
          BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<
              >::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1
template <class TYPE, class OTHER_01>
struct Variant_UsesBslmaAllocatorAny<TYPE, OTHER_01>
: bsl::integral_constant<
      bool,
      BloombergLP::bslma::UsesBslmaAllocator<TYPE>::value ||
          BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<
              OTHER_01>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2
template <class TYPE, class OTHER_01,
                      class OTHER_02>
struct Variant_UsesBslmaAllocatorAny<TYPE, OTHER_01,
                                           OTHER_02>
: bsl::integral_constant<
      bool,
      BloombergLP::bslma::UsesBslmaAllocator<TYPE>::value ||
          BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<
              OTHER_01,
              OTHER_02>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3
template <class TYPE, class OTHER_01,
                      class OTHER_02,
                      class OTHER_03>
struct Variant_UsesBslmaAllocatorAny<TYPE, OTHER_01,
                                           OTHER_02,
                                           OTHER_03>
: bsl::integral_constant<
      bool,
      BloombergLP::bslma::UsesBslmaAllocator<TYPE>::value ||
          BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<
              OTHER_01,
              OTHER_02,
              OTHER_03>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4
template <class TYPE, class OTHER_01,
                      class OTHER_02,
                      class OTHER_03,
                      class OTHER_04>
struct Variant_UsesBslmaAllocatorAny<TYPE, OTHER_01,
                                           OTHER_02,
                                           OTHER_03,
                                           OTHER_04>
: bsl::integral_constant<
      bool,
      BloombergLP::bslma::UsesBslmaAllocator<TYPE>::value ||
          BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<
              OTHER_01,
              OTHER_02,
              OTHER_03,
              OTHER_04>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5
template <class TYPE, class OTHER_01,
                      class OTHER_02,
                      class OTHER_03,
                      class OTHER_04,
                      class OTHER_05>
struct Variant_UsesBslmaAllocatorAny<TYPE, OTHER_01,
                                           OTHER_02,
                                           OTHER_03,
                                           OTHER_04,
                                           OTHER_05>
: bsl::integral_constant<
      bool,
      BloombergLP::bslma::UsesBslmaAllocator<TYPE>::value ||
          BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<
              OTHER_01,
              OTHER_02,
              OTHER_03,
              OTHER_04,
              OTHER_05>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6
template <class TYPE, class OTHER_01,
                      class OTHER_02,
                      class OTHER_03,
                      class OTHER_04,
                      class OTHER_05,
                      class OTHER_06>
struct Variant_UsesBslmaAllocatorAny<TYPE, OTHER_01,
                                           OTHER_02,
                                           OTHER_03,
                                           OTHER_04,
                                           OTHER_05,
                                           OTHER_06>
: bsl::integral_constant<
      bool,
      BloombergLP::bslma::UsesBslmaAllocator<TYPE>::value ||
          BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<
              OTHER_01,
              OTHER_02,
              OTHER_03,
              OTHER_04,
              OTHER_05,
              OTHER_06>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7
template <class TYPE, class OTHER_01,
                      class OTHER_02,
                      class OTHER_03,
                      class OTHER_04,
                      class OTHER_05,
                      class OTHER_06,
                      class OTHER_07>
struct Variant_UsesBslmaAllocatorAny<TYPE, OTHER_01,
                                           OTHER_02,
                                           OTHER_03,
                                           OTHER_04,
                                           OTHER_05,
                                           OTHER_06,
                                           OTHER_07>
: bsl::integral_constant<
      bool,
      BloombergLP::bslma::UsesBslmaAllocator<TYPE>::value ||
          BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<
              OTHER_01,
              OTHER_02,
              OTHER_03,
              OTHER_04,
              OTHER_05,
              OTHER_06,
              OTHER_07>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8
template <class TYPE, class OTHER_01,
                      class OTHER_02,
                      class OTHER_03,
                      class OTHER_04,
                      class OTHER_05,
                      class OTHER_06,
                      class OTHER_07,
                      class OTHER_08>
struct Variant_UsesBslmaAllocatorAny<TYPE, OTHER_01,
                                           OTHER_02,
                                           OTHER_03,
                                           OTHER_04,
                                           OTHER_05,
                                           OTHER_06,
                                           OTHER_07,
                                           OTHER_08>
: bsl::integral_constant<
      bool,
      BloombergLP::bslma::UsesBslmaAllocator<TYPE>::value ||
          BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<
              OTHER_01,
              OTHER_02,
              OTHER_03,
              OTHER_04,
              OTHER_05,
              OTHER_06,
              OTHER_07,
              OTHER_08>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
template <class TYPE, class OTHER_01,
                      class OTHER_02,
                      class OTHER_03,
                      class OTHER_04,
                      class OTHER_05,
                      class OTHER_06,
                      class OTHER_07,
                      class OTHER_08,
                      class OTHER_09>
struct Variant_UsesBslmaAllocatorAny<TYPE, OTHER_01,
                                           OTHER_02,
                                           OTHER_03,
                                           OTHER_04,
                                           OTHER_05,
                                           OTHER_06,
                                           OTHER_07,
                                           OTHER_08,
                                           OTHER_09>
: bsl::integral_constant<
      bool,
      BloombergLP::bslma::UsesBslmaAllocator<TYPE>::value ||
          BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<
              OTHER_01,
              OTHER_02,
              OTHER_03,
              OTHER_04,
              OTHER_05,
              OTHER_06,
              OTHER_07,
              OTHER_08,
              OTHER_09>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10
template <class TYPE, class OTHER_01,
                      class OTHER_02,
                      class OTHER_03,
                      class OTHER_04,
                      class OTHER_05,
                      class OTHER_06,
                      class OTHER_07,
                      class OTHER_08,
                      class OTHER_09,
                      class OTHER_10>
struct Variant_UsesBslmaAllocatorAny<TYPE, OTHER_01,
                                           OTHER_02,
                                           OTHER_03,
                                           OTHER_04,
                                           OTHER_05,
                                           OTHER_06,
                                           OTHER_07,
                                           OTHER_08,
                                           OTHER_09,
                                           OTHER_10>
: bsl::integral_constant<
      bool,
      BloombergLP::bslma::UsesBslmaAllocator<TYPE>::value ||
          BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<
              OTHER_01,
              OTHER_02,
              OTHER_03,
              OTHER_04,
              OTHER_05,
              OTHER_06,
              OTHER_07,
              OTHER_08,
              OTHER_09,
              OTHER_10>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10


template <class TYPE = BSLSTL_VARIANT_NOT_A_TYPE
#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0
        , class OTHER_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1
        , class OTHER_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2
        , class OTHER_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3
        , class OTHER_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4
        , class OTHER_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5
        , class OTHER_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6
        , class OTHER_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7
        , class OTHER_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8
        , class OTHER_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
        , class OTHER_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
        , class = BSLS_COMPILERFEATURES_NILT>
struct Variant_IsBitwiseMoveableAll;


template <>
struct Variant_IsBitwiseMoveableAll<BSLSTL_VARIANT_NOT_A_TYPE>
: bsl::true_type {
};

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0
template <class TYPE>
struct Variant_IsBitwiseMoveableAll<TYPE>
: bsl::integral_constant<bool,
                         BloombergLP::bslmf::IsBitwiseMoveable<TYPE>::value &&
                             Variant_IsBitwiseMoveableAll<>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1
template <class TYPE, class OTHER_01>
struct Variant_IsBitwiseMoveableAll<TYPE, OTHER_01>
: bsl::integral_constant<bool,
                         BloombergLP::bslmf::IsBitwiseMoveable<TYPE>::value &&
                             Variant_IsBitwiseMoveableAll<OTHER_01>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2
template <class TYPE, class OTHER_01,
                      class OTHER_02>
struct Variant_IsBitwiseMoveableAll<TYPE, OTHER_01,
                                          OTHER_02>
: bsl::integral_constant<bool,
                         BloombergLP::bslmf::IsBitwiseMoveable<TYPE>::value &&
                             Variant_IsBitwiseMoveableAll<OTHER_01,
                                                          OTHER_02>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3
template <class TYPE, class OTHER_01,
                      class OTHER_02,
                      class OTHER_03>
struct Variant_IsBitwiseMoveableAll<TYPE, OTHER_01,
                                          OTHER_02,
                                          OTHER_03>
: bsl::integral_constant<bool,
                         BloombergLP::bslmf::IsBitwiseMoveable<TYPE>::value &&
                             Variant_IsBitwiseMoveableAll<OTHER_01,
                                                          OTHER_02,
                                                          OTHER_03>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4
template <class TYPE, class OTHER_01,
                      class OTHER_02,
                      class OTHER_03,
                      class OTHER_04>
struct Variant_IsBitwiseMoveableAll<TYPE, OTHER_01,
                                          OTHER_02,
                                          OTHER_03,
                                          OTHER_04>
: bsl::integral_constant<bool,
                         BloombergLP::bslmf::IsBitwiseMoveable<TYPE>::value &&
                             Variant_IsBitwiseMoveableAll<OTHER_01,
                                                          OTHER_02,
                                                          OTHER_03,
                                                          OTHER_04>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5
template <class TYPE, class OTHER_01,
                      class OTHER_02,
                      class OTHER_03,
                      class OTHER_04,
                      class OTHER_05>
struct Variant_IsBitwiseMoveableAll<TYPE, OTHER_01,
                                          OTHER_02,
                                          OTHER_03,
                                          OTHER_04,
                                          OTHER_05>
: bsl::integral_constant<bool,
                         BloombergLP::bslmf::IsBitwiseMoveable<TYPE>::value &&
                             Variant_IsBitwiseMoveableAll<OTHER_01,
                                                          OTHER_02,
                                                          OTHER_03,
                                                          OTHER_04,
                                                          OTHER_05>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6
template <class TYPE, class OTHER_01,
                      class OTHER_02,
                      class OTHER_03,
                      class OTHER_04,
                      class OTHER_05,
                      class OTHER_06>
struct Variant_IsBitwiseMoveableAll<TYPE, OTHER_01,
                                          OTHER_02,
                                          OTHER_03,
                                          OTHER_04,
                                          OTHER_05,
                                          OTHER_06>
: bsl::integral_constant<bool,
                         BloombergLP::bslmf::IsBitwiseMoveable<TYPE>::value &&
                             Variant_IsBitwiseMoveableAll<OTHER_01,
                                                          OTHER_02,
                                                          OTHER_03,
                                                          OTHER_04,
                                                          OTHER_05,
                                                          OTHER_06>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7
template <class TYPE, class OTHER_01,
                      class OTHER_02,
                      class OTHER_03,
                      class OTHER_04,
                      class OTHER_05,
                      class OTHER_06,
                      class OTHER_07>
struct Variant_IsBitwiseMoveableAll<TYPE, OTHER_01,
                                          OTHER_02,
                                          OTHER_03,
                                          OTHER_04,
                                          OTHER_05,
                                          OTHER_06,
                                          OTHER_07>
: bsl::integral_constant<bool,
                         BloombergLP::bslmf::IsBitwiseMoveable<TYPE>::value &&
                             Variant_IsBitwiseMoveableAll<OTHER_01,
                                                          OTHER_02,
                                                          OTHER_03,
                                                          OTHER_04,
                                                          OTHER_05,
                                                          OTHER_06,
                                                          OTHER_07>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8
template <class TYPE, class OTHER_01,
                      class OTHER_02,
                      class OTHER_03,
                      class OTHER_04,
                      class OTHER_05,
                      class OTHER_06,
                      class OTHER_07,
                      class OTHER_08>
struct Variant_IsBitwiseMoveableAll<TYPE, OTHER_01,
                                          OTHER_02,
                                          OTHER_03,
                                          OTHER_04,
                                          OTHER_05,
                                          OTHER_06,
                                          OTHER_07,
                                          OTHER_08>
: bsl::integral_constant<bool,
                         BloombergLP::bslmf::IsBitwiseMoveable<TYPE>::value &&
                             Variant_IsBitwiseMoveableAll<OTHER_01,
                                                          OTHER_02,
                                                          OTHER_03,
                                                          OTHER_04,
                                                          OTHER_05,
                                                          OTHER_06,
                                                          OTHER_07,
                                                          OTHER_08>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
template <class TYPE, class OTHER_01,
                      class OTHER_02,
                      class OTHER_03,
                      class OTHER_04,
                      class OTHER_05,
                      class OTHER_06,
                      class OTHER_07,
                      class OTHER_08,
                      class OTHER_09>
struct Variant_IsBitwiseMoveableAll<TYPE, OTHER_01,
                                          OTHER_02,
                                          OTHER_03,
                                          OTHER_04,
                                          OTHER_05,
                                          OTHER_06,
                                          OTHER_07,
                                          OTHER_08,
                                          OTHER_09>
: bsl::integral_constant<bool,
                         BloombergLP::bslmf::IsBitwiseMoveable<TYPE>::value &&
                             Variant_IsBitwiseMoveableAll<OTHER_01,
                                                          OTHER_02,
                                                          OTHER_03,
                                                          OTHER_04,
                                                          OTHER_05,
                                                          OTHER_06,
                                                          OTHER_07,
                                                          OTHER_08,
                                                          OTHER_09>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10
template <class TYPE, class OTHER_01,
                      class OTHER_02,
                      class OTHER_03,
                      class OTHER_04,
                      class OTHER_05,
                      class OTHER_06,
                      class OTHER_07,
                      class OTHER_08,
                      class OTHER_09,
                      class OTHER_10>
struct Variant_IsBitwiseMoveableAll<TYPE, OTHER_01,
                                          OTHER_02,
                                          OTHER_03,
                                          OTHER_04,
                                          OTHER_05,
                                          OTHER_06,
                                          OTHER_07,
                                          OTHER_08,
                                          OTHER_09,
                                          OTHER_10>
: bsl::integral_constant<bool,
                         BloombergLP::bslmf::IsBitwiseMoveable<TYPE>::value &&
                             Variant_IsBitwiseMoveableAll<OTHER_01,
                                                          OTHER_02,
                                                          OTHER_03,
                                                          OTHER_04,
                                                          OTHER_05,
                                                          OTHER_06,
                                                          OTHER_07,
                                                          OTHER_08,
                                                          OTHER_09,
                                                          OTHER_10>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10


template <class TYPE>
struct Variant_IsTag : bsl::false_type {
};

template <>
struct Variant_IsTag<bsl::allocator_arg_t> : bsl::true_type {
};

template <class TYPE>
struct Variant_IsTag<bsl::in_place_type_t<TYPE> > : bsl::true_type {
};

template <size_t INDEX>
struct Variant_IsTag<bsl::in_place_index_t<INDEX> > : bsl::true_type {
};

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
template <class t_TO, class t_FROM>
struct Variant_IsConstructible : std::is_constructible<t_TO, t_FROM> {
};

template <class t_LHS, class t_RHS>
struct Variant_IsAssignable : std::is_assignable<t_LHS, t_RHS> {
};
#else
template <class t_TO, class t_FROM>
struct Variant_IsConstructible : bsl::true_type {
};

template <class t_LHS, class t_RHS>
struct Variant_IsAssignable : bsl::true_type {
};
#endif

#define BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(VARIANT, TYPE)               \
    typename bsl::enable_if<                                                  \
        BloombergLP::bslstl::Variant_ConstructsFromType<VARIANT,              \
                                                        TYPE>::value,         \
        BloombergLP::bslstl::Variant_NoSuchType>::type

#define BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(VARIANT, TYPE)              \
    BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(                                 \
                        VARIANT,                                              \
                        TYPE) = BloombergLP::bslstl::Variant_NoSuchType(0)

#define BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE)                        \
    typename bsl::enable_if<                                                  \
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,     \
        BloombergLP::bslstl::Variant_NoSuchType>::type

#define BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE)                       \
    BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(                                 \
                           TYPE) = BloombergLP::bslstl::Variant_NoSuchType(0)

#define BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE)                                  \
    BloombergLP::bslstl::                                                     \
        Variant_HasUniqueType<TYPE, variant<HEAD, TAIL...> >::value

#define BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX)                                   \
    typename bsl::variant_alternative<INDEX,                                  \
                                      bsl::variant<HEAD, TAIL...> >::type

#define BSLSTL_VARIANT_INDEX_OF(TYPE, VARIANT)                                \
    BloombergLP::bslstl::Variant_TypeToIndex<TYPE, VARIANT>::value

#define BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, VARIANT)                        \
    BloombergLP::bslstl::Variant_ConvertIndex<TYPE, VARIANT>::value

#define BSLSTL_VARIANT_CONVERT_TYPE_OF(TYPE, VARIANT)                         \
    typename bsl::variant_alternative<BSLSTL_VARIANT_CONVERT_INDEX_OF(        \
                                          TYPE, VARIANT),                     \
                                      VARIANT>::type

#define BSLSTL_VARIANT_VISITID(RET, VISITOR, VAROBJ)                          \
    BloombergLP::bslstl::Variant_VisitImplId<RET>(VISITOR, VAROBJ);

template <size_t INDEX,
          class TYPE,
          class HEAD = BSLSTL_VARIANT_NOT_A_TYPE
#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0
        , class TAIL_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1
        , class TAIL_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2
        , class TAIL_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3
        , class TAIL_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4
        , class TAIL_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5
        , class TAIL_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6
        , class TAIL_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7
        , class TAIL_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8
        , class TAIL_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
        , class TAIL_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
        , class = BSLS_COMPILERFEATURES_NILT>
struct Variant_TypeToIndexImpl;

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0
template <size_t INDEX, class TYPE, class HEAD>
struct Variant_TypeToIndexImpl<INDEX, TYPE, HEAD>
: bsl::conditional<bsl::is_same<TYPE, HEAD>::value,
                   bsl::integral_constant<size_t, INDEX>,
                   Variant_TypeToIndexImpl<INDEX + 1, TYPE> >::type {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1
template <size_t INDEX, class TYPE, class HEAD, class TAIL_01>
struct Variant_TypeToIndexImpl<INDEX, TYPE, HEAD, TAIL_01>
: bsl::conditional<bsl::is_same<TYPE, HEAD>::value,
                   bsl::integral_constant<size_t, INDEX>,
                   Variant_TypeToIndexImpl<INDEX + 1, TYPE, TAIL_01> >::type {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2
template <size_t INDEX, class TYPE, class HEAD, class TAIL_01,
                                                class TAIL_02>
struct Variant_TypeToIndexImpl<INDEX, TYPE, HEAD, TAIL_01,
                                                  TAIL_02>
: bsl::conditional<bsl::is_same<TYPE, HEAD>::value,
                   bsl::integral_constant<size_t, INDEX>,
                   Variant_TypeToIndexImpl<INDEX + 1, TYPE, TAIL_01,
                                                            TAIL_02> >::type {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3
template <size_t INDEX, class TYPE, class HEAD, class TAIL_01,
                                                class TAIL_02,
                                                class TAIL_03>
struct Variant_TypeToIndexImpl<INDEX, TYPE, HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03>
: bsl::conditional<bsl::is_same<TYPE, HEAD>::value,
                   bsl::integral_constant<size_t, INDEX>,
                   Variant_TypeToIndexImpl<INDEX + 1, TYPE, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03> >::type {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4
template <size_t INDEX, class TYPE, class HEAD, class TAIL_01,
                                                class TAIL_02,
                                                class TAIL_03,
                                                class TAIL_04>
struct Variant_TypeToIndexImpl<INDEX, TYPE, HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04>
: bsl::conditional<bsl::is_same<TYPE, HEAD>::value,
                   bsl::integral_constant<size_t, INDEX>,
                   Variant_TypeToIndexImpl<INDEX + 1, TYPE, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04> >::type {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5
template <size_t INDEX, class TYPE, class HEAD, class TAIL_01,
                                                class TAIL_02,
                                                class TAIL_03,
                                                class TAIL_04,
                                                class TAIL_05>
struct Variant_TypeToIndexImpl<INDEX, TYPE, HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05>
: bsl::conditional<bsl::is_same<TYPE, HEAD>::value,
                   bsl::integral_constant<size_t, INDEX>,
                   Variant_TypeToIndexImpl<INDEX + 1, TYPE, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05> >::type {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6
template <size_t INDEX, class TYPE, class HEAD, class TAIL_01,
                                                class TAIL_02,
                                                class TAIL_03,
                                                class TAIL_04,
                                                class TAIL_05,
                                                class TAIL_06>
struct Variant_TypeToIndexImpl<INDEX, TYPE, HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06>
: bsl::conditional<bsl::is_same<TYPE, HEAD>::value,
                   bsl::integral_constant<size_t, INDEX>,
                   Variant_TypeToIndexImpl<INDEX + 1, TYPE, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06> >::type {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7
template <size_t INDEX, class TYPE, class HEAD, class TAIL_01,
                                                class TAIL_02,
                                                class TAIL_03,
                                                class TAIL_04,
                                                class TAIL_05,
                                                class TAIL_06,
                                                class TAIL_07>
struct Variant_TypeToIndexImpl<INDEX, TYPE, HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06,
                                                  TAIL_07>
: bsl::conditional<bsl::is_same<TYPE, HEAD>::value,
                   bsl::integral_constant<size_t, INDEX>,
                   Variant_TypeToIndexImpl<INDEX + 1, TYPE, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07> >::type {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8
template <size_t INDEX, class TYPE, class HEAD, class TAIL_01,
                                                class TAIL_02,
                                                class TAIL_03,
                                                class TAIL_04,
                                                class TAIL_05,
                                                class TAIL_06,
                                                class TAIL_07,
                                                class TAIL_08>
struct Variant_TypeToIndexImpl<INDEX, TYPE, HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06,
                                                  TAIL_07,
                                                  TAIL_08>
: bsl::conditional<bsl::is_same<TYPE, HEAD>::value,
                   bsl::integral_constant<size_t, INDEX>,
                   Variant_TypeToIndexImpl<INDEX + 1, TYPE, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08> >::type {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
template <size_t INDEX, class TYPE, class HEAD, class TAIL_01,
                                                class TAIL_02,
                                                class TAIL_03,
                                                class TAIL_04,
                                                class TAIL_05,
                                                class TAIL_06,
                                                class TAIL_07,
                                                class TAIL_08,
                                                class TAIL_09>
struct Variant_TypeToIndexImpl<INDEX, TYPE, HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06,
                                                  TAIL_07,
                                                  TAIL_08,
                                                  TAIL_09>
: bsl::conditional<bsl::is_same<TYPE, HEAD>::value,
                   bsl::integral_constant<size_t, INDEX>,
                   Variant_TypeToIndexImpl<INDEX + 1, TYPE, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08,
                                                            TAIL_09> >::type {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10
template <size_t INDEX, class TYPE, class HEAD, class TAIL_01,
                                                class TAIL_02,
                                                class TAIL_03,
                                                class TAIL_04,
                                                class TAIL_05,
                                                class TAIL_06,
                                                class TAIL_07,
                                                class TAIL_08,
                                                class TAIL_09,
                                                class TAIL_10>
struct Variant_TypeToIndexImpl<INDEX, TYPE, HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06,
                                                  TAIL_07,
                                                  TAIL_08,
                                                  TAIL_09,
                                                  TAIL_10>
: bsl::conditional<bsl::is_same<TYPE, HEAD>::value,
                   bsl::integral_constant<size_t, INDEX>,
                   Variant_TypeToIndexImpl<INDEX + 1, TYPE, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08,
                                                            TAIL_09,
                                                            TAIL_10> >::type {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10


template <size_t INDEX, class TYPE>
struct Variant_TypeToIndexImpl<INDEX, TYPE, BSLSTL_VARIANT_NOT_A_TYPE>
: bsl::integral_constant<size_t, bsl::variant_npos> {
};

template <class TYPE, class VARIANT>
struct Variant_TypeToIndex;

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0
template <class TYPE, class HEAD>
struct Variant_TypeToIndex<TYPE, bsl::variant<HEAD> >
: Variant_TypeToIndexImpl<0, TYPE, HEAD> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1
template <class TYPE, class HEAD, class TAIL_01>
struct Variant_TypeToIndex<TYPE, bsl::variant<HEAD, TAIL_01> >
: Variant_TypeToIndexImpl<0, TYPE, HEAD, TAIL_01> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02>
struct Variant_TypeToIndex<TYPE, bsl::variant<HEAD, TAIL_01,
                                                    TAIL_02> >
: Variant_TypeToIndexImpl<0, TYPE, HEAD, TAIL_01,
                                         TAIL_02> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03>
struct Variant_TypeToIndex<TYPE, bsl::variant<HEAD, TAIL_01,
                                                    TAIL_02,
                                                    TAIL_03> >
: Variant_TypeToIndexImpl<0, TYPE, HEAD, TAIL_01,
                                         TAIL_02,
                                         TAIL_03> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04>
struct Variant_TypeToIndex<TYPE, bsl::variant<HEAD, TAIL_01,
                                                    TAIL_02,
                                                    TAIL_03,
                                                    TAIL_04> >
: Variant_TypeToIndexImpl<0, TYPE, HEAD, TAIL_01,
                                         TAIL_02,
                                         TAIL_03,
                                         TAIL_04> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05>
struct Variant_TypeToIndex<TYPE, bsl::variant<HEAD, TAIL_01,
                                                    TAIL_02,
                                                    TAIL_03,
                                                    TAIL_04,
                                                    TAIL_05> >
: Variant_TypeToIndexImpl<0, TYPE, HEAD, TAIL_01,
                                         TAIL_02,
                                         TAIL_03,
                                         TAIL_04,
                                         TAIL_05> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06>
struct Variant_TypeToIndex<TYPE, bsl::variant<HEAD, TAIL_01,
                                                    TAIL_02,
                                                    TAIL_03,
                                                    TAIL_04,
                                                    TAIL_05,
                                                    TAIL_06> >
: Variant_TypeToIndexImpl<0, TYPE, HEAD, TAIL_01,
                                         TAIL_02,
                                         TAIL_03,
                                         TAIL_04,
                                         TAIL_05,
                                         TAIL_06> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07>
struct Variant_TypeToIndex<TYPE, bsl::variant<HEAD, TAIL_01,
                                                    TAIL_02,
                                                    TAIL_03,
                                                    TAIL_04,
                                                    TAIL_05,
                                                    TAIL_06,
                                                    TAIL_07> >
: Variant_TypeToIndexImpl<0, TYPE, HEAD, TAIL_01,
                                         TAIL_02,
                                         TAIL_03,
                                         TAIL_04,
                                         TAIL_05,
                                         TAIL_06,
                                         TAIL_07> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08>
struct Variant_TypeToIndex<TYPE, bsl::variant<HEAD, TAIL_01,
                                                    TAIL_02,
                                                    TAIL_03,
                                                    TAIL_04,
                                                    TAIL_05,
                                                    TAIL_06,
                                                    TAIL_07,
                                                    TAIL_08> >
: Variant_TypeToIndexImpl<0, TYPE, HEAD, TAIL_01,
                                         TAIL_02,
                                         TAIL_03,
                                         TAIL_04,
                                         TAIL_05,
                                         TAIL_06,
                                         TAIL_07,
                                         TAIL_08> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08,
                                  class TAIL_09>
struct Variant_TypeToIndex<TYPE, bsl::variant<HEAD, TAIL_01,
                                                    TAIL_02,
                                                    TAIL_03,
                                                    TAIL_04,
                                                    TAIL_05,
                                                    TAIL_06,
                                                    TAIL_07,
                                                    TAIL_08,
                                                    TAIL_09> >
: Variant_TypeToIndexImpl<0, TYPE, HEAD, TAIL_01,
                                         TAIL_02,
                                         TAIL_03,
                                         TAIL_04,
                                         TAIL_05,
                                         TAIL_06,
                                         TAIL_07,
                                         TAIL_08,
                                         TAIL_09> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08,
                                  class TAIL_09,
                                  class TAIL_10>
struct Variant_TypeToIndex<TYPE, bsl::variant<HEAD, TAIL_01,
                                                    TAIL_02,
                                                    TAIL_03,
                                                    TAIL_04,
                                                    TAIL_05,
                                                    TAIL_06,
                                                    TAIL_07,
                                                    TAIL_08,
                                                    TAIL_09,
                                                    TAIL_10> >
: Variant_TypeToIndexImpl<0, TYPE, HEAD, TAIL_01,
                                         TAIL_02,
                                         TAIL_03,
                                         TAIL_04,
                                         TAIL_05,
                                         TAIL_06,
                                         TAIL_07,
                                         TAIL_08,
                                         TAIL_09,
                                         TAIL_10> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10


template <class TYPE,
          class HEAD = BSLSTL_VARIANT_NOT_A_TYPE
#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0
        , class TAIL_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1
        , class TAIL_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2
        , class TAIL_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3
        , class TAIL_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4
        , class TAIL_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5
        , class TAIL_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6
        , class TAIL_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7
        , class TAIL_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8
        , class TAIL_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
        , class TAIL_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
        , class = BSLS_COMPILERFEATURES_NILT>
struct Variant_CountType;

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0
template <class TYPE, class HEAD>
struct Variant_CountType<TYPE, HEAD>
: bsl::integral_constant<size_t,
                         bsl::is_same<TYPE, HEAD>::value +
                             Variant_CountType<TYPE>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1
template <class TYPE, class HEAD, class TAIL_01>
struct Variant_CountType<TYPE, HEAD, TAIL_01>
: bsl::integral_constant<size_t,
                         bsl::is_same<TYPE, HEAD>::value +
                             Variant_CountType<TYPE, TAIL_01>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02>
struct Variant_CountType<TYPE, HEAD, TAIL_01,
                                     TAIL_02>
: bsl::integral_constant<size_t,
                         bsl::is_same<TYPE, HEAD>::value +
                             Variant_CountType<TYPE, TAIL_01,
                                                     TAIL_02>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03>
struct Variant_CountType<TYPE, HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03>
: bsl::integral_constant<size_t,
                         bsl::is_same<TYPE, HEAD>::value +
                             Variant_CountType<TYPE, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04>
struct Variant_CountType<TYPE, HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04>
: bsl::integral_constant<size_t,
                         bsl::is_same<TYPE, HEAD>::value +
                             Variant_CountType<TYPE, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05>
struct Variant_CountType<TYPE, HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05>
: bsl::integral_constant<size_t,
                         bsl::is_same<TYPE, HEAD>::value +
                             Variant_CountType<TYPE, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06>
struct Variant_CountType<TYPE, HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05,
                                     TAIL_06>
: bsl::integral_constant<size_t,
                         bsl::is_same<TYPE, HEAD>::value +
                             Variant_CountType<TYPE, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07>
struct Variant_CountType<TYPE, HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05,
                                     TAIL_06,
                                     TAIL_07>
: bsl::integral_constant<size_t,
                         bsl::is_same<TYPE, HEAD>::value +
                             Variant_CountType<TYPE, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08>
struct Variant_CountType<TYPE, HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05,
                                     TAIL_06,
                                     TAIL_07,
                                     TAIL_08>
: bsl::integral_constant<size_t,
                         bsl::is_same<TYPE, HEAD>::value +
                             Variant_CountType<TYPE, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07,
                                                     TAIL_08>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08,
                                  class TAIL_09>
struct Variant_CountType<TYPE, HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05,
                                     TAIL_06,
                                     TAIL_07,
                                     TAIL_08,
                                     TAIL_09>
: bsl::integral_constant<size_t,
                         bsl::is_same<TYPE, HEAD>::value +
                             Variant_CountType<TYPE, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07,
                                                     TAIL_08,
                                                     TAIL_09>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08,
                                  class TAIL_09,
                                  class TAIL_10>
struct Variant_CountType<TYPE, HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05,
                                     TAIL_06,
                                     TAIL_07,
                                     TAIL_08,
                                     TAIL_09,
                                     TAIL_10>
: bsl::integral_constant<size_t,
                         bsl::is_same<TYPE, HEAD>::value +
                             Variant_CountType<TYPE, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07,
                                                     TAIL_08,
                                                     TAIL_09,
                                                     TAIL_10>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10


template <class TYPE>
struct Variant_CountType<TYPE, BSLSTL_VARIANT_NOT_A_TYPE>
: bsl::integral_constant<size_t, 0> {
};

template <class TYPE, class VARIANT>
struct Variant_HasUniqueType;

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0
template <class TYPE, class HEAD>
struct Variant_HasUniqueType<TYPE, bsl::variant<HEAD> >
: bsl::integral_constant<bool,
                         Variant_CountType<TYPE, HEAD>::value == 1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1
template <class TYPE, class HEAD, class TAIL_01>
struct Variant_HasUniqueType<TYPE, bsl::variant<HEAD, TAIL_01> >
: bsl::integral_constant<bool,
                         Variant_CountType<TYPE, HEAD, TAIL_01>::value == 1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02>
struct Variant_HasUniqueType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                      TAIL_02> >
: bsl::integral_constant<bool,
                         Variant_CountType<TYPE, HEAD, TAIL_01,
                                                       TAIL_02>::value == 1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03>
struct Variant_HasUniqueType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03> >
: bsl::integral_constant<bool,
                         Variant_CountType<TYPE, HEAD, TAIL_01,
                                                       TAIL_02,
                                                       TAIL_03>::value == 1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04>
struct Variant_HasUniqueType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04> >
: bsl::integral_constant<bool,
                         Variant_CountType<TYPE, HEAD, TAIL_01,
                                                       TAIL_02,
                                                       TAIL_03,
                                                       TAIL_04>::value == 1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05>
struct Variant_HasUniqueType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05> >
: bsl::integral_constant<bool,
                         Variant_CountType<TYPE, HEAD, TAIL_01,
                                                       TAIL_02,
                                                       TAIL_03,
                                                       TAIL_04,
                                                       TAIL_05>::value == 1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06>
struct Variant_HasUniqueType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06> >
: bsl::integral_constant<bool,
                         Variant_CountType<TYPE, HEAD, TAIL_01,
                                                       TAIL_02,
                                                       TAIL_03,
                                                       TAIL_04,
                                                       TAIL_05,
                                                       TAIL_06>::value == 1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07>
struct Variant_HasUniqueType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07> >
: bsl::integral_constant<bool,
                         Variant_CountType<TYPE, HEAD, TAIL_01,
                                                       TAIL_02,
                                                       TAIL_03,
                                                       TAIL_04,
                                                       TAIL_05,
                                                       TAIL_06,
                                                       TAIL_07>::value == 1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08>
struct Variant_HasUniqueType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08> >
: bsl::integral_constant<bool,
                         Variant_CountType<TYPE, HEAD, TAIL_01,
                                                       TAIL_02,
                                                       TAIL_03,
                                                       TAIL_04,
                                                       TAIL_05,
                                                       TAIL_06,
                                                       TAIL_07,
                                                       TAIL_08>::value == 1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08,
                                  class TAIL_09>
struct Variant_HasUniqueType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08,
                                                      TAIL_09> >
: bsl::integral_constant<bool,
                         Variant_CountType<TYPE, HEAD, TAIL_01,
                                                       TAIL_02,
                                                       TAIL_03,
                                                       TAIL_04,
                                                       TAIL_05,
                                                       TAIL_06,
                                                       TAIL_07,
                                                       TAIL_08,
                                                       TAIL_09>::value == 1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08,
                                  class TAIL_09,
                                  class TAIL_10>
struct Variant_HasUniqueType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08,
                                                      TAIL_09,
                                                      TAIL_10> >
: bsl::integral_constant<bool,
                         Variant_CountType<TYPE, HEAD, TAIL_01,
                                                       TAIL_02,
                                                       TAIL_03,
                                                       TAIL_04,
                                                       TAIL_05,
                                                       TAIL_06,
                                                       TAIL_07,
                                                       TAIL_08,
                                                       TAIL_09,
                                                       TAIL_10>::value == 1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10


template <class TYPE,
          class HEAD = BSLSTL_VARIANT_NOT_A_TYPE
#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0
        , class TAIL_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1
        , class TAIL_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2
        , class TAIL_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3
        , class TAIL_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4
        , class TAIL_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5
        , class TAIL_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6
        , class TAIL_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7
        , class TAIL_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8
        , class TAIL_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
        , class TAIL_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
        , class = BSLS_COMPILERFEATURES_NILT>
struct Variant_CountCVType;

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0
template <class TYPE, class HEAD>
struct Variant_CountCVType<TYPE, HEAD>
: bsl::integral_constant<
      size_t,
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value +
          Variant_CountCVType<TYPE>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1
template <class TYPE, class HEAD, class TAIL_01>
struct Variant_CountCVType<TYPE, HEAD, TAIL_01>
: bsl::integral_constant<
      size_t,
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value +
          Variant_CountCVType<TYPE, TAIL_01>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02>
struct Variant_CountCVType<TYPE, HEAD, TAIL_01,
                                       TAIL_02>
: bsl::integral_constant<
      size_t,
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value +
          Variant_CountCVType<TYPE, TAIL_01,
                                    TAIL_02>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03>
struct Variant_CountCVType<TYPE, HEAD, TAIL_01,
                                       TAIL_02,
                                       TAIL_03>
: bsl::integral_constant<
      size_t,
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value +
          Variant_CountCVType<TYPE, TAIL_01,
                                    TAIL_02,
                                    TAIL_03>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04>
struct Variant_CountCVType<TYPE, HEAD, TAIL_01,
                                       TAIL_02,
                                       TAIL_03,
                                       TAIL_04>
: bsl::integral_constant<
      size_t,
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value +
          Variant_CountCVType<TYPE, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05>
struct Variant_CountCVType<TYPE, HEAD, TAIL_01,
                                       TAIL_02,
                                       TAIL_03,
                                       TAIL_04,
                                       TAIL_05>
: bsl::integral_constant<
      size_t,
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value +
          Variant_CountCVType<TYPE, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06>
struct Variant_CountCVType<TYPE, HEAD, TAIL_01,
                                       TAIL_02,
                                       TAIL_03,
                                       TAIL_04,
                                       TAIL_05,
                                       TAIL_06>
: bsl::integral_constant<
      size_t,
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value +
          Variant_CountCVType<TYPE, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07>
struct Variant_CountCVType<TYPE, HEAD, TAIL_01,
                                       TAIL_02,
                                       TAIL_03,
                                       TAIL_04,
                                       TAIL_05,
                                       TAIL_06,
                                       TAIL_07>
: bsl::integral_constant<
      size_t,
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value +
          Variant_CountCVType<TYPE, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08>
struct Variant_CountCVType<TYPE, HEAD, TAIL_01,
                                       TAIL_02,
                                       TAIL_03,
                                       TAIL_04,
                                       TAIL_05,
                                       TAIL_06,
                                       TAIL_07,
                                       TAIL_08>
: bsl::integral_constant<
      size_t,
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value +
          Variant_CountCVType<TYPE, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08,
                                  class TAIL_09>
struct Variant_CountCVType<TYPE, HEAD, TAIL_01,
                                       TAIL_02,
                                       TAIL_03,
                                       TAIL_04,
                                       TAIL_05,
                                       TAIL_06,
                                       TAIL_07,
                                       TAIL_08,
                                       TAIL_09>
: bsl::integral_constant<
      size_t,
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value +
          Variant_CountCVType<TYPE, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08,
                                  class TAIL_09,
                                  class TAIL_10>
struct Variant_CountCVType<TYPE, HEAD, TAIL_01,
                                       TAIL_02,
                                       TAIL_03,
                                       TAIL_04,
                                       TAIL_05,
                                       TAIL_06,
                                       TAIL_07,
                                       TAIL_08,
                                       TAIL_09,
                                       TAIL_10>
: bsl::integral_constant<
      size_t,
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value +
          Variant_CountCVType<TYPE, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09,
                                    TAIL_10>::value> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10


template <class TYPE>
struct Variant_CountCVType<TYPE, BSLSTL_VARIANT_NOT_A_TYPE>
: bsl::integral_constant<size_t, 0> {
};

template <class TYPE, class VARIANT>
struct Variant_HasUniqueCVType;

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0
template <class TYPE, class HEAD>
struct Variant_HasUniqueCVType<TYPE, bsl::variant<HEAD> >
: bsl::integral_constant<bool,
                         Variant_CountCVType<TYPE, HEAD>::value ==
                             1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1
template <class TYPE, class HEAD, class TAIL_01>
struct Variant_HasUniqueCVType<TYPE, bsl::variant<HEAD, TAIL_01> >
: bsl::integral_constant<bool,
                         Variant_CountCVType<TYPE, HEAD, TAIL_01>::value ==
                             1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02>
struct Variant_HasUniqueCVType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                        TAIL_02> >
: bsl::integral_constant<bool,
                         Variant_CountCVType<TYPE, HEAD, TAIL_01,
                                                         TAIL_02>::value ==
                             1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03>
struct Variant_HasUniqueCVType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                        TAIL_02,
                                                        TAIL_03> >
: bsl::integral_constant<bool,
                         Variant_CountCVType<TYPE, HEAD, TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03>::value ==
                             1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04>
struct Variant_HasUniqueCVType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                        TAIL_02,
                                                        TAIL_03,
                                                        TAIL_04> >
: bsl::integral_constant<bool,
                         Variant_CountCVType<TYPE, HEAD, TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03,
                                                         TAIL_04>::value ==
                             1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05>
struct Variant_HasUniqueCVType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                        TAIL_02,
                                                        TAIL_03,
                                                        TAIL_04,
                                                        TAIL_05> >
: bsl::integral_constant<bool,
                         Variant_CountCVType<TYPE, HEAD, TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03,
                                                         TAIL_04,
                                                         TAIL_05>::value ==
                             1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06>
struct Variant_HasUniqueCVType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                        TAIL_02,
                                                        TAIL_03,
                                                        TAIL_04,
                                                        TAIL_05,
                                                        TAIL_06> >
: bsl::integral_constant<bool,
                         Variant_CountCVType<TYPE, HEAD, TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03,
                                                         TAIL_04,
                                                         TAIL_05,
                                                         TAIL_06>::value ==
                             1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07>
struct Variant_HasUniqueCVType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                        TAIL_02,
                                                        TAIL_03,
                                                        TAIL_04,
                                                        TAIL_05,
                                                        TAIL_06,
                                                        TAIL_07> >
: bsl::integral_constant<bool,
                         Variant_CountCVType<TYPE, HEAD, TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03,
                                                         TAIL_04,
                                                         TAIL_05,
                                                         TAIL_06,
                                                         TAIL_07>::value ==
                             1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08>
struct Variant_HasUniqueCVType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                        TAIL_02,
                                                        TAIL_03,
                                                        TAIL_04,
                                                        TAIL_05,
                                                        TAIL_06,
                                                        TAIL_07,
                                                        TAIL_08> >
: bsl::integral_constant<bool,
                         Variant_CountCVType<TYPE, HEAD, TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03,
                                                         TAIL_04,
                                                         TAIL_05,
                                                         TAIL_06,
                                                         TAIL_07,
                                                         TAIL_08>::value ==
                             1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08,
                                  class TAIL_09>
struct Variant_HasUniqueCVType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                        TAIL_02,
                                                        TAIL_03,
                                                        TAIL_04,
                                                        TAIL_05,
                                                        TAIL_06,
                                                        TAIL_07,
                                                        TAIL_08,
                                                        TAIL_09> >
: bsl::integral_constant<bool,
                         Variant_CountCVType<TYPE, HEAD, TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03,
                                                         TAIL_04,
                                                         TAIL_05,
                                                         TAIL_06,
                                                         TAIL_07,
                                                         TAIL_08,
                                                         TAIL_09>::value ==
                             1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08,
                                  class TAIL_09,
                                  class TAIL_10>
struct Variant_HasUniqueCVType<TYPE, bsl::variant<HEAD, TAIL_01,
                                                        TAIL_02,
                                                        TAIL_03,
                                                        TAIL_04,
                                                        TAIL_05,
                                                        TAIL_06,
                                                        TAIL_07,
                                                        TAIL_08,
                                                        TAIL_09,
                                                        TAIL_10> >
: bsl::integral_constant<bool,
                         Variant_CountCVType<TYPE, HEAD, TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03,
                                                         TAIL_04,
                                                         TAIL_05,
                                                         TAIL_06,
                                                         TAIL_07,
                                                         TAIL_08,
                                                         TAIL_09,
                                                         TAIL_10>::value ==
                             1> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_E >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class HEAD, class... TAIL>
bool operator==(const variant<HEAD, TAIL...>& lhs,
                const variant<HEAD, TAIL...>& rhs);

template <class HEAD, class... TAIL>
bool operator!=(const variant<HEAD, TAIL...>& lhs,
                const variant<HEAD, TAIL...>& rhs);

template <class HEAD, class... TAIL>
bool operator<(const variant<HEAD, TAIL...>& lhs,
               const variant<HEAD, TAIL...>& rhs);

template <class HEAD, class... TAIL>
bool operator>(const variant<HEAD, TAIL...>& lhs,
               const variant<HEAD, TAIL...>& rhs);

template <class HEAD, class... TAIL>
bool operator<=(const variant<HEAD, TAIL...>& lhs,
                const variant<HEAD, TAIL...>& rhs);

template <class HEAD, class... TAIL>
bool operator>=(const variant<HEAD, TAIL...>& lhs,
                const variant<HEAD, TAIL...>& rhs);
}

namespace BloombergLP {
namespace bslstl {

template <class TYPE = BSLSTL_VARIANT_NOT_A_TYPE, class... OTHER>
struct Variant_UsesBslmaAllocatorAny;

template <>
struct Variant_UsesBslmaAllocatorAny<BSLSTL_VARIANT_NOT_A_TYPE>
: bsl::false_type {
};

template <class TYPE, class... OTHER>
struct Variant_UsesBslmaAllocatorAny
: bsl::integral_constant<
      bool,
      BloombergLP::bslma::UsesBslmaAllocator<TYPE>::value ||
          BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<
              OTHER...>::value> {
};

template <class TYPE = BSLSTL_VARIANT_NOT_A_TYPE, class... OTHER>
struct Variant_IsBitwiseMoveableAll;

template <>
struct Variant_IsBitwiseMoveableAll<BSLSTL_VARIANT_NOT_A_TYPE>
: bsl::true_type {
};

template <class TYPE, class... OTHER>
struct Variant_IsBitwiseMoveableAll
: bsl::integral_constant<bool,
                         BloombergLP::bslmf::IsBitwiseMoveable<TYPE>::value &&
                             Variant_IsBitwiseMoveableAll<OTHER...>::value> {
};

template <class TYPE>
struct Variant_IsTag : bsl::false_type {
};

template <>
struct Variant_IsTag<bsl::allocator_arg_t> : bsl::true_type {
};

template <class TYPE>
struct Variant_IsTag<bsl::in_place_type_t<TYPE> > : bsl::true_type {
};

template <size_t INDEX>
struct Variant_IsTag<bsl::in_place_index_t<INDEX> > : bsl::true_type {
};

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
template <class t_TO, class t_FROM>
struct Variant_IsConstructible : std::is_constructible<t_TO, t_FROM> {
};

template <class t_LHS, class t_RHS>
struct Variant_IsAssignable : std::is_assignable<t_LHS, t_RHS> {
};
#else
template <class t_TO, class t_FROM>
struct Variant_IsConstructible : bsl::true_type {
};

template <class t_LHS, class t_RHS>
struct Variant_IsAssignable : bsl::true_type {
};
#endif

#define BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(VARIANT, TYPE)               \
    typename bsl::enable_if<                                                  \
        BloombergLP::bslstl::Variant_ConstructsFromType<VARIANT,              \
                                                        TYPE>::value,         \
        BloombergLP::bslstl::Variant_NoSuchType>::type

#define BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(VARIANT, TYPE)              \
    BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(                                 \
                        VARIANT,                                              \
                        TYPE) = BloombergLP::bslstl::Variant_NoSuchType(0)

#define BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE)                        \
    typename bsl::enable_if<                                                  \
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,     \
        BloombergLP::bslstl::Variant_NoSuchType>::type

#define BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE)                       \
    BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(                                 \
                           TYPE) = BloombergLP::bslstl::Variant_NoSuchType(0)

#define BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE)                                  \
    BloombergLP::bslstl::                                                     \
        Variant_HasUniqueType<TYPE, variant<HEAD, TAIL...> >::value

#define BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX)                                   \
    typename bsl::variant_alternative<INDEX,                                  \
                                      bsl::variant<HEAD, TAIL...> >::type

#define BSLSTL_VARIANT_INDEX_OF(TYPE, VARIANT)                                \
    BloombergLP::bslstl::Variant_TypeToIndex<TYPE, VARIANT>::value

#define BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, VARIANT)                        \
    BloombergLP::bslstl::Variant_ConvertIndex<TYPE, VARIANT>::value

#define BSLSTL_VARIANT_CONVERT_TYPE_OF(TYPE, VARIANT)                         \
    typename bsl::variant_alternative<BSLSTL_VARIANT_CONVERT_INDEX_OF(        \
                                          TYPE, VARIANT),                     \
                                      VARIANT>::type

#define BSLSTL_VARIANT_VISITID(RET, VISITOR, VAROBJ)                          \
    BloombergLP::bslstl::Variant_VisitImplId<RET>(VISITOR, VAROBJ);

template <size_t   INDEX,
          class    TYPE,
          class    HEAD = BSLSTL_VARIANT_NOT_A_TYPE,
          class... TAIL>
struct Variant_TypeToIndexImpl
: bsl::conditional<bsl::is_same<TYPE, HEAD>::value,
                   bsl::integral_constant<size_t, INDEX>,
                   Variant_TypeToIndexImpl<INDEX + 1, TYPE, TAIL...> >::type {
};

template <size_t INDEX, class TYPE>
struct Variant_TypeToIndexImpl<INDEX, TYPE, BSLSTL_VARIANT_NOT_A_TYPE>
: bsl::integral_constant<size_t, bsl::variant_npos> {
};

template <class TYPE, class VARIANT>
struct Variant_TypeToIndex;

template <class TYPE, class HEAD, class... TAIL>
struct Variant_TypeToIndex<TYPE, bsl::variant<HEAD, TAIL...> >
: Variant_TypeToIndexImpl<0, TYPE, HEAD, TAIL...> {
};

template <class TYPE, class HEAD = BSLSTL_VARIANT_NOT_A_TYPE, class... TAIL>
struct Variant_CountType
: bsl::integral_constant<size_t,
                         bsl::is_same<TYPE, HEAD>::value +
                             Variant_CountType<TYPE, TAIL...>::value> {
};

template <class TYPE>
struct Variant_CountType<TYPE, BSLSTL_VARIANT_NOT_A_TYPE>
: bsl::integral_constant<size_t, 0> {
};

template <class TYPE, class VARIANT>
struct Variant_HasUniqueType;

template <class TYPE, class HEAD, class... TAIL>
struct Variant_HasUniqueType<TYPE, bsl::variant<HEAD, TAIL...> >
: bsl::integral_constant<bool,
                         Variant_CountType<TYPE, HEAD, TAIL...>::value == 1> {
};

template <class TYPE, class HEAD = BSLSTL_VARIANT_NOT_A_TYPE, class... TAIL>
struct Variant_CountCVType
: bsl::integral_constant<
      size_t,
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value +
          Variant_CountCVType<TYPE, TAIL...>::value> {
};

template <class TYPE>
struct Variant_CountCVType<TYPE, BSLSTL_VARIANT_NOT_A_TYPE>
: bsl::integral_constant<size_t, 0> {
};

template <class TYPE, class VARIANT>
struct Variant_HasUniqueCVType;

template <class TYPE, class HEAD, class... TAIL>
struct Variant_HasUniqueCVType<TYPE, bsl::variant<HEAD, TAIL...> >
: bsl::integral_constant<bool,
                         Variant_CountCVType<TYPE, HEAD, TAIL...>::value ==
                             1> {
};
// }}} END GENERATED CODE
#endif
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
template <class VARIANT, size_t INDEX>
struct Variant_CVQualAlt {
    // This component-private metafunction calculates the alternative type at
    // index (template parameter) 'INDEX' in (template parameter) 'VARIANT',
    // where the cv- and ref-qualifiers of 'VARIANT' are added to the
    // alternative type.  This metafunction is used to calculate the return
    // type of 'bsl::visit'.

    typedef typename bsl::variant_alternative<
        INDEX,
        bsl::remove_reference_t<VARIANT> >::type CVAlt;
        // Alternative at 'INDEX' with combined cv-qualifiers

    typedef typename bsl::conditional<
        bsl::is_reference<VARIANT>::value,
        typename bsl::conditional<
            bsl::is_rvalue_reference<VARIANT>::value,
            typename bsl::add_rvalue_reference<CVAlt>::type,
            typename bsl::add_lvalue_reference<CVAlt>::type>::type,
        CVAlt>::type type;
};

template <class  RET,
          class  VISITOR,
          class  VARIANT,
          size_t INDEX =
              bsl::variant_size<bsl::remove_reference_t<VARIANT> >::value - 1>
struct Variant_IsSameReturnType
: public bsl::integral_constant<
      bool,
      bsl::is_same<RET,
                   typename bsl::invoke_result<
                       VISITOR,
                       typename Variant_CVQualAlt<VARIANT, INDEX>::type>::
                       type>::value &&
          Variant_IsSameReturnType<RET, VISITOR, VARIANT, INDEX - 1>::value> {
    // This component-private metafunction derives from 'bsl::true_type' if,
    // for each alternative 'ALTi' in (template parameter) 'VARIANT' with index
    // less than or equal to (template parameter) 'INDEX',
    // 'decltype(std::declval<VISITOR>(std::declval<ALTi>()))' is 'RET';
    // otherwise, this metafunction derives from 'bsl::false_type'.  Note that
    // 'ALTi' has the cv- and ref-qualifiers from 'VARIANT' added to it.  This
    // metafunction is used to determine whether invoking the visitor results
    // in the same type and value category for all alternatives.
};
template <class RET, class VISITOR, class VARIANT>
struct Variant_IsSameReturnType<RET, VISITOR, VARIANT, 0>
: bsl::is_same<RET,
               typename bsl::invoke_result<
                   VISITOR,
                   typename Variant_CVQualAlt<VARIANT, 0>::type>::type> {
};
#else   // BSL_VARIANT_FULL_IMPLEMENTATION
template <class  RET,
          class  VISITOR,
          class  VARIANT,
          size_t INDEX = bsl::variant_size<VARIANT>::value - 1>
struct Variant_IsSameReturnType
: public bsl::integral_constant<
      bool,
      bsl::is_same<RET,
                   typename bsl::invoke_result<
                       VISITOR,
                       typename bsl::variant_alternative<INDEX, VARIANT>::
                           type&>::type>::value &&
          Variant_IsSameReturnType<RET, VISITOR, VARIANT, INDEX - 1>::value> {
    // This component-private metafunction derives from 'bsl::true_type' if,
    // for each alternative 'ALTi' in (template parameter) 'VARIANT' with index
    // less than or equal to (template parameter) 'INDEX', invoking an object
    // of type (template parameter) 'VISITOR' on an lvalue of type 'ALTi' would
    // yield the type and value category given by (template parameter) 'RET';
    // otherwise, this metafunction derives from 'bsl::false_type'.  Note that
    // 'ALTi' has any cv-qualifiers from 'VARIANT' added to it.  This
    // metafunction is used to determine whether invoking the visitor results
    // in the same type and value category for all alternatives.
};

template <class RET, class VISITOR, class VARIANT>
struct Variant_IsSameReturnType<RET, VISITOR, VARIANT, 0>
: bsl::is_same<
      RET,
      typename bsl::invoke_result<
          VISITOR,
          typename bsl::variant_alternative<0, VARIANT>::type&>::type> {
};
template <class  RET,
          class  VISITOR,
          class  VARIANT,
          size_t INDEX = bsl::variant_size<VARIANT>::value - 1>
struct Variant_IsSameMoveReturnType
: public bsl::integral_constant<
      bool,
      bsl::is_same<RET,
                   typename bsl::invoke_result<
                       VISITOR,
                       BloombergLP::bslmf::MovableRef<
                           typename bsl::variant_alternative<INDEX, VARIANT>::
                               type> >::type>::value &&
          Variant_IsSameMoveReturnType<RET, VISITOR, VARIANT, INDEX - 1>::
              value> {
    // This component-private metafunction derives from 'bsl::true_type' if,
    // for each alternative 'ALTi' in (template parameter) 'VARIANT' with index
    // less than or equal to (template parameter) 'INDEX', invoking an object
    // of type (template parameter) 'VISITOR' on a 'bslmf::MovableRef<ALTi>'
    // would yield the type and value category given by (template parameter)
    // 'RET'; otherwise, this metafunction derives from 'bsl::false_type'.
    // This metafunction is used to determine whether invoking the visitor
    // results in the same type and value category for all alternatives.
};

template <class RET, class VISITOR, class VARIANT>
struct Variant_IsSameMoveReturnType<RET, VISITOR, VARIANT, 0>
: bsl::is_same<
      RET,
      typename bsl::invoke_result<
          VISITOR,
          BloombergLP::bslmf::MovableRef<
              typename bsl::variant_alternative<0, VARIANT>::type> >::type> {
};
#endif  // BSL_VARIANT_FULL_IMPLEMENTATION

                           // ======================
                           // struct Variant_ImpUtil
                           // ======================

template <class VARIANT>
struct Variant_ImpUtil {
    // This component-private class holds all functions that need to have
    // friendship access to the 'bsl::variant' type (template parameter)
    // 'VARIANT'.

    template <class RET, size_t INDEX>
    static RET& getImpl(bsl::in_place_index_t<INDEX>, VARIANT&       variant);
    template <class RET, size_t INDEX>
    static RET& getImpl(bsl::in_place_index_t<INDEX>, const VARIANT& variant);
        // Return a reference to the alternative with index (template
        // parameter) 'INDEX' in the specified 'variant'.  If 'INDEX' is not
        // the index of the currently active alternative, an exception of type
        // 'bad_variant_access' is thrown.  Note that the return type must be
        // explicitly specified.

#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class RET, size_t INDEX>
    static RET& Variant_UnsafeGetImpl(bsl::in_place_index_t<INDEX>,
                                      VARIANT&       variant);
    template <class RET, size_t INDEX>
    static RET& Variant_UnsafeGetImpl(bsl::in_place_index_t<INDEX>,
                                      const VARIANT& variant);
        // These component-private functions return a reference to type
        // template parameter) 'RET' to the alternative at (template parameter)
        // 'INDEX' in the specified 'variant', regardless of whether that is
        // the active alternative.  The behavior is undefined unless the active
        // alternative of 'variant' has the same type as the alternative with
        // index 'INDEX'.  Note that the return type must be explicitly
        // specified.
#endif  // BSL_VARIANT_FULL_IMPLEMENTATION

    static bool EqualImpl(const VARIANT& lhs, const VARIANT& rhs);
    static bool NotEqualImpl(const VARIANT& lhs, const VARIANT& rhs);
    static bool LessThanImpl(const VARIANT& lhs, const VARIANT& rhs);
    static bool GreaterThanImpl(const VARIANT& lhs, const VARIANT& rhs);
    static bool LessOrEqualImpl(const VARIANT& lhs, const VARIANT& rhs);
    static bool GreaterOrEqualImpl(const VARIANT& lhs, const VARIANT& rhs);
        // Return the result of comparing the specified 'lhs' with the
        // specified 'rhs'.  The behavior is undefined unless both 'lhs' and
        // 'rhs' hold the same alternative.  Note that the capitalization of
        // the names of these methods has been chosen so that their definitions
        // can be generated using a macro.
};

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
template <class TYPE>
struct Variant_ArrayHelper {
    // This component-private struct is used to check whether an alternative
    // given by (template parameter) 'TYPE' is a potential match for an
    // argument of a 'bsl::variant' constructor or assignment operator that
    // does not take an explicitly specified alternative type.  The standard
    // allows such conversion only when the declaration 'TYPE d_x[] = {expr};'
    // is valid, where 'expr' is the (forwarded) argument expression.
    TYPE d_x[1];
};

template <class TYPE, class = void>
struct Variant_CheckForP1957R2 : bsl::true_type {
    // This component-private metafunction checks whether a conversion from a
    // pointer type to (template parameter) 'TYPE' is narrowing.  It is
    // instantiated only for 'bool', and its behavior depends on whether the
    // compiler has implemented P1957R2.
};

template <class TYPE>
struct Variant_CheckForP1957R2<
    TYPE,
    bsl::void_t<decltype(Variant_ArrayHelper<TYPE>{{"bc"}})> >
: bsl::false_type {
};

template <class DEST, class SOURCE, class = void>
struct Variant_ConvertsWithoutNarrowing : bsl::false_type {
};

template <class DEST, class SOURCE>
struct Variant_ConvertsWithoutNarrowing<
    DEST,
    SOURCE,
    bsl::void_t<decltype(
        Variant_ArrayHelper<DEST>{{std::declval<SOURCE>()}})> >
: bsl::integral_constant<
      bool,
      !(!Variant_CheckForP1957R2<bool>::value &&
        bsl::is_same<bool, typename bsl::remove_cvref<DEST>::type>::value &&
        !bsl::is_same<bool,
                      typename bsl::remove_cvref<SOURCE>::type>::value)> {
    // This component-private metafunction is derived from 'bsl::true_type' if
    // (template parameter) 'SOURCE' can be converted to (template parameter)
    // 'DEST' without narrowing, and 'bsl::false_type' otherwise.  A conversion
    // from pointer or pointer-to-member type to cv 'bool' is considered
    // narrowing even if the compiler does not implement P1957R2 (which was
    // adopted as a DR); however, on compilers that do not implement P1957R2,
    // we do not have the ability to check whether a user-defined conversion
    // sequence to cv 'bool' would use a narrowing standard conversion, so on
    // those compilers, we permit conversion to a 'DEST' that is cv 'bool' only
    // if 'SOURCE' is also cv 'bool', and not when 'SOURCE' is a class type.
    // This behavior is not expected to pose a problem for users migrating from
    // 'bdlb::Variant', because that class does not support implicit
    // conversions from an argument type to an alternative type.
};

                       // =============================
                       // struct Variant_OverloadSetImp
                       // =============================

template <class SRC, size_t INDEX, class HEAD, class... TAIL>
struct Variant_OverloadSetImp
: Variant_OverloadSetImp<SRC, INDEX + 1, TAIL...> {
    // This component-private metafunction computes an overload set consisting
    // of one function, named 'candidate', for each type in (template
    // parameters) 'HEAD, TAIL...', having one parameter of that type.  Each
    // such function participates in overload resolution only when
    // 'std::declval<SRC>()' is convertible to the alternative without
    // narrowing, and returns 'bsl::integral_constant<INDEX + i>', where 'i' is
    // the zero-based index of the corresponding alternative.  Note that a type
    // that occurs multiple times in 'HEAD, TAIL...' (possibly with varying
    // cv-qualifications) will only result in the generation of a single
    // candidate.  This implementation relies on expression SFINAE, 'decltype',
    // 'std::declval', and P1957R2; since these features are not available in
    // C++03, the C++03 version requires an exact match modulo
    // cv-qualification.

    using Variant_OverloadSetImp<SRC, INDEX + 1, TAIL...>::candidate;

    template <class DEST = HEAD>
    static typename bsl::enable_if<
        Variant_ConvertsWithoutNarrowing<DEST, SRC>::value,
        bsl::integral_constant<size_t, INDEX> >::type candidate(HEAD);
};
template <class SRC, size_t INDEX, class HEAD>
struct Variant_OverloadSetImp<SRC, INDEX, HEAD> {
    template <class DEST = HEAD>
    static typename bsl::enable_if<
        Variant_ConvertsWithoutNarrowing<DEST, SRC>::value,
        bsl::integral_constant<size_t, INDEX> >::type candidate(HEAD);
};

template <class SRC, class VARIANT, class = void>
struct Variant_OverLoadHelper {
    // This component-private metafunction provides a member typedef 'Index'
    // representing the value that should be computed by
    // 'Variant_ConvertIndex'.  The primary template is instantiated when the
    // partial specialization below is not viable because no viable alternative
    // exists for the conversion or because the best match is not "unique" (see
    // the documentation of 'Variant_ConvertIndex' for an explanation).

    typedef bsl::integral_constant<size_t, bsl::variant_npos> Index;
};

template <class SRC, class HEAD, class... TAIL>
struct Variant_OverLoadHelper<
    SRC,
    bsl::variant<HEAD, TAIL...>,
    bsl::void_t<decltype(Variant_OverloadSetImp<SRC, 0, HEAD, TAIL...>::
                             candidate(std::declval<SRC>()))> > {
    // This partial specialization is used when a "unique" best match is found
    // for converting 'std::declval<SRC>()' to one of (template parameters)
    // 'HEAD, TAIL...'.
    typedef decltype(Variant_OverloadSetImp<SRC, 0, HEAD, TAIL...>::candidate(
        std::declval<SRC>())) Index;
};

template <class TYPE, class VARIANT>
struct Variant_ConvertIndex : Variant_OverLoadHelper<TYPE, VARIANT>::Index {
    // This component-private metafunction computes the index of the
    // alternative in (template parameter) 'VARIANT' that is the "unique" best
    // match for conversion from 'std::declval<TYPE>()', or 'bsl::variant_npos'
    // if there is no such alternative.  An alternative that occurs multiple
    // times in 'VARIANT' (possibly with varying cv-qualifications) is
    // considered to occur only once; thus, if all alternatives that are tied
    // for the best match are the same type (possibly with varying
    // cv-qualifications), the result is the lowest index at which that type
    // (with any cv-qualification) occurs.
};

#else  //BSL_VARIANT_FULL_IMPLEMENTATION

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_variant.h
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT
#define BSLSTL_VARIANT_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT_F
#define BSLSTL_VARIANT_VARIADIC_LIMIT_F BSLSTL_VARIANT_VARIADIC_LIMIT
#endif
template <size_t INDEX,
          class TYPE,
          class HEAD = BSLSTL_VARIANT_NOT_A_TYPE
#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 0
        , class TAIL_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 1
        , class TAIL_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 2
        , class TAIL_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 3
        , class TAIL_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 4
        , class TAIL_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 5
        , class TAIL_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 6
        , class TAIL_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 7
        , class TAIL_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 8
        , class TAIL_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 9
        , class TAIL_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 9
        , class = BSLS_COMPILERFEATURES_NILT>
struct Variant_ConvertToIndexImpl;


template <size_t INDEX, class TYPE>
struct Variant_ConvertToIndexImpl<INDEX, TYPE, BSLSTL_VARIANT_NOT_A_TYPE>
: bsl::integral_constant<size_t, bsl::variant_npos> {
};
#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 0
template <size_t INDEX, class TYPE, class HEAD>
struct Variant_ConvertToIndexImpl<INDEX, TYPE, HEAD>
: bsl::conditional<
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value,
      bsl::integral_constant<size_t, INDEX>,
      Variant_ConvertToIndexImpl<INDEX + 1, TYPE> >::type {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 1
template <size_t INDEX, class TYPE, class HEAD, class TAIL_01>
struct Variant_ConvertToIndexImpl<INDEX, TYPE, HEAD, TAIL_01>
: bsl::conditional<
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value,
      bsl::integral_constant<size_t, INDEX>,
      Variant_ConvertToIndexImpl<INDEX + 1, TYPE, TAIL_01> >::type {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 2
template <size_t INDEX, class TYPE, class HEAD, class TAIL_01,
                                                class TAIL_02>
struct Variant_ConvertToIndexImpl<INDEX, TYPE, HEAD, TAIL_01,
                                                     TAIL_02>
: bsl::conditional<
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value,
      bsl::integral_constant<size_t, INDEX>,
      Variant_ConvertToIndexImpl<INDEX + 1, TYPE, TAIL_01,
                                                  TAIL_02> >::type {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 3
template <size_t INDEX, class TYPE, class HEAD, class TAIL_01,
                                                class TAIL_02,
                                                class TAIL_03>
struct Variant_ConvertToIndexImpl<INDEX, TYPE, HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03>
: bsl::conditional<
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value,
      bsl::integral_constant<size_t, INDEX>,
      Variant_ConvertToIndexImpl<INDEX + 1, TYPE, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03> >::type {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 4
template <size_t INDEX, class TYPE, class HEAD, class TAIL_01,
                                                class TAIL_02,
                                                class TAIL_03,
                                                class TAIL_04>
struct Variant_ConvertToIndexImpl<INDEX, TYPE, HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04>
: bsl::conditional<
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value,
      bsl::integral_constant<size_t, INDEX>,
      Variant_ConvertToIndexImpl<INDEX + 1, TYPE, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04> >::type {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 5
template <size_t INDEX, class TYPE, class HEAD, class TAIL_01,
                                                class TAIL_02,
                                                class TAIL_03,
                                                class TAIL_04,
                                                class TAIL_05>
struct Variant_ConvertToIndexImpl<INDEX, TYPE, HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05>
: bsl::conditional<
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value,
      bsl::integral_constant<size_t, INDEX>,
      Variant_ConvertToIndexImpl<INDEX + 1, TYPE, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05> >::type {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 6
template <size_t INDEX, class TYPE, class HEAD, class TAIL_01,
                                                class TAIL_02,
                                                class TAIL_03,
                                                class TAIL_04,
                                                class TAIL_05,
                                                class TAIL_06>
struct Variant_ConvertToIndexImpl<INDEX, TYPE, HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06>
: bsl::conditional<
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value,
      bsl::integral_constant<size_t, INDEX>,
      Variant_ConvertToIndexImpl<INDEX + 1, TYPE, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06> >::type {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 7
template <size_t INDEX, class TYPE, class HEAD, class TAIL_01,
                                                class TAIL_02,
                                                class TAIL_03,
                                                class TAIL_04,
                                                class TAIL_05,
                                                class TAIL_06,
                                                class TAIL_07>
struct Variant_ConvertToIndexImpl<INDEX, TYPE, HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07>
: bsl::conditional<
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value,
      bsl::integral_constant<size_t, INDEX>,
      Variant_ConvertToIndexImpl<INDEX + 1, TYPE, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06,
                                                  TAIL_07> >::type {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 8
template <size_t INDEX, class TYPE, class HEAD, class TAIL_01,
                                                class TAIL_02,
                                                class TAIL_03,
                                                class TAIL_04,
                                                class TAIL_05,
                                                class TAIL_06,
                                                class TAIL_07,
                                                class TAIL_08>
struct Variant_ConvertToIndexImpl<INDEX, TYPE, HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07,
                                                     TAIL_08>
: bsl::conditional<
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value,
      bsl::integral_constant<size_t, INDEX>,
      Variant_ConvertToIndexImpl<INDEX + 1, TYPE, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06,
                                                  TAIL_07,
                                                  TAIL_08> >::type {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 9
template <size_t INDEX, class TYPE, class HEAD, class TAIL_01,
                                                class TAIL_02,
                                                class TAIL_03,
                                                class TAIL_04,
                                                class TAIL_05,
                                                class TAIL_06,
                                                class TAIL_07,
                                                class TAIL_08,
                                                class TAIL_09>
struct Variant_ConvertToIndexImpl<INDEX, TYPE, HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07,
                                                     TAIL_08,
                                                     TAIL_09>
: bsl::conditional<
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value,
      bsl::integral_constant<size_t, INDEX>,
      Variant_ConvertToIndexImpl<INDEX + 1, TYPE, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06,
                                                  TAIL_07,
                                                  TAIL_08,
                                                  TAIL_09> >::type {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 10
template <size_t INDEX, class TYPE, class HEAD, class TAIL_01,
                                                class TAIL_02,
                                                class TAIL_03,
                                                class TAIL_04,
                                                class TAIL_05,
                                                class TAIL_06,
                                                class TAIL_07,
                                                class TAIL_08,
                                                class TAIL_09,
                                                class TAIL_10>
struct Variant_ConvertToIndexImpl<INDEX, TYPE, HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07,
                                                     TAIL_08,
                                                     TAIL_09,
                                                     TAIL_10>
: bsl::conditional<
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value,
      bsl::integral_constant<size_t, INDEX>,
      Variant_ConvertToIndexImpl<INDEX + 1, TYPE, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06,
                                                  TAIL_07,
                                                  TAIL_08,
                                                  TAIL_09,
                                                  TAIL_10> >::type {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 10


template <class TYPE, class VARIANT>
struct Variant_ConvertIndex;

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 0
template <class TYPE, class HEAD>
struct Variant_ConvertIndex<TYPE, bsl::variant<HEAD> >
: Variant_ConvertToIndexImpl<
      0,
      typename bslmf::MovableRefUtil::RemoveReference<TYPE>::type,
      HEAD> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 1
template <class TYPE, class HEAD, class TAIL_01>
struct Variant_ConvertIndex<TYPE, bsl::variant<HEAD, TAIL_01> >
: Variant_ConvertToIndexImpl<
      0,
      typename bslmf::MovableRefUtil::RemoveReference<TYPE>::type,
      HEAD,
      TAIL_01> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 2
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02>
struct Variant_ConvertIndex<TYPE, bsl::variant<HEAD, TAIL_01,
                                                     TAIL_02> >
: Variant_ConvertToIndexImpl<
      0,
      typename bslmf::MovableRefUtil::RemoveReference<TYPE>::type,
      HEAD,
      TAIL_01,
      TAIL_02> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 3
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03>
struct Variant_ConvertIndex<TYPE, bsl::variant<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03> >
: Variant_ConvertToIndexImpl<
      0,
      typename bslmf::MovableRefUtil::RemoveReference<TYPE>::type,
      HEAD,
      TAIL_01,
      TAIL_02,
      TAIL_03> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 4
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04>
struct Variant_ConvertIndex<TYPE, bsl::variant<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04> >
: Variant_ConvertToIndexImpl<
      0,
      typename bslmf::MovableRefUtil::RemoveReference<TYPE>::type,
      HEAD,
      TAIL_01,
      TAIL_02,
      TAIL_03,
      TAIL_04> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 5
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05>
struct Variant_ConvertIndex<TYPE, bsl::variant<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05> >
: Variant_ConvertToIndexImpl<
      0,
      typename bslmf::MovableRefUtil::RemoveReference<TYPE>::type,
      HEAD,
      TAIL_01,
      TAIL_02,
      TAIL_03,
      TAIL_04,
      TAIL_05> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 6
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06>
struct Variant_ConvertIndex<TYPE, bsl::variant<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06> >
: Variant_ConvertToIndexImpl<
      0,
      typename bslmf::MovableRefUtil::RemoveReference<TYPE>::type,
      HEAD,
      TAIL_01,
      TAIL_02,
      TAIL_03,
      TAIL_04,
      TAIL_05,
      TAIL_06> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 7
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07>
struct Variant_ConvertIndex<TYPE, bsl::variant<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07> >
: Variant_ConvertToIndexImpl<
      0,
      typename bslmf::MovableRefUtil::RemoveReference<TYPE>::type,
      HEAD,
      TAIL_01,
      TAIL_02,
      TAIL_03,
      TAIL_04,
      TAIL_05,
      TAIL_06,
      TAIL_07> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 8
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08>
struct Variant_ConvertIndex<TYPE, bsl::variant<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07,
                                                     TAIL_08> >
: Variant_ConvertToIndexImpl<
      0,
      typename bslmf::MovableRefUtil::RemoveReference<TYPE>::type,
      HEAD,
      TAIL_01,
      TAIL_02,
      TAIL_03,
      TAIL_04,
      TAIL_05,
      TAIL_06,
      TAIL_07,
      TAIL_08> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 9
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08,
                                  class TAIL_09>
struct Variant_ConvertIndex<TYPE, bsl::variant<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07,
                                                     TAIL_08,
                                                     TAIL_09> >
: Variant_ConvertToIndexImpl<
      0,
      typename bslmf::MovableRefUtil::RemoveReference<TYPE>::type,
      HEAD,
      TAIL_01,
      TAIL_02,
      TAIL_03,
      TAIL_04,
      TAIL_05,
      TAIL_06,
      TAIL_07,
      TAIL_08,
      TAIL_09> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 10
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08,
                                  class TAIL_09,
                                  class TAIL_10>
struct Variant_ConvertIndex<TYPE, bsl::variant<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07,
                                                     TAIL_08,
                                                     TAIL_09,
                                                     TAIL_10> >
: Variant_ConvertToIndexImpl<
      0,
      typename bslmf::MovableRefUtil::RemoveReference<TYPE>::type,
      HEAD,
      TAIL_01,
      TAIL_02,
      TAIL_03,
      TAIL_04,
      TAIL_05,
      TAIL_06,
      TAIL_07,
      TAIL_08,
      TAIL_09,
      TAIL_10> {
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_F >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <size_t   INDEX,
          class    TYPE,
          class    HEAD = BSLSTL_VARIANT_NOT_A_TYPE,
          class... TAIL>
struct Variant_ConvertToIndexImpl;

template <size_t INDEX, class TYPE>
struct Variant_ConvertToIndexImpl<INDEX, TYPE, BSLSTL_VARIANT_NOT_A_TYPE>
: bsl::integral_constant<size_t, bsl::variant_npos> {
};
template <size_t INDEX, class TYPE, class HEAD, class... TAIL>
struct Variant_ConvertToIndexImpl<INDEX, TYPE, HEAD, TAIL...>
: bsl::conditional<
      bsl::is_same<typename bsl::remove_cv<TYPE>::type,
                   typename bsl::remove_cv<HEAD>::type>::value,
      bsl::integral_constant<size_t, INDEX>,
      Variant_ConvertToIndexImpl<INDEX + 1, TYPE, TAIL...> >::type {
};

template <class TYPE, class VARIANT>
struct Variant_ConvertIndex;

template <class TYPE, class HEAD, class... TAIL>
struct Variant_ConvertIndex<TYPE, bsl::variant<HEAD, TAIL...> >
: Variant_ConvertToIndexImpl<
      0,
      typename bslmf::MovableRefUtil::RemoveReference<TYPE>::type,
      HEAD,
      TAIL...> {
};

// }}} END GENERATED CODE
#endif
#endif  // BSL_VARIANT_FULL_IMPLEMENTATION

template <class  VARIANT,
          class  TYPE,
          size_t INDEX = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, VARIANT)>
struct Variant_IsAlternativeConstructibleFrom
: bsl::integral_constant<
      bool,
      Variant_IsConstructible<
          typename bsl::variant_alternative<INDEX, VARIANT>::type,
          TYPE>::value &&
          Variant_HasUniqueCVType<BSLSTL_VARIANT_CONVERT_TYPE_OF(TYPE,
                                                                 VARIANT),
                                  VARIANT>::value> {
    // This component-private metafunction is derived from 'bsl::true_type' if
    // there is a unique best match alternative in (template parameter)
    // 'VARIANT' for 'std::declval<TYPE>() and that alternative is
    // constructible from 'std::declval<TYPE>(), and 'bsl::false_type'
    // otherwise.
};

template <class VARIANT, class TYPE>
struct Variant_IsAlternativeConstructibleFrom<VARIANT, TYPE, bsl::variant_npos>
: bsl::false_type {
};

template <class  VARIANT,
          class  TYPE,
          size_t INDEX = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, VARIANT)>
struct Variant_isAlternativeAssignableFrom
: bsl::integral_constant<
      bool,
      Variant_IsAssignable<
          typename bsl::variant_alternative<INDEX, VARIANT>::type&,
          TYPE>::value &&
          Variant_HasUniqueCVType<BSLSTL_VARIANT_CONVERT_TYPE_OF(TYPE,
                                                                 VARIANT),
                                  VARIANT>::value> {
    // This component-private metafunction is derived from 'bsl::true_type' if
    // there is a unique best match alternative in (template parameter)
    // 'VARIANT' for 'std::declval<TYPE>()' and that alternative is both
    // constructible and assignable from 'std::declval<TYPE>()', and
    // 'bsl::false_type' otherwise.
};

template <class VARIANT, class TYPE>
struct Variant_isAlternativeAssignableFrom<VARIANT, TYPE, bsl::variant_npos>
: bsl::false_type {
};

template <class VARIANT, class TYPE>
struct Variant_ConstructsFromType
: bsl::integral_constant<
      bool,
      !bsl::is_same<typename bsl::remove_cvref<TYPE>::type, VARIANT>::value &&
          !Variant_IsTag<typename bsl::remove_cvref<TYPE>::type>::value &&
          Variant_IsAlternativeConstructibleFrom<VARIANT, TYPE>::value> {
    // This component-private metafunction is derived from 'bsl::true_type' if
    // (template parameter) 'TYPE' is neither a tag type nor the type
    // (template parameter) 'VARIANT' (modulo cv-qualification), there is a
    // unique best match alternative in 'VARIANT' for 'std::declval<TYPE>()',
    // and that alternative is constructible from 'std::declval<TYPE>()';
    // otherwise, this metafunction is derived from 'bsl::false_type'.
};

template <class VARIANT, class TYPE>
struct Variant_AssignsFromType
: bsl::integral_constant<
      bool,
      !bsl::is_same<typename bsl::remove_cvref<TYPE>::type, VARIANT>::value &&
          Variant_IsAlternativeConstructibleFrom<VARIANT, TYPE>::value &&
          Variant_isAlternativeAssignableFrom<VARIANT, TYPE>::value> {
    // This component-private metafunction is derived from 'bsl::true_type' if
    // (template parameter) 'TYPE' is neither a tag type nor the type
    // (template parameter) 'VARIANT' (modulo cv-qualification), there is a
    // unique best match alternative in 'VARIANT' for 'std::declval<TYPE>()',
    // and that alternative is constructible and assignable from
    // 'std::declval<TYPE>()'; otherwise, this metafunction is derived from
    // 'bsl::false_type'.
};

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
// The following component-private machinery allows for conditionally deleting
// special member functions.

template <bool ISCOPYCONSTRUCTIBLE>
struct Variant_CopyConstructorBase {
    // This component-private class has deleted copy constructor if (template
    // parameter) 'ISCOPYCONSTRUCTIBLE' is 'false'.  All other special member
    // functions are defaulted.
};
template <>
struct Variant_CopyConstructorBase<false> {
    Variant_CopyConstructorBase()                                   = default;
    Variant_CopyConstructorBase(const Variant_CopyConstructorBase&) = delete;
    Variant_CopyConstructorBase(Variant_CopyConstructorBase&&)      = default;
    Variant_CopyConstructorBase&
    operator=(const Variant_CopyConstructorBase&) = default;
    Variant_CopyConstructorBase&
    operator=(Variant_CopyConstructorBase&&) = default;
};

template <bool ISCOPYCONSTRUCTIBLE, bool ISMOVECONSTRUCTIBLE>
struct Variant_MoveConstructorBase
: Variant_CopyConstructorBase<ISCOPYCONSTRUCTIBLE> {
    // This component-private class has deleted move constructor if (template
    // parameter) 'ISMOVECONSTRUCTIBLE' is 'false'.  All other special member
    // functions are defaulted.
};
template <bool ISCOPYCONSTRUCTIBLE>
struct Variant_MoveConstructorBase<ISCOPYCONSTRUCTIBLE, false>
: Variant_CopyConstructorBase<ISCOPYCONSTRUCTIBLE> {
    Variant_MoveConstructorBase()                                   = default;
    Variant_MoveConstructorBase(const Variant_MoveConstructorBase&) = default;
    Variant_MoveConstructorBase(Variant_MoveConstructorBase&&)      = delete;
    Variant_MoveConstructorBase&
    operator=(const Variant_MoveConstructorBase&) = default;
    Variant_MoveConstructorBase&
    operator=(Variant_MoveConstructorBase&&) = default;
};

template <bool ISCOPYCONSTRUCTIBLE,
          bool ISMOVECONSTRUCTIBLE,
          bool ISCOPYASSIGNABLE>
struct Variant_CopyAssignBase
: Variant_MoveConstructorBase<ISCOPYCONSTRUCTIBLE, ISMOVECONSTRUCTIBLE> {
    // This component-private class has deleted copy assignment operator if
    // (template parameter) 'ISCOPYASSIGNABLE' is 'false'.  All other special
    // member functions are defaulted.
};
template <bool ISCOPYCONSTRUCTIBLE, bool ISMOVECONSTRUCTIBLE>
struct Variant_CopyAssignBase<ISCOPYCONSTRUCTIBLE, ISMOVECONSTRUCTIBLE, false>
: Variant_MoveConstructorBase<ISCOPYCONSTRUCTIBLE, ISMOVECONSTRUCTIBLE> {
    Variant_CopyAssignBase()                                         = default;
    Variant_CopyAssignBase(const Variant_CopyAssignBase&)            = default;
    Variant_CopyAssignBase(Variant_CopyAssignBase&&)                 = default;
    Variant_CopyAssignBase& operator=(const Variant_CopyAssignBase&) = delete;
    Variant_CopyAssignBase& operator=(Variant_CopyAssignBase&&)      = default;
};

template <bool ISCOPYCONSTRUCTIBLE,
          bool ISMOVECONSTRUCTIBLE,
          bool ISCOPYASSIGNABLE,
          bool ISMOVEASSIGNABLE>
struct Variant_MoveAssignBase : Variant_CopyAssignBase<ISCOPYCONSTRUCTIBLE,
                                                       ISMOVECONSTRUCTIBLE,
                                                       ISCOPYASSIGNABLE> {
    // This component-private class has deleted move assignment operator if
    // (template parameter) 'ISMOVEASSIGNABLE' is 'false'.  All other special
    // member functions are defaulted.
};
template <bool ISCOPYCONSTRUCTIBLE,
          bool ISMOVECONSTRUCTIBLE,
          bool ISCOPYASSIGNABLE>
struct Variant_MoveAssignBase<ISCOPYCONSTRUCTIBLE,
                              ISMOVECONSTRUCTIBLE,
                              ISCOPYASSIGNABLE,
                              false>
: Variant_CopyAssignBase<ISCOPYCONSTRUCTIBLE,
                         ISMOVECONSTRUCTIBLE,
                         ISCOPYASSIGNABLE> {
    Variant_MoveAssignBase()                                         = default;
    Variant_MoveAssignBase(const Variant_MoveAssignBase&)            = default;
    Variant_MoveAssignBase(Variant_MoveAssignBase&&)                 = default;
    Variant_MoveAssignBase& operator=(const Variant_MoveAssignBase&) = default;
    Variant_MoveAssignBase& operator=(Variant_MoveAssignBase&&)      = delete;
};

template <bool ISCOPYCONSTRUCTIBLE,
          bool ISMOVECONSTRUCTIBLE,
          bool ISCOPYASSIGNABLE,
          bool ISMOVEASSIGNABLE>
struct Variant_SMFBase : Variant_MoveAssignBase<ISCOPYCONSTRUCTIBLE,
                                                ISMOVECONSTRUCTIBLE,
                                                ISCOPYASSIGNABLE,
                                                ISMOVEASSIGNABLE> {
    // This component-private class has special member functions that are
    // either deleted or defaulted according to the specified template
    // parameters.
};

template <class TYPE, class... OTHER>
struct Variant_IsCopyConstructibleAll
: bsl::integral_constant<bool,
                         std::is_copy_constructible<TYPE>::value &&
                             Variant_IsCopyConstructibleAll<OTHER...>::value> {
    // This component-private metafunction is derived from 'bsl::true_type' if
    // all template parameters are copy constructible, and 'bsl::false_type'
    // otherwise.
};

template <class TYPE>
struct Variant_IsCopyConstructibleAll<TYPE>
: std::is_copy_constructible<TYPE> {
};

template <class TYPE, class... OTHER>
struct Variant_IsMoveConstructibleAll
: bsl::integral_constant<bool,
                         std::is_move_constructible<TYPE>::value &&
                             Variant_IsMoveConstructibleAll<OTHER...>::value> {
    // This component-private metafunction is derived from 'bsl::true_type' if
    // all template parameters are move constructible, and 'bsl::false_type'
    // otherwise.
};

template <class TYPE>
struct Variant_IsMoveConstructibleAll<TYPE>
: std::is_move_constructible<TYPE> {
};

template <class TYPE, class... OTHER>
struct Variant_IsCopyAssignableAll
: bsl::integral_constant<bool,
                         std::is_copy_assignable<TYPE>::value &&
                             Variant_IsCopyAssignableAll<OTHER...>::value> {
    // This component-private metafunction is derived from 'bsl::true_type' if
    // all template parameters are copy assignable, and 'bsl::false_type'
    // otherwise.
};

template <class TYPE>
struct Variant_IsCopyAssignableAll<TYPE> : std::is_copy_assignable<TYPE> {
};

template <class TYPE, class... OTHER>
struct Variant_IsMoveAssignableAll
: bsl::integral_constant<bool,
                         std::is_move_assignable<TYPE>::value &&
                             Variant_IsMoveAssignableAll<OTHER...>::value> {
    // This component-private metafunction is derived from 'bsl::true_type' if
    // all template parameters are move assignable, and 'bsl::false_type'
    // otherwise.
};

template <class TYPE>
struct Variant_IsMoveAssignableAll<TYPE> : std::is_move_assignable<TYPE> {
};
#endif  // BSL_VARIANT_FULL_IMPLEMENTATION

template <class RET, class VARIANTUNION>
RET& variant_getAlternativeImpl(bsl::in_place_index_t<0>,
                                VARIANTUNION& variantUnion)
                                                          BSLS_KEYWORD_NOEXCEPT
    // This component-private function returns a reference to the object
    // managed by the first member of the specified 'variantUnion'.  It is the
    // base case for the overload of 'getAlternativeImpl' below.
{
    return variantUnion.d_head.value();
}

template <class RET, size_t INDEX, class VARIANTUNION>
RET& variant_getAlternativeImpl(bsl::in_place_index_t<INDEX>,
                                VARIANTUNION& variantUnion)
                                                          BSLS_KEYWORD_NOEXCEPT
    // This component-private function returns a reference to the alternative
    // with index (template parameter) 'INDEX' in the specified 'variantUnion'
    // by recursively unravelling 'variantUnion' until the desired alternative
    // is at the head.  'INDEX' shall be a valid alternative index.  The
    // behavior is undefined unless the alternative with index 'INDEX' has the
    // same type as the active alternative of 'variantUnion'.
{
    return variant_getAlternativeImpl<RET>(bsl::in_place_index_t<INDEX - 1>(),
                                           variantUnion.d_tail);
}

template <class VARIANT>
template <class RET, size_t INDEX>
RET& Variant_ImpUtil<VARIANT>::getImpl(bsl::in_place_index_t<INDEX>,
                                       VARIANT& variant)
{
    if (variant.index() != INDEX) {
        BSLS_THROW(bsl::bad_variant_access());
    }

    return variant_getAlternativeImpl<RET>(bsl::in_place_index_t<INDEX>(),
                                           variant.d_union);
}

template <class VARIANT>
template <class RET, size_t INDEX>
RET& Variant_ImpUtil<VARIANT>::getImpl(bsl::in_place_index_t<INDEX>,
                                       const VARIANT& variant)
{
    if (variant.index() != INDEX) {
        BSLS_THROW(bsl::bad_variant_access());
    }

    return variant_getAlternativeImpl<RET>(bsl::in_place_index_t<INDEX>(),
                                           variant.d_union);
}

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
template <class t_RET, class VISITOR, class VARIANT, size_t INDEX>
struct Variant_Function {
    static t_RET functionImpl(VISITOR&& visitor, VARIANT&& variant)
        // This component-private function invokes the specified 'visitor' with
        // the active alternative object of the specified 'variant' and
        // implicitly converts the return type to (template parameter) 't_RET'.
        // The pre-C++17 implementation is limited to invocations of the form
        // 'visitor(variant)'.  The behavior is undefined unless (template
        // parameter) 'INDEX' is the index of the active alternative.
    {
#ifdef BSLS_LIBRARYFEATURES_HAS_CPP17_BASELINE_LIBRARY
        return std::invoke(std::forward<VISITOR>(visitor),
                           bsl::get<INDEX>(std::forward<VARIANT>(variant)));
#else
        return visitor(bsl::get<INDEX>(std::forward<VARIANT>(variant)));
#endif
    }
};

template <class VISITOR, class VARIANT, size_t INDEX>
struct Variant_Function<void, VISITOR, VARIANT, INDEX> {
    // This partial specialization is used when 't_RET' is 'void'.  The visitor
    // is invoked and its return value, if any, is ignored.  This partial
    // specialization is necessary because a 'void'-returning function cannot
    // contain a 'return' statement with a non-'void' operand.

    static void functionImpl(VISITOR&& visitor, VARIANT&& variant)
    {
#ifdef BSLS_LIBRARYFEATURES_HAS_CPP17_BASELINE_LIBRARY
        std::invoke(std::forward<VISITOR>(visitor),
                    bsl::get<INDEX>(std::forward<VARIANT>(variant)));
#else
        visitor(bsl::get<INDEX>(std::forward<VARIANT>(variant)));
#endif
    }
};

template <class t_RET, class VISITOR, class VARIANT, size_t INDEX>
struct Variant_FunctionId {
    static t_RET functionImpl(VISITOR&& visitor, VARIANT&& variant)
        // This component-private function invokes the specified 'visitor' with
        // a 'bsl::in_place_index_t' tag representing the value of (template
        // parameter) 'INDEX' and the active alternative object of the
        // specified 'variant', implicitly converting the return type to
        // (template parameter) 't_RET'.  The behavior is undefined unless
        // 'INDEX' is the index of the active alternative.
    {
        return visitor(bsl::in_place_index_t<INDEX>(),
                       bsl::get<INDEX>(std::forward<VARIANT>(variant)));
    }
};

template <class t_RET, class VISITOR, class VARIANT, class DUMMY>
struct Variant_VTable;
    // This component-private struct computes an array in which element 'i' is
    // a pointer to 'Variant_Function<R, VISITOR, VARIANT, i>::functionImpl',
    // defined above as a function that invokes a 'VISITOR' with alternative
    // 'i' of 'VARIANT' and implicitly converts the return type to 't_RET'.

template <class t_RET, class VISITOR, class VARIANT, size_t... INDICES>
struct Variant_VTable<t_RET,
                      VISITOR,
                      VARIANT,
                      bslmf::IntegerSequence<std::size_t, INDICES...> > {
    // In order to allow for perfect forwarding, both VISITOR and VARIANT must
    // be of reference type.  If they are not, something went wrong.
    BSLMF_ASSERT(bsl::is_reference<VISITOR>::value);
    BSLMF_ASSERT(bsl::is_reference<VARIANT>::value);

    typedef t_RET (*FuncPtr)(VISITOR, VARIANT);

    static BSLS_KEYWORD_CONSTEXPR FuncPtr s_map[sizeof...(INDICES)] = {&(
         Variant_Function<t_RET, VISITOR, VARIANT, INDICES>::functionImpl)...};
};

template <class t_RET, class VISITOR, class VARIANT, class DUMMY>
struct Variant_VTableId;
    // This component-private struct computes an array in which element 'i' is
    // a pointer to
    // 'Variant_FunctionId<t_RET, VISITOR, VARIANT, i>::functionImpl', defined
    // above as a function that invokes a 'VISITOR' with a tag representing 'i'
    // and alternative 'i' of 'VARIANT', implicitly converting the return type
    // to 't_RET'.  Implementation note: The constexpr static maps of pointers
    // defined by 'Variant_VTable' and this class have deliberately been
    // defined in two different classes as having them in the same class caused
    // issues with Clang and Microsoft Visual C++.

template <class t_RET, class VISITOR, class VARIANT, size_t... INDICES>
struct Variant_VTableId<t_RET,
                        VISITOR,
                        VARIANT,
                        bslmf::IntegerSequence<std::size_t, INDICES...> > {
    // In order to allow for perfect forwarding, both VISITOR and VARIANT must
    // be of reference type.  If they are not, something went wrong.
    BSLMF_ASSERT(bsl::is_reference<VISITOR>::value);
    BSLMF_ASSERT(bsl::is_reference<VARIANT>::value);

    typedef t_RET (*FuncPtr)(VISITOR, VARIANT);

    static BSLS_KEYWORD_CONSTEXPR FuncPtr s_mapId[sizeof...(INDICES)] = {
        &(Variant_FunctionId<t_RET, VISITOR, VARIANT, INDICES>::
              functionImpl)...};
};

// inline definitions of component-private function pointer maps
template <class t_RET, class VISITOR, class VARIANT, size_t... INDICES>
BSLS_KEYWORD_CONSTEXPR typename Variant_VTable<
    t_RET,
    VISITOR,
    VARIANT,
    bslmf::IntegerSequence<std::size_t, INDICES...> >::FuncPtr
    Variant_VTable<t_RET,
                   VISITOR,
                   VARIANT,
                   bslmf::IntegerSequence<std::size_t, INDICES...> >::s_map
        [sizeof...(INDICES)];

template <class t_RET, class VISITOR, class VARIANT, size_t... INDICES>
BSLS_KEYWORD_CONSTEXPR typename Variant_VTableId<
    t_RET,
    VISITOR,
    VARIANT,
    bslmf::IntegerSequence<std::size_t, INDICES...> >::FuncPtr
    Variant_VTableId<t_RET,
                     VISITOR,
                     VARIANT,
                     bslmf::IntegerSequence<std::size_t, INDICES...> >::s_mapId
        [sizeof...(INDICES)];

template <class t_RET, class VISITOR, class VARIANT>
t_RET Variant_VisitImpl(VISITOR&& visitor, VARIANT&& variant)
    // This component-private function invokes the specified 'visitor' on the
    // active alternative of the specified 'variant', implicitly converting the
    // return type to the explicitly specified (template parameter) 't_RET'.
    // The behavior is undefined if 'variant' does not hold a value.
{
    static constexpr size_t varSize =
        bsl::variant_size<bsl::remove_reference_t<VARIANT> >::value;

    typedef typename Variant_VTable<
        t_RET,
        VISITOR&&,
        VARIANT&&,
        bslmf::MakeIntegerSequence<std::size_t, varSize> >::FuncPtr FuncPtr;

    // Generate the table of all function pointers for 'VISITOR' and 'VARIANT',
    // then invoke the one corresponding to the active index.
    FuncPtr func_ptr =
        Variant_VTable<t_RET,
                       VISITOR&&,
                       VARIANT&&,
                       bslmf::MakeIntegerSequence<std::size_t, varSize> >::
            s_map[variant.index()];

    return (*func_ptr)(std::forward<VISITOR>(visitor),
                       std::forward<VARIANT>(variant));
}
template <class t_RET, class VISITOR, class VARIANT>
t_RET Variant_VisitImplId(VISITOR&& visitor, VARIANT&& variant)
    // This component-private function is like 'Variant_VisitImpl', but it also
    // passes a tag representing the index of the selected alternative when
    // invoking the visitor.  It is used internally for visitors that
    // participate in the 'variant' implementation.
{
    static constexpr size_t varSize =
        bsl::variant_size<bsl::remove_reference_t<VARIANT> >::value;

    typedef typename Variant_VTableId<
        t_RET,
        VISITOR&&,
        VARIANT&&,
        bslmf::MakeIntegerSequence<std::size_t, varSize> >::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTableId<t_RET,
                         VISITOR&&,
                         VARIANT&&,
                         bslmf::MakeIntegerSequence<std::size_t, varSize> >::
            s_mapId[variant.index()];

    return (*func_ptr)(std::forward<VISITOR>(visitor),
                       std::forward<VARIANT>(variant));
}

#else  //BSL_VARIANT_FULL_IMPLEMENTATION
#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_variant.h
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT
#define BSLSTL_VARIANT_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT_G
#define BSLSTL_VARIANT_VARIADIC_LIMIT_G BSLSTL_VARIANT_VARIADIC_LIMIT
#endif
template <class VARIANT>
template <class RET, size_t INDEX>
RET& Variant_ImpUtil<VARIANT>::Variant_UnsafeGetImpl(
                                                  bsl::in_place_index_t<INDEX>,
                                                  VARIANT& variant)
{
    return variant_getAlternativeImpl<RET>(bsl::in_place_index_t<INDEX>(),
                                           variant.d_union);
}

template <class VARIANT>
template <class RET, size_t INDEX>
RET& Variant_ImpUtil<VARIANT>::Variant_UnsafeGetImpl(
                                                  bsl::in_place_index_t<INDEX>,
                                                  const VARIANT& variant)
{
    return variant_getAlternativeImpl<RET>(bsl::in_place_index_t<INDEX>(),
                                           variant.d_union);
}

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 0
template <class TYPE, class HEAD>
TYPE& Variant_UnsafeGet(bsl::variant<HEAD>& obj)
{
    typedef typename bsl::variant<HEAD>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 1
template <class TYPE, class HEAD, class TAIL_01>
TYPE& Variant_UnsafeGet(bsl::variant<HEAD, TAIL_01>& obj)
{
    typedef typename bsl::variant<HEAD, TAIL_01>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 2
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02>
TYPE& Variant_UnsafeGet(bsl::variant<HEAD, TAIL_01,
                                           TAIL_02>& obj)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 3
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03>
TYPE& Variant_UnsafeGet(bsl::variant<HEAD, TAIL_01,
                                           TAIL_02,
                                           TAIL_03>& obj)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 4
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04>
TYPE& Variant_UnsafeGet(bsl::variant<HEAD, TAIL_01,
                                           TAIL_02,
                                           TAIL_03,
                                           TAIL_04>& obj)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 5
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05>
TYPE& Variant_UnsafeGet(bsl::variant<HEAD, TAIL_01,
                                           TAIL_02,
                                           TAIL_03,
                                           TAIL_04,
                                           TAIL_05>& obj)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 6
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06>
TYPE& Variant_UnsafeGet(bsl::variant<HEAD, TAIL_01,
                                           TAIL_02,
                                           TAIL_03,
                                           TAIL_04,
                                           TAIL_05,
                                           TAIL_06>& obj)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 7
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07>
TYPE& Variant_UnsafeGet(bsl::variant<HEAD, TAIL_01,
                                           TAIL_02,
                                           TAIL_03,
                                           TAIL_04,
                                           TAIL_05,
                                           TAIL_06,
                                           TAIL_07>& obj)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 8
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08>
TYPE& Variant_UnsafeGet(bsl::variant<HEAD, TAIL_01,
                                           TAIL_02,
                                           TAIL_03,
                                           TAIL_04,
                                           TAIL_05,
                                           TAIL_06,
                                           TAIL_07,
                                           TAIL_08>& obj)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 9
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08,
                                  class TAIL_09>
TYPE& Variant_UnsafeGet(bsl::variant<HEAD, TAIL_01,
                                           TAIL_02,
                                           TAIL_03,
                                           TAIL_04,
                                           TAIL_05,
                                           TAIL_06,
                                           TAIL_07,
                                           TAIL_08,
                                           TAIL_09>& obj)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08,
                                        TAIL_09>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 10
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08,
                                  class TAIL_09,
                                  class TAIL_10>
TYPE& Variant_UnsafeGet(bsl::variant<HEAD, TAIL_01,
                                           TAIL_02,
                                           TAIL_03,
                                           TAIL_04,
                                           TAIL_05,
                                           TAIL_06,
                                           TAIL_07,
                                           TAIL_08,
                                           TAIL_09,
                                           TAIL_10>& obj)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08,
                                        TAIL_09,
                                        TAIL_10>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 0
template <class TYPE, class HEAD>
const TYPE& Variant_UnsafeGet(const bsl::variant<HEAD>& obj)
{
    typedef typename bsl::variant<HEAD>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<const TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 1
template <class TYPE, class HEAD, class TAIL_01>
const TYPE& Variant_UnsafeGet(const bsl::variant<HEAD, TAIL_01>& obj)
{
    typedef typename bsl::variant<HEAD, TAIL_01>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<const TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 2
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02>
const TYPE& Variant_UnsafeGet(const bsl::variant<HEAD, TAIL_01,
                                                       TAIL_02>& obj)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<const TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 3
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03>
const TYPE& Variant_UnsafeGet(const bsl::variant<HEAD, TAIL_01,
                                                       TAIL_02,
                                                       TAIL_03>& obj)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<const TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 4
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04>
const TYPE& Variant_UnsafeGet(const bsl::variant<HEAD, TAIL_01,
                                                       TAIL_02,
                                                       TAIL_03,
                                                       TAIL_04>& obj)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<const TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 5
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05>
const TYPE& Variant_UnsafeGet(const bsl::variant<HEAD, TAIL_01,
                                                       TAIL_02,
                                                       TAIL_03,
                                                       TAIL_04,
                                                       TAIL_05>& obj)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<const TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 6
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06>
const TYPE& Variant_UnsafeGet(const bsl::variant<HEAD, TAIL_01,
                                                       TAIL_02,
                                                       TAIL_03,
                                                       TAIL_04,
                                                       TAIL_05,
                                                       TAIL_06>& obj)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<const TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 7
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07>
const TYPE& Variant_UnsafeGet(const bsl::variant<HEAD, TAIL_01,
                                                       TAIL_02,
                                                       TAIL_03,
                                                       TAIL_04,
                                                       TAIL_05,
                                                       TAIL_06,
                                                       TAIL_07>& obj)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<const TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 8
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08>
const TYPE& Variant_UnsafeGet(const bsl::variant<HEAD, TAIL_01,
                                                       TAIL_02,
                                                       TAIL_03,
                                                       TAIL_04,
                                                       TAIL_05,
                                                       TAIL_06,
                                                       TAIL_07,
                                                       TAIL_08>& obj)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<const TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 9
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08,
                                  class TAIL_09>
const TYPE& Variant_UnsafeGet(const bsl::variant<HEAD, TAIL_01,
                                                       TAIL_02,
                                                       TAIL_03,
                                                       TAIL_04,
                                                       TAIL_05,
                                                       TAIL_06,
                                                       TAIL_07,
                                                       TAIL_08,
                                                       TAIL_09>& obj)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08,
                                        TAIL_09>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<const TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 10
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08,
                                  class TAIL_09,
                                  class TAIL_10>
const TYPE& Variant_UnsafeGet(const bsl::variant<HEAD, TAIL_01,
                                                       TAIL_02,
                                                       TAIL_03,
                                                       TAIL_04,
                                                       TAIL_05,
                                                       TAIL_06,
                                                       TAIL_07,
                                                       TAIL_08,
                                                       TAIL_09,
                                                       TAIL_10>& obj)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08,
                                        TAIL_09,
                                        TAIL_10>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<const TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 10


template <class R, class VISITOR, class VARIANT, class ALT_TYPE>
struct Variant_Function {
    static R functionImpl(VISITOR& visitor, VARIANT& variant)
    {
        return visitor(Variant_UnsafeGet<ALT_TYPE>(variant));
    }
};

template <class VISITOR, class VARIANT, class ALT_TYPE>
struct Variant_Function<void, VISITOR, VARIANT, ALT_TYPE> {
    static void functionImpl(VISITOR& visitor, VARIANT& variant)
    {
        visitor(Variant_UnsafeGet<ALT_TYPE>(variant));
    }
};

template <class R, class VISITOR, class VARIANT, class ALT_TYPE>
struct Variant_MoveFunction {
    static R functionImpl(VISITOR& visitor, VARIANT& variant)
    {
        typedef BloombergLP::bslmf::MovableRefUtil MoveUtil;

        return visitor(MoveUtil::move(Variant_UnsafeGet<ALT_TYPE>(variant)));
    }
};

template <class VISITOR, class VARIANT, class ALT_TYPE>
struct Variant_MoveFunction<void, VISITOR, VARIANT, ALT_TYPE> {
    static void functionImpl(VISITOR& visitor, VARIANT& variant)
    {
        typedef BloombergLP::bslmf::MovableRefUtil MoveUtil;

        visitor(MoveUtil::move(Variant_UnsafeGet<ALT_TYPE>(variant)));
    }
};

template <class R, class VISITOR, class VARIANT, class ALT_TYPE>
struct Variant_FunctionId {
    static R functionImpl(VISITOR& visitor, VARIANT& variant)
    {
        static const size_t INDEX = BSLSTL_VARIANT_INDEX_OF(
            ALT_TYPE, typename bsl::remove_cv<VARIANT>::type);

        return visitor(bsl::in_place_index_t<INDEX>(),
                       Variant_UnsafeGet<ALT_TYPE>(variant));
    }
};

template <class R,
          class VISITOR,
          class VARIANT
#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 0
        , class UNUSED_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 1
        , class UNUSED_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 2
        , class UNUSED_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 3
        , class UNUSED_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 4
        , class UNUSED_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 5
        , class UNUSED_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 6
        , class UNUSED_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 7
        , class UNUSED_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 8
        , class UNUSED_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 9
        , class UNUSED_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 9
        , class = BSLS_COMPILERFEATURES_NILT>
struct Variant_VTable;


#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 0
template <class R, class VISITOR, class HEAD>
struct Variant_VTable<R, VISITOR, bsl::variant<HEAD> > {

    typedef R (*FuncPtr)(VISITOR&, bsl::variant<HEAD>&);

    typedef bsl::variant<HEAD> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *moveMap()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_MoveFunction<R, VISITOR, VARIANT, HEAD>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl)};
        return s_mapArray;
    }
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 1
template <class R, class VISITOR, class HEAD, class TAIL_01>
struct Variant_VTable<R, VISITOR, bsl::variant<HEAD, TAIL_01> > {

    typedef R (*FuncPtr)(VISITOR&, bsl::variant<HEAD, TAIL_01>&);

    typedef bsl::variant<HEAD, TAIL_01> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_01>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *moveMap()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_MoveFunction<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_01>::
            functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_01>::functionImpl)};
        return s_mapArray;
    }
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 2
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02>
struct Variant_VTable<R, VISITOR, bsl::variant<HEAD, TAIL_01,
                                                     TAIL_02> > {

    typedef R (*FuncPtr)(VISITOR&, bsl::variant<HEAD, TAIL_01,
                                                      TAIL_02>&);

    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_02>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *moveMap()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_MoveFunction<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_01>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_02>::
            functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_02>::functionImpl)};
        return s_mapArray;
    }
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 3
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03>
struct Variant_VTable<R, VISITOR, bsl::variant<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03> > {

    typedef R (*FuncPtr)(VISITOR&, bsl::variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03>&);

    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_03>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *moveMap()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_MoveFunction<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_01>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_02>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_03>::
            functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_03>::functionImpl)};
        return s_mapArray;
    }
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 4
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04>
struct Variant_VTable<R, VISITOR, bsl::variant<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04> > {

    typedef R (*FuncPtr)(VISITOR&, bsl::variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04>&);

    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_04>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *moveMap()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_MoveFunction<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_01>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_02>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_03>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_04>::
            functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_04>::functionImpl)};
        return s_mapArray;
    }
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 5
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05>
struct Variant_VTable<R, VISITOR, bsl::variant<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05> > {

    typedef R (*FuncPtr)(VISITOR&, bsl::variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05>&);

    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_05>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *moveMap()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_MoveFunction<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_01>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_02>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_03>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_04>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_05>::
            functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_05>::functionImpl)};
        return s_mapArray;
    }
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 6
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06>
struct Variant_VTable<R, VISITOR, bsl::variant<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06> > {

    typedef R (*FuncPtr)(VISITOR&, bsl::variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06>&);

    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_05>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_06>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *moveMap()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_MoveFunction<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_01>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_02>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_03>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_04>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_05>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_06>::
            functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_05>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_06>::functionImpl)};
        return s_mapArray;
    }
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 7
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07>
struct Variant_VTable<R, VISITOR, bsl::variant<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07> > {

    typedef R (*FuncPtr)(VISITOR&, bsl::variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07>&);

    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06,
                               TAIL_07> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_05>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_06>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_07>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *moveMap()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_MoveFunction<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_01>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_02>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_03>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_04>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_05>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_06>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_07>::
            functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_05>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_06>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_07>::functionImpl)};
        return s_mapArray;
    }
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 8
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07,
                                              class TAIL_08>
struct Variant_VTable<R, VISITOR, bsl::variant<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07,
                                                     TAIL_08> > {

    typedef R (*FuncPtr)(VISITOR&, bsl::variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08>&);

    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06,
                               TAIL_07,
                               TAIL_08> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_05>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_06>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_07>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_08>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *moveMap()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_MoveFunction<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_01>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_02>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_03>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_04>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_05>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_06>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_07>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_08>::
            functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_05>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_06>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_07>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_08>::functionImpl)};
        return s_mapArray;
    }
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 9
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07,
                                              class TAIL_08,
                                              class TAIL_09>
struct Variant_VTable<R, VISITOR, bsl::variant<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07,
                                                     TAIL_08,
                                                     TAIL_09> > {

    typedef R (*FuncPtr)(VISITOR&, bsl::variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08,
                                                      TAIL_09>&);

    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06,
                               TAIL_07,
                               TAIL_08,
                               TAIL_09> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_05>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_06>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_07>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_08>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_09>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *moveMap()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_MoveFunction<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_01>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_02>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_03>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_04>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_05>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_06>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_07>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_08>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_09>::
            functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_05>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_06>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_07>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_08>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_09>::functionImpl)};
        return s_mapArray;
    }
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 10
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07,
                                              class TAIL_08,
                                              class TAIL_09,
                                              class TAIL_10>
struct Variant_VTable<R, VISITOR, bsl::variant<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07,
                                                     TAIL_08,
                                                     TAIL_09,
                                                     TAIL_10> > {

    typedef R (*FuncPtr)(VISITOR&, bsl::variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08,
                                                      TAIL_09,
                                                      TAIL_10>&);

    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06,
                               TAIL_07,
                               TAIL_08,
                               TAIL_09,
                               TAIL_10> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_05>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_06>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_07>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_08>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_09>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_10>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *moveMap()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_MoveFunction<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_01>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_02>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_03>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_04>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_05>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_06>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_07>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_08>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_09>::
            functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL_10>::
            functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_05>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_06>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_07>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_08>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_09>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_10>::functionImpl)};
        return s_mapArray;
    }
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 0
template <class R, class VISITOR, class HEAD>
struct Variant_VTable<R, VISITOR, const bsl::variant<HEAD> > {

    typedef R (*FuncPtr)(VISITOR&, const bsl::variant<HEAD>&);

    typedef const bsl::variant<HEAD> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl)};
        return s_mapArray;
    }
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 1
template <class R, class VISITOR, class HEAD, class TAIL_01>
struct Variant_VTable<R, VISITOR, const bsl::variant<HEAD, TAIL_01> > {

    typedef R (*FuncPtr)(VISITOR&, const bsl::variant<HEAD, TAIL_01>&);

    typedef const bsl::variant<HEAD, TAIL_01> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_01>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_01>::functionImpl)};
        return s_mapArray;
    }
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 2
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02>
struct Variant_VTable<R, VISITOR, const bsl::variant<HEAD, TAIL_01,
                                                           TAIL_02> > {

    typedef R (*FuncPtr)(VISITOR&, const bsl::variant<HEAD, TAIL_01,
                                                            TAIL_02>&);

    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_02>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_02>::functionImpl)};
        return s_mapArray;
    }
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 3
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03>
struct Variant_VTable<R, VISITOR, const bsl::variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03> > {

    typedef R (*FuncPtr)(VISITOR&, const bsl::variant<HEAD, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03>&);

    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_03>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_03>::functionImpl)};
        return s_mapArray;
    }
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 4
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04>
struct Variant_VTable<R, VISITOR, const bsl::variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04> > {

    typedef R (*FuncPtr)(VISITOR&, const bsl::variant<HEAD, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04>&);

    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_04>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_04>::functionImpl)};
        return s_mapArray;
    }
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 5
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05>
struct Variant_VTable<R, VISITOR, const bsl::variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05> > {

    typedef R (*FuncPtr)(VISITOR&, const bsl::variant<HEAD, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05>&);

    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_05>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_05>::functionImpl)};
        return s_mapArray;
    }
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 6
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06>
struct Variant_VTable<R, VISITOR, const bsl::variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06> > {

    typedef R (*FuncPtr)(VISITOR&, const bsl::variant<HEAD, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06>&);

    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05,
                                     TAIL_06> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_05>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_06>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_05>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_06>::functionImpl)};
        return s_mapArray;
    }
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 7
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07>
struct Variant_VTable<R, VISITOR, const bsl::variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07> > {

    typedef R (*FuncPtr)(VISITOR&, const bsl::variant<HEAD, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07>&);

    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05,
                                     TAIL_06,
                                     TAIL_07> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_05>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_06>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_07>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_05>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_06>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_07>::functionImpl)};
        return s_mapArray;
    }
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 8
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07,
                                              class TAIL_08>
struct Variant_VTable<R, VISITOR, const bsl::variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08> > {

    typedef R (*FuncPtr)(VISITOR&, const bsl::variant<HEAD, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08>&);

    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05,
                                     TAIL_06,
                                     TAIL_07,
                                     TAIL_08> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_05>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_06>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_07>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_08>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_05>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_06>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_07>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_08>::functionImpl)};
        return s_mapArray;
    }
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 9
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07,
                                              class TAIL_08,
                                              class TAIL_09>
struct Variant_VTable<R, VISITOR, const bsl::variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08,
                                                           TAIL_09> > {

    typedef R (*FuncPtr)(VISITOR&, const bsl::variant<HEAD, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08,
                                                            TAIL_09>&);

    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05,
                                     TAIL_06,
                                     TAIL_07,
                                     TAIL_08,
                                     TAIL_09> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_05>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_06>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_07>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_08>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_09>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_05>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_06>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_07>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_08>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_09>::functionImpl)};
        return s_mapArray;
    }
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 10
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07,
                                              class TAIL_08,
                                              class TAIL_09,
                                              class TAIL_10>
struct Variant_VTable<R, VISITOR, const bsl::variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08,
                                                           TAIL_09,
                                                           TAIL_10> > {

    typedef R (*FuncPtr)(VISITOR&, const bsl::variant<HEAD, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08,
                                                            TAIL_09,
                                                            TAIL_10>&);

    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05,
                                     TAIL_06,
                                     TAIL_07,
                                     TAIL_08,
                                     TAIL_09,
                                     TAIL_10> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_05>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_06>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_07>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_08>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_09>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL_10>::functionImpl)};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_01>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_02>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_03>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_04>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_05>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_06>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_07>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_08>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_09>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL_10>::functionImpl)};
        return s_mapArray;
    }
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 0
template <class R, class VISITOR, class HEAD>
R Variant_VisitImpl(VISITOR& visitor, bsl::variant<HEAD>& variant)
{
    typedef bsl::variant<HEAD>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 1
template <class R, class VISITOR, class HEAD, class TAIL_01>
R Variant_VisitImpl(VISITOR& visitor, bsl::variant<HEAD, TAIL_01>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 2
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02>
R Variant_VisitImpl(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                         TAIL_02>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 3
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03>
R Variant_VisitImpl(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 4
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04>
R Variant_VisitImpl(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03,
                                                         TAIL_04>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 5
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05>
R Variant_VisitImpl(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03,
                                                         TAIL_04,
                                                         TAIL_05>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 6
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06>
R Variant_VisitImpl(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03,
                                                         TAIL_04,
                                                         TAIL_05,
                                                         TAIL_06>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 7
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07>
R Variant_VisitImpl(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03,
                                                         TAIL_04,
                                                         TAIL_05,
                                                         TAIL_06,
                                                         TAIL_07>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06,
                               TAIL_07>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 8
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07,
                                              class TAIL_08>
R Variant_VisitImpl(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03,
                                                         TAIL_04,
                                                         TAIL_05,
                                                         TAIL_06,
                                                         TAIL_07,
                                                         TAIL_08>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06,
                               TAIL_07,
                               TAIL_08>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 9
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07,
                                              class TAIL_08,
                                              class TAIL_09>
R Variant_VisitImpl(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03,
                                                         TAIL_04,
                                                         TAIL_05,
                                                         TAIL_06,
                                                         TAIL_07,
                                                         TAIL_08,
                                                         TAIL_09>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06,
                               TAIL_07,
                               TAIL_08,
                               TAIL_09>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 10
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07,
                                              class TAIL_08,
                                              class TAIL_09,
                                              class TAIL_10>
R Variant_VisitImpl(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03,
                                                         TAIL_04,
                                                         TAIL_05,
                                                         TAIL_06,
                                                         TAIL_07,
                                                         TAIL_08,
                                                         TAIL_09,
                                                         TAIL_10>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06,
                               TAIL_07,
                               TAIL_08,
                               TAIL_09,
                               TAIL_10>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 0
template <class R, class VISITOR, class HEAD>
R Variant_VisitImpl(VISITOR&                           visitor,
                    const bsl::variant<HEAD>& variant)
{
    typedef const bsl::variant<HEAD>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 1
template <class R, class VISITOR, class HEAD, class TAIL_01>
R Variant_VisitImpl(VISITOR&                           visitor,
                    const bsl::variant<HEAD, TAIL_01>& variant)
{
    typedef const bsl::variant<HEAD, TAIL_01>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 2
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02>
R Variant_VisitImpl(VISITOR&                           visitor,
                    const bsl::variant<HEAD, TAIL_01,
                                             TAIL_02>& variant)
{
    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 3
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03>
R Variant_VisitImpl(VISITOR&                           visitor,
                    const bsl::variant<HEAD, TAIL_01,
                                             TAIL_02,
                                             TAIL_03>& variant)
{
    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 4
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04>
R Variant_VisitImpl(VISITOR&                           visitor,
                    const bsl::variant<HEAD, TAIL_01,
                                             TAIL_02,
                                             TAIL_03,
                                             TAIL_04>& variant)
{
    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 5
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05>
R Variant_VisitImpl(VISITOR&                           visitor,
                    const bsl::variant<HEAD, TAIL_01,
                                             TAIL_02,
                                             TAIL_03,
                                             TAIL_04,
                                             TAIL_05>& variant)
{
    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 6
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06>
R Variant_VisitImpl(VISITOR&                           visitor,
                    const bsl::variant<HEAD, TAIL_01,
                                             TAIL_02,
                                             TAIL_03,
                                             TAIL_04,
                                             TAIL_05,
                                             TAIL_06>& variant)
{
    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05,
                                     TAIL_06>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 7
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07>
R Variant_VisitImpl(VISITOR&                           visitor,
                    const bsl::variant<HEAD, TAIL_01,
                                             TAIL_02,
                                             TAIL_03,
                                             TAIL_04,
                                             TAIL_05,
                                             TAIL_06,
                                             TAIL_07>& variant)
{
    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05,
                                     TAIL_06,
                                     TAIL_07>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 8
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07,
                                              class TAIL_08>
R Variant_VisitImpl(VISITOR&                           visitor,
                    const bsl::variant<HEAD, TAIL_01,
                                             TAIL_02,
                                             TAIL_03,
                                             TAIL_04,
                                             TAIL_05,
                                             TAIL_06,
                                             TAIL_07,
                                             TAIL_08>& variant)
{
    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05,
                                     TAIL_06,
                                     TAIL_07,
                                     TAIL_08>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 9
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07,
                                              class TAIL_08,
                                              class TAIL_09>
R Variant_VisitImpl(VISITOR&                           visitor,
                    const bsl::variant<HEAD, TAIL_01,
                                             TAIL_02,
                                             TAIL_03,
                                             TAIL_04,
                                             TAIL_05,
                                             TAIL_06,
                                             TAIL_07,
                                             TAIL_08,
                                             TAIL_09>& variant)
{
    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05,
                                     TAIL_06,
                                     TAIL_07,
                                     TAIL_08,
                                     TAIL_09>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 10
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07,
                                              class TAIL_08,
                                              class TAIL_09,
                                              class TAIL_10>
R Variant_VisitImpl(VISITOR&                           visitor,
                    const bsl::variant<HEAD, TAIL_01,
                                             TAIL_02,
                                             TAIL_03,
                                             TAIL_04,
                                             TAIL_05,
                                             TAIL_06,
                                             TAIL_07,
                                             TAIL_08,
                                             TAIL_09,
                                             TAIL_10>& variant)
{
    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05,
                                     TAIL_06,
                                     TAIL_07,
                                     TAIL_08,
                                     TAIL_09,
                                     TAIL_10>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 0
template <class R, class VISITOR, class HEAD>
R Variant_MoveVisitImpl(VISITOR& visitor, bsl::variant<HEAD>& variant)
{
    typedef bsl::variant<HEAD>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::moveMap()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 1
template <class R, class VISITOR, class HEAD, class TAIL_01>
R Variant_MoveVisitImpl(VISITOR& visitor, bsl::variant<HEAD, TAIL_01>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::moveMap()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 2
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02>
R Variant_MoveVisitImpl(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                             TAIL_02>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::moveMap()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 3
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03>
R Variant_MoveVisitImpl(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::moveMap()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 4
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04>
R Variant_MoveVisitImpl(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03,
                                                             TAIL_04>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::moveMap()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 5
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05>
R Variant_MoveVisitImpl(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03,
                                                             TAIL_04,
                                                             TAIL_05>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::moveMap()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 6
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06>
R Variant_MoveVisitImpl(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03,
                                                             TAIL_04,
                                                             TAIL_05,
                                                             TAIL_06>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::moveMap()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 7
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07>
R Variant_MoveVisitImpl(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03,
                                                             TAIL_04,
                                                             TAIL_05,
                                                             TAIL_06,
                                                             TAIL_07>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06,
                               TAIL_07>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::moveMap()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 8
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07,
                                              class TAIL_08>
R Variant_MoveVisitImpl(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03,
                                                             TAIL_04,
                                                             TAIL_05,
                                                             TAIL_06,
                                                             TAIL_07,
                                                             TAIL_08>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06,
                               TAIL_07,
                               TAIL_08>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::moveMap()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 9
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07,
                                              class TAIL_08,
                                              class TAIL_09>
R Variant_MoveVisitImpl(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03,
                                                             TAIL_04,
                                                             TAIL_05,
                                                             TAIL_06,
                                                             TAIL_07,
                                                             TAIL_08,
                                                             TAIL_09>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06,
                               TAIL_07,
                               TAIL_08,
                               TAIL_09>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::moveMap()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 10
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07,
                                              class TAIL_08,
                                              class TAIL_09,
                                              class TAIL_10>
R Variant_MoveVisitImpl(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03,
                                                             TAIL_04,
                                                             TAIL_05,
                                                             TAIL_06,
                                                             TAIL_07,
                                                             TAIL_08,
                                                             TAIL_09,
                                                             TAIL_10>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06,
                               TAIL_07,
                               TAIL_08,
                               TAIL_09,
                               TAIL_10>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::moveMap()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 0
template <class R, class VISITOR, class HEAD>
R Variant_VisitImplId(VISITOR& visitor, bsl::variant<HEAD>& variant)
{
    typedef bsl::variant<HEAD>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 1
template <class R, class VISITOR, class HEAD, class TAIL_01>
R Variant_VisitImplId(VISITOR& visitor, bsl::variant<HEAD, TAIL_01>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 2
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02>
R Variant_VisitImplId(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                           TAIL_02>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 3
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03>
R Variant_VisitImplId(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 4
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04>
R Variant_VisitImplId(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 5
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05>
R Variant_VisitImplId(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 6
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06>
R Variant_VisitImplId(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 7
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07>
R Variant_VisitImplId(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06,
                               TAIL_07>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 8
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07,
                                              class TAIL_08>
R Variant_VisitImplId(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06,
                               TAIL_07,
                               TAIL_08>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 9
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07,
                                              class TAIL_08,
                                              class TAIL_09>
R Variant_VisitImplId(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08,
                                                           TAIL_09>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06,
                               TAIL_07,
                               TAIL_08,
                               TAIL_09>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 10
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07,
                                              class TAIL_08,
                                              class TAIL_09,
                                              class TAIL_10>
R Variant_VisitImplId(VISITOR& visitor, bsl::variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08,
                                                           TAIL_09,
                                                           TAIL_10>& variant)
{
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06,
                               TAIL_07,
                               TAIL_08,
                               TAIL_09,
                               TAIL_10>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 0
template <class R, class VISITOR, class HEAD>
R Variant_VisitImplId(VISITOR&                           visitor,
                      const bsl::variant<HEAD>& variant)
{
    typedef const bsl::variant<HEAD>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 1
template <class R, class VISITOR, class HEAD, class TAIL_01>
R Variant_VisitImplId(VISITOR&                           visitor,
                      const bsl::variant<HEAD, TAIL_01>& variant)
{
    typedef const bsl::variant<HEAD, TAIL_01>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 2
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02>
R Variant_VisitImplId(VISITOR&                           visitor,
                      const bsl::variant<HEAD, TAIL_01,
                                               TAIL_02>& variant)
{
    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 3
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03>
R Variant_VisitImplId(VISITOR&                           visitor,
                      const bsl::variant<HEAD, TAIL_01,
                                               TAIL_02,
                                               TAIL_03>& variant)
{
    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 4
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04>
R Variant_VisitImplId(VISITOR&                           visitor,
                      const bsl::variant<HEAD, TAIL_01,
                                               TAIL_02,
                                               TAIL_03,
                                               TAIL_04>& variant)
{
    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 5
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05>
R Variant_VisitImplId(VISITOR&                           visitor,
                      const bsl::variant<HEAD, TAIL_01,
                                               TAIL_02,
                                               TAIL_03,
                                               TAIL_04,
                                               TAIL_05>& variant)
{
    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 6
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06>
R Variant_VisitImplId(VISITOR&                           visitor,
                      const bsl::variant<HEAD, TAIL_01,
                                               TAIL_02,
                                               TAIL_03,
                                               TAIL_04,
                                               TAIL_05,
                                               TAIL_06>& variant)
{
    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05,
                                     TAIL_06>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 7
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07>
R Variant_VisitImplId(VISITOR&                           visitor,
                      const bsl::variant<HEAD, TAIL_01,
                                               TAIL_02,
                                               TAIL_03,
                                               TAIL_04,
                                               TAIL_05,
                                               TAIL_06,
                                               TAIL_07>& variant)
{
    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05,
                                     TAIL_06,
                                     TAIL_07>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 8
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07,
                                              class TAIL_08>
R Variant_VisitImplId(VISITOR&                           visitor,
                      const bsl::variant<HEAD, TAIL_01,
                                               TAIL_02,
                                               TAIL_03,
                                               TAIL_04,
                                               TAIL_05,
                                               TAIL_06,
                                               TAIL_07,
                                               TAIL_08>& variant)
{
    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05,
                                     TAIL_06,
                                     TAIL_07,
                                     TAIL_08>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 9
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07,
                                              class TAIL_08,
                                              class TAIL_09>
R Variant_VisitImplId(VISITOR&                           visitor,
                      const bsl::variant<HEAD, TAIL_01,
                                               TAIL_02,
                                               TAIL_03,
                                               TAIL_04,
                                               TAIL_05,
                                               TAIL_06,
                                               TAIL_07,
                                               TAIL_08,
                                               TAIL_09>& variant)
{
    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05,
                                     TAIL_06,
                                     TAIL_07,
                                     TAIL_08,
                                     TAIL_09>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 10
template <class R, class VISITOR, class HEAD, class TAIL_01,
                                              class TAIL_02,
                                              class TAIL_03,
                                              class TAIL_04,
                                              class TAIL_05,
                                              class TAIL_06,
                                              class TAIL_07,
                                              class TAIL_08,
                                              class TAIL_09,
                                              class TAIL_10>
R Variant_VisitImplId(VISITOR&                           visitor,
                      const bsl::variant<HEAD, TAIL_01,
                                               TAIL_02,
                                               TAIL_03,
                                               TAIL_04,
                                               TAIL_05,
                                               TAIL_06,
                                               TAIL_07,
                                               TAIL_08,
                                               TAIL_09,
                                               TAIL_10>& variant)
{
    typedef const bsl::variant<HEAD, TAIL_01,
                                     TAIL_02,
                                     TAIL_03,
                                     TAIL_04,
                                     TAIL_05,
                                     TAIL_06,
                                     TAIL_07,
                                     TAIL_08,
                                     TAIL_09,
                                     TAIL_10>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_G >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class VARIANT>
template <class RET, size_t INDEX>
RET& Variant_ImpUtil<VARIANT>::Variant_UnsafeGetImpl(
                                                  bsl::in_place_index_t<INDEX>,
                                                  VARIANT& variant)
{
    return variant_getAlternativeImpl<RET>(bsl::in_place_index_t<INDEX>(),
                                           variant.d_union);
}

template <class VARIANT>
template <class RET, size_t INDEX>
RET& Variant_ImpUtil<VARIANT>::Variant_UnsafeGetImpl(
                                                  bsl::in_place_index_t<INDEX>,
                                                  const VARIANT& variant)
{
    return variant_getAlternativeImpl<RET>(bsl::in_place_index_t<INDEX>(),
                                           variant.d_union);
}

template <class TYPE, class HEAD, class... TAIL>
TYPE& Variant_UnsafeGet(bsl::variant<HEAD, TAIL...>& obj)
{
    typedef typename bsl::variant<HEAD, TAIL...>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}

template <class TYPE, class HEAD, class... TAIL>
const TYPE& Variant_UnsafeGet(const bsl::variant<HEAD, TAIL...>& obj)
{
    typedef typename bsl::variant<HEAD, TAIL...>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template Variant_UnsafeGetImpl<const TYPE>(
        bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(), obj);
}

template <class R, class VISITOR, class VARIANT, class ALT_TYPE>
struct Variant_Function {
    static R functionImpl(VISITOR& visitor, VARIANT& variant)
    {
        return visitor(Variant_UnsafeGet<ALT_TYPE>(variant));
    }
};

template <class VISITOR, class VARIANT, class ALT_TYPE>
struct Variant_Function<void, VISITOR, VARIANT, ALT_TYPE> {
    static void functionImpl(VISITOR& visitor, VARIANT& variant)
    {
        visitor(Variant_UnsafeGet<ALT_TYPE>(variant));
    }
};

template <class R, class VISITOR, class VARIANT, class ALT_TYPE>
struct Variant_MoveFunction {
    static R functionImpl(VISITOR& visitor, VARIANT& variant)
    {
        typedef BloombergLP::bslmf::MovableRefUtil MoveUtil;

        return visitor(MoveUtil::move(Variant_UnsafeGet<ALT_TYPE>(variant)));
    }
};

template <class VISITOR, class VARIANT, class ALT_TYPE>
struct Variant_MoveFunction<void, VISITOR, VARIANT, ALT_TYPE> {
    static void functionImpl(VISITOR& visitor, VARIANT& variant)
    {
        typedef BloombergLP::bslmf::MovableRefUtil MoveUtil;

        visitor(MoveUtil::move(Variant_UnsafeGet<ALT_TYPE>(variant)));
    }
};

template <class R, class VISITOR, class VARIANT, class ALT_TYPE>
struct Variant_FunctionId {
    static R functionImpl(VISITOR& visitor, VARIANT& variant)
    {
        static const size_t INDEX = BSLSTL_VARIANT_INDEX_OF(
            ALT_TYPE, typename bsl::remove_cv<VARIANT>::type);

        return visitor(bsl::in_place_index_t<INDEX>(),
                       Variant_UnsafeGet<ALT_TYPE>(variant));
    }
};

template <class R, class VISITOR, class VARIANT, class... UNUSED>
struct Variant_VTable;

template <class R, class VISITOR, class HEAD, class... TAIL>
struct Variant_VTable<R, VISITOR, bsl::variant<HEAD, TAIL...> > {

    typedef R (*FuncPtr)(VISITOR&, bsl::variant<HEAD, TAIL...>&);

    typedef bsl::variant<HEAD, TAIL...> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL>::functionImpl)...};
        return s_mapArray;
    }

    static const FuncPtr *moveMap()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_MoveFunction<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_MoveFunction<R, VISITOR, VARIANT, TAIL>::
                  functionImpl)...};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL>::functionImpl)...};
        return s_mapArray;
    }
};

template <class R, class VISITOR, class HEAD, class... TAIL>
struct Variant_VTable<R, VISITOR, const bsl::variant<HEAD, TAIL...> > {

    typedef R (*FuncPtr)(VISITOR&, const bsl::variant<HEAD, TAIL...>&);

    typedef const bsl::variant<HEAD, TAIL...> VARIANT;

    static const FuncPtr *map()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_Function<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_Function<R, VISITOR, VARIANT, TAIL>::functionImpl)...};
        return s_mapArray;
    }

    static const FuncPtr *mapId()
    {
        static const FuncPtr s_mapArray[] = {
            &(Variant_FunctionId<R, VISITOR, VARIANT, HEAD>::functionImpl),
            &(Variant_FunctionId<R, VISITOR, VARIANT, TAIL>::functionImpl)...};
        return s_mapArray;
    }
};

template <class R, class VISITOR, class HEAD, class... TAIL>
R Variant_VisitImpl(VISITOR& visitor, bsl::variant<HEAD, TAIL...>& variant)
{
    typedef bsl::variant<HEAD, TAIL...>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}

template <class R, class VISITOR, class HEAD, class... TAIL>
R Variant_VisitImpl(VISITOR&                           visitor,
                    const bsl::variant<HEAD, TAIL...>& variant)
{
    typedef const bsl::variant<HEAD, TAIL...>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::map()[variant.index()];

    return (*func_ptr)(visitor, variant);
}

template <class R, class VISITOR, class HEAD, class... TAIL>
R Variant_MoveVisitImpl(VISITOR& visitor, bsl::variant<HEAD, TAIL...>& variant)
{
    typedef bsl::variant<HEAD, TAIL...>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::moveMap()[variant.index()];

    return (*func_ptr)(visitor, variant);
}

template <class R, class VISITOR, class HEAD, class... TAIL>
R Variant_VisitImplId(VISITOR& visitor, bsl::variant<HEAD, TAIL...>& variant)
{
    typedef bsl::variant<HEAD, TAIL...>                           VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}

template <class R, class VISITOR, class HEAD, class... TAIL>
R Variant_VisitImplId(VISITOR&                           visitor,
                      const bsl::variant<HEAD, TAIL...>& variant)
{
    typedef const bsl::variant<HEAD, TAIL...>                     VARIANT;
    typedef typename Variant_VTable<R, VISITOR, VARIANT>::FuncPtr FuncPtr;

    FuncPtr func_ptr =
        Variant_VTable<R, VISITOR, VARIANT>::mapId()[variant.index()];

    return (*func_ptr)(visitor, variant);
}

// }}} END GENERATED CODE
#endif
#endif  // BSL_VARIANT_FULL_IMPLEMENTATION

}  // close package namespace
}  // close enterprise namespace

namespace bsl {
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
template <class t_RET, class VISITOR, class VARIANT>
t_RET visit(VISITOR&& visitor, VARIANT&& variant)
    // Return the result of invoking the specified 'visitor' with the currently
    // active alternative of the specified 'variant', implicitly converting the
    // result to the explicitly specified (template parameter) 't_RET'.  If
    // 'variant' does not hold a value, an exception of type
    // 'bsl::bad_variant_access' is thrown.  Note that unlike the 'visit'
    // overload below that deduces its return type, this overload does not
    // require the visitor to yield the exact same type for each alternative,
    // but only requires each such type to be implicitly convertible to 'R'.
    // This function differs from the standard in the following ways:
    //: o only one variant is supported
    //:
    //: o constexpr is not implemented
    //:
    //: o before C++17, only 'VISITOR(ALTERNATIVE)' form of visitation is
    //:   supported; cases where the visitor is a pointer to member are not
    //:   supported.
{
    if (variant.valueless_by_exception()) {
        BSLS_THROW(bsl::bad_variant_access());
    }
    return BloombergLP::bslstl::Variant_VisitImpl<t_RET>(
        std::forward<VISITOR>(visitor), std::forward<VARIANT>(variant));
}

template <class VISITOR, class VARIANT>
typename bsl::invoke_result<
    VISITOR,
    typename BloombergLP::bslstl::Variant_CVQualAlt<VARIANT, 0>::type>::type
visit(VISITOR&& visitor, VARIANT&& variant)
    // Return the result of invoking the specified 'visitor' with the currently
    // active alternative of the specified 'variant'.  If 'variant' does not
    // hold a value, an exception of type 'bsl::bad_variant_access' is thrown.
    // For each alternative, invocation of the visitor with that alternative
    // shall be of the same type and value category.  This function differs
    // from the standard in the following ways:
    //: o only one variant is supported
    //:
    //: o constexpr is not implemented
    //:
    //: o before C++17, only 'VISITOR(ALTERNATIVE)' form of visitation is
    //:   supported; cases where the visitor is a pointer to member are not
    //:   supported.
{
    typedef typename bsl::invoke_result<
        VISITOR,
        typename BloombergLP::bslstl::Variant_CVQualAlt<VARIANT,
                                                        0>::type>::type R;
    static_assert(BloombergLP::bslstl::
                      Variant_IsSameReturnType<R, VISITOR, VARIANT>::value,
                  "The value type and category of invoking the visitor with "
                  "every alternative is not the same");
    if (variant.valueless_by_exception()) {
        BSLS_THROW(bsl::bad_variant_access());
    }
    return BloombergLP::bslstl::Variant_VisitImpl<R>(
        std::forward<VISITOR>(visitor), std::forward<VARIANT>(variant));
}

template <class t_RET, class VISITOR, class VARIANT>
t_RET visitR(VISITOR& visitor, VARIANT&& variant)
    // Return the result of invoking the specified 'visitor' with the currently
    // active alternative of the specified 'variant', implicitly converting the
    // result to the explicitly specified (template parameter) 't_RET'.  If
    // 'variant' does not hold a value, an exception of type
    // 'bsl::bad_variant_access' is thrown.  This function is provided in all
    // language versions for compatibility with the C++03 version (see below),
    // but in new code in C++11 and later, 'bsl::visit' should be used instead
    // of this function.
{
    if (variant.valueless_by_exception()) {
        BSLS_THROW(bsl::bad_variant_access());
    }
    return BloombergLP::bslstl::Variant_VisitImpl<t_RET>(
        visitor, std::forward<VARIANT>(variant));
}
#else  //BSL_VARIANT_FULL_IMPLEMENTATION

template <class t_RET, class VISITOR, class VARIANT>
t_RET visitR(VISITOR& visitor, VARIANT& variant)
    // Return the result of invoking the specified 'visitor' with the currently
    // active alternative of the specified 'variant', implicitly converting the
    // result to the explicitly specified (template parameter) 't_RET'.  If
    // 'variant' does not hold a value, an exception of type
    // 'bsl::bad_variant_access' is thrown.  Unlike 'visit', which deduces its
    // return type, this function does not require the visitor to yield the
    // exact same type for each alternative, but only requires each such type
    // to be implicitly convertible to 't_RET'.  Implementation note: Due to
    // limitations of the type deduction facility in C++03, this function can
    // not share the same name as the deduced type visit because it is not
    // possible to discern between invocation of non deduced return type visit
    // where the return type parameter is explicitly specified and invocation
    // of deduced return type visit where the visitor type parameter is
    // explicitly specified.
{
    if (variant.valueless_by_exception()) {
        BSLS_THROW(bsl::bad_variant_access());
    }
    return BloombergLP::bslstl::Variant_VisitImpl<t_RET>(visitor, variant);
}

template <class t_RET, class VISITOR, class VARIANT>
t_RET visitR(VISITOR& visitor, BloombergLP::bslmf::MovableRef<VARIANT> variant)
    // Return the result of invoking the specified 'visitor' with a
    // 'bslmf::MovableRef' referring to the currently active alternative of the
    // specified 'variant', implicitly converting the result to the explicitly
    // specified (template parameter) 't_RET'.  If 'variant' does not hold a
    // value, an exception of type 'bsl::bad_variant_access' is thrown.  Unlike
    // 'visit', which deduces its return type, this function does not require
    // the visitor to yield the exact same type for each alternative, but only
    // requires each such type to be implicitly convertible to 't_RET'.
    // Implementation note: Due to limitations of the type deduction facility
    // in C++03, this function can not share the same name as the deduced type
    // visit because it is not possible to discern between invocation of non
    // deduced return type visit where the return type parameter is explicitly
    // specified and invocation of deduced return type visit where the visitor
    // type parameter is explicitly specified.
{
    VARIANT& lvalue = variant;
    if (lvalue.valueless_by_exception()) {
        BSLS_THROW(bsl::bad_variant_access());
    }
    return BloombergLP::bslstl::Variant_MoveVisitImpl<t_RET>(visitor, lvalue);
}

template <class VISITOR, class VARIANT>
typename bsl::invoke_result<
    VISITOR,
    typename bsl::variant_alternative<0, VARIANT>::type&>::type
visit(VISITOR& visitor, VARIANT& variant)
    // Return the result of invoking the specified 'visitor' with the currently
    // active alternative of the specified 'variant'.  If 'variant' does not
    // hold a value, an exception of type 'bsl::bad_variant_access' is thrown.
    // For each alternative, invocation of the visitor with that alternative
    // shall be of the same type and value category.
{
    if (variant.valueless_by_exception()) {
        BSLS_THROW(bsl::bad_variant_access());
    }
    typedef typename bsl::invoke_result<
        VISITOR,
        typename bsl::variant_alternative<0, VARIANT>::type&>::type R;

    BSLMF_ASSERT((BloombergLP::bslstl::
                      Variant_IsSameReturnType<R, VISITOR, VARIANT>::value));

    return BloombergLP::bslstl::Variant_VisitImpl<R>(visitor, variant);
}

template <class VISITOR, class VARIANT>
typename bsl::invoke_result<
    VISITOR,
    BloombergLP::bslmf::MovableRef<
        typename bsl::variant_alternative<0, VARIANT>::type> >::type
visit(VISITOR& visitor, BloombergLP::bslmf::MovableRef<VARIANT> variant)
    // Return the result of invoking the specified 'visitor' with a
    // 'bslmf::MovableRef' referring to the currently active alternative of the
    // specified 'variant'.  If 'variant' does not hold a value, an exception
    // of type 'bsl::bad_variant_access' is thrown.  For each alternative,
    // invocation of the visitor with that alternative shall be of the same
    // type and value category.
{
    VARIANT& lvalue = variant;
    if (lvalue.valueless_by_exception()) {
        BSLS_THROW(bsl::bad_variant_access());
    }
    typedef typename bsl::invoke_result<
        VISITOR,
        BloombergLP::bslmf::MovableRef<
            typename bsl::variant_alternative<0, VARIANT>::type> >::type R;

    BSLMF_ASSERT(
        (BloombergLP::bslstl::
             Variant_IsSameMoveReturnType<R, VISITOR, VARIANT>::value));

    return BloombergLP::bslstl::Variant_MoveVisitImpl<R>(visitor, lvalue);
}

#endif  // BSL_VARIANT_FULL_IMPLEMENTATION

}  // close namespace bsl

namespace BloombergLP {
namespace bslstl {

                          // ========================
                          // class Variant_NoSuchType
                          // ========================

struct Variant_NoSuchType {
    // This component-private trivial tag type is used to distinguish between
    // arguments passed by a user, and an 'enable_if' argument.  It is not
    // default constructible so the following construction never invokes a
    // constrained single parameter constructor:
    //..
    //   struct SomeType
    //   {
    //       SomeType(int, const std::string &s = "default"){}
    //   };
    //
    //   variant<SomeType> o(1, {});
    //..

    // CREATORS
    explicit BSLS_KEYWORD_CONSTEXPR Variant_NoSuchType(int)
                                                         BSLS_KEYWORD_NOEXCEPT;
        // Create a 'Variant_NoSuchType' object.
};

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
template <class TYPE>
class Variant_DataImp {
    // This component-private class manages an object of type (template
    // parameter) 'TYPE' that is stored in a 'variant' object.  Note that
    // 'TYPE' may be const-qualified, in which case the internally stored
    // object is not 'const', but the interface of this class prevents
    // modification thereof.

  private:
    // PRIVATE TYPES
    typedef typename bsl::remove_const<TYPE>::type StoredType;

    // DATA
    bsls::ObjectBuffer<StoredType> d_buffer;  // in-place 'TYPE' object

  public:
    // CREATORS
    Variant_DataImp() = default;
        // Create a 'Variant_DataImp' object that holds an empty buffer.

    // MANIPULATORS
    template <class... ARGS>
    Variant_DataImp(ARGS&&... args);
        // Create a 'Variant_DataImp' object whose stored 'TYPE' object is
        // constructed by forwarding the specified 'args' to
        // 'ConstructionUtil::construct directly.  This means the first
        // argument in 'args' must be a pointer to 'bslma::Allocator', which
        // will be ignored if 'TYPE' is not allocator-aware.

    BSLS_KEYWORD_CONSTEXPR_CPP14 TYPE&  value() &;
    BSLS_KEYWORD_CONSTEXPR_CPP14 TYPE&& value() &&;
        // Return a reference to the stored 'TYPE' object.  The behavior is
        // undefined unless this object contains a 'TYPE' object (i.e., this
        // object is currently managing the active alternative of a
        // 'bsl::variant' object).

    // ACCESSORS
    BSLS_KEYWORD_CONSTEXPR_CPP14 const TYPE& value() const&;
    BSLS_KEYWORD_CONSTEXPR_CPP14 const TYPE&& value() const&&;
        // Return a const reference to the stored 'TYPE' object.  The behavior
        // is undefined unless this object contains a 'TYPE' object (i.e., this
        // object is currently managing the active alternative of a
        // 'bsl::variant' object).
};

template <class... TYPES>
union Variant_Union {
    // This component-private union can hold a 'Variant_DataImp' object for
    // any alternative in (template parameters) 'TYPES...'.  The primary
    // template is used when 'TYPES...' is empty.
};

template <class HEAD, class... TAIL>
union Variant_Union<HEAD, TAIL...> {
    // This partial specialization uses template recursion because C++ does not
    // support member packs.

    // PUBLIC DATA
    Variant_DataImp<HEAD>  d_head;
    Variant_Union<TAIL...> d_tail;

    // CREATORS
    Variant_Union() = default;
        // Create a 'Variant_Union' object having no active alternative.

    template <class... ARGS>
    Variant_Union(bsl::in_place_index_t<0>, ARGS&&... args)
    : d_head(std::forward<ARGS>(args)...)
        // Create a 'Variant_Union' object holding an object of type 'HEAD'
        // direct-initialized from the specified 'args'.
    {
    }

    template <size_t t_INDEX, class... ARGS>
    Variant_Union(bsl::in_place_index_t<t_INDEX>, ARGS&&... args)
    : d_tail(bsl::in_place_index_t<t_INDEX - 1>(), std::forward<ARGS>(args)...)
        // Create a 'Variant_Union' object holding the alternative at index
        // (template parameter) 't_INDEX' in (template parameters) 'HEAD,
        // TAIL...', direct-initialized from the specified 'args'.  Note that
        // 't_INDEX' is not necessarily the absolute index of the desired
        // alternative in the 'bsl::variant' object.  We use the tag to
        // "unravel" the union until we get to the desired alternative type.
    {
    }
};
#else  // BSL_VARIANT_FULL_IMPLEMENTATION
template <class TYPE>
class Variant_DataImp {
    // This component-private class manages an object of type (template
    // parameter) 'TYPE' that is stored in a 'variant' object.  Note that
    // 'TYPE' may be const-qualified, in which case the internally stored
    // object is not 'const', but the interface of this class prevents
    // modification thereof.

  private:
    // PRIVATE TYPES
    typedef typename bsl::remove_const<TYPE>::type StoredType;

    // DATA
    bsls::ObjectBuffer<StoredType> d_buffer;  // in-place 'TYPE' object

  public:
    // CREATORS
    //! Variant_DataImp() = default;
        // Create a 'Variant_DataImp' object that holds an empty buffer.

    // MANIPULATORS
    TYPE& value();
        // Return a reference to the stored 'TYPE' object.  The behavior is
        // undefined unless the enclosing union contains a 'TYPE' object (i.e.,
        // the enclosing 'bsl::variant' has an active alternative of type
        // 'TYPE').

    // ACCESSORS
    const TYPE& value() const;
        // Return a const reference to the stored 'TYPE' object.  The behavior
        // is undefined unless the enclosing union contains a 'TYPE' object
        // (i.e., the enclosing 'bsl::variant' has an active alternative of
        // type 'TYPE').
};

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_variant.h
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT
#define BSLSTL_VARIANT_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT_H
#define BSLSTL_VARIANT_VARIADIC_LIMIT_H BSLSTL_VARIANT_VARIADIC_LIMIT
#endif
template <class HEAD = void,
          class TAIL0 = void
#if BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 0
        , class TAIL_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 1
        , class TAIL_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 2
        , class TAIL_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 3
        , class TAIL_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 4
        , class TAIL_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 5
        , class TAIL_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 6
        , class TAIL_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 7
        , class TAIL_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 8
        , class TAIL_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 9
        , class TAIL_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 9
        , class = BSLS_COMPILERFEATURES_NILT>
union Variant_Union;


template <>
union Variant_Union<void, void> {
};

#if BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 0
template <class HEAD, class TAIL0>
union Variant_Union<HEAD, TAIL0> {

    Variant_DataImp<HEAD>         d_head;
    Variant_Union<TAIL0> d_tail;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 1
template <class HEAD, class TAIL0, class TAIL_01>
union Variant_Union<HEAD, TAIL0, TAIL_01> {

    Variant_DataImp<HEAD>         d_head;
    Variant_Union<TAIL0, TAIL_01> d_tail;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 2
template <class HEAD, class TAIL0, class TAIL_01,
                                   class TAIL_02>
union Variant_Union<HEAD, TAIL0, TAIL_01,
                                 TAIL_02> {

    Variant_DataImp<HEAD>         d_head;
    Variant_Union<TAIL0, TAIL_01,
                         TAIL_02> d_tail;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 3
template <class HEAD, class TAIL0, class TAIL_01,
                                   class TAIL_02,
                                   class TAIL_03>
union Variant_Union<HEAD, TAIL0, TAIL_01,
                                 TAIL_02,
                                 TAIL_03> {

    Variant_DataImp<HEAD>         d_head;
    Variant_Union<TAIL0, TAIL_01,
                         TAIL_02,
                         TAIL_03> d_tail;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 4
template <class HEAD, class TAIL0, class TAIL_01,
                                   class TAIL_02,
                                   class TAIL_03,
                                   class TAIL_04>
union Variant_Union<HEAD, TAIL0, TAIL_01,
                                 TAIL_02,
                                 TAIL_03,
                                 TAIL_04> {

    Variant_DataImp<HEAD>         d_head;
    Variant_Union<TAIL0, TAIL_01,
                         TAIL_02,
                         TAIL_03,
                         TAIL_04> d_tail;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 5
template <class HEAD, class TAIL0, class TAIL_01,
                                   class TAIL_02,
                                   class TAIL_03,
                                   class TAIL_04,
                                   class TAIL_05>
union Variant_Union<HEAD, TAIL0, TAIL_01,
                                 TAIL_02,
                                 TAIL_03,
                                 TAIL_04,
                                 TAIL_05> {

    Variant_DataImp<HEAD>         d_head;
    Variant_Union<TAIL0, TAIL_01,
                         TAIL_02,
                         TAIL_03,
                         TAIL_04,
                         TAIL_05> d_tail;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 6
template <class HEAD, class TAIL0, class TAIL_01,
                                   class TAIL_02,
                                   class TAIL_03,
                                   class TAIL_04,
                                   class TAIL_05,
                                   class TAIL_06>
union Variant_Union<HEAD, TAIL0, TAIL_01,
                                 TAIL_02,
                                 TAIL_03,
                                 TAIL_04,
                                 TAIL_05,
                                 TAIL_06> {

    Variant_DataImp<HEAD>         d_head;
    Variant_Union<TAIL0, TAIL_01,
                         TAIL_02,
                         TAIL_03,
                         TAIL_04,
                         TAIL_05,
                         TAIL_06> d_tail;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 7
template <class HEAD, class TAIL0, class TAIL_01,
                                   class TAIL_02,
                                   class TAIL_03,
                                   class TAIL_04,
                                   class TAIL_05,
                                   class TAIL_06,
                                   class TAIL_07>
union Variant_Union<HEAD, TAIL0, TAIL_01,
                                 TAIL_02,
                                 TAIL_03,
                                 TAIL_04,
                                 TAIL_05,
                                 TAIL_06,
                                 TAIL_07> {

    Variant_DataImp<HEAD>         d_head;
    Variant_Union<TAIL0, TAIL_01,
                         TAIL_02,
                         TAIL_03,
                         TAIL_04,
                         TAIL_05,
                         TAIL_06,
                         TAIL_07> d_tail;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 8
template <class HEAD, class TAIL0, class TAIL_01,
                                   class TAIL_02,
                                   class TAIL_03,
                                   class TAIL_04,
                                   class TAIL_05,
                                   class TAIL_06,
                                   class TAIL_07,
                                   class TAIL_08>
union Variant_Union<HEAD, TAIL0, TAIL_01,
                                 TAIL_02,
                                 TAIL_03,
                                 TAIL_04,
                                 TAIL_05,
                                 TAIL_06,
                                 TAIL_07,
                                 TAIL_08> {

    Variant_DataImp<HEAD>         d_head;
    Variant_Union<TAIL0, TAIL_01,
                         TAIL_02,
                         TAIL_03,
                         TAIL_04,
                         TAIL_05,
                         TAIL_06,
                         TAIL_07,
                         TAIL_08> d_tail;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 9
template <class HEAD, class TAIL0, class TAIL_01,
                                   class TAIL_02,
                                   class TAIL_03,
                                   class TAIL_04,
                                   class TAIL_05,
                                   class TAIL_06,
                                   class TAIL_07,
                                   class TAIL_08,
                                   class TAIL_09>
union Variant_Union<HEAD, TAIL0, TAIL_01,
                                 TAIL_02,
                                 TAIL_03,
                                 TAIL_04,
                                 TAIL_05,
                                 TAIL_06,
                                 TAIL_07,
                                 TAIL_08,
                                 TAIL_09> {

    Variant_DataImp<HEAD>         d_head;
    Variant_Union<TAIL0, TAIL_01,
                         TAIL_02,
                         TAIL_03,
                         TAIL_04,
                         TAIL_05,
                         TAIL_06,
                         TAIL_07,
                         TAIL_08,
                         TAIL_09> d_tail;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 10
template <class HEAD, class TAIL0, class TAIL_01,
                                   class TAIL_02,
                                   class TAIL_03,
                                   class TAIL_04,
                                   class TAIL_05,
                                   class TAIL_06,
                                   class TAIL_07,
                                   class TAIL_08,
                                   class TAIL_09,
                                   class TAIL_10>
union Variant_Union<HEAD, TAIL0, TAIL_01,
                                 TAIL_02,
                                 TAIL_03,
                                 TAIL_04,
                                 TAIL_05,
                                 TAIL_06,
                                 TAIL_07,
                                 TAIL_08,
                                 TAIL_09,
                                 TAIL_10> {

    Variant_DataImp<HEAD>         d_head;
    Variant_Union<TAIL0, TAIL_01,
                         TAIL_02,
                         TAIL_03,
                         TAIL_04,
                         TAIL_05,
                         TAIL_06,
                         TAIL_07,
                         TAIL_08,
                         TAIL_09,
                         TAIL_10> d_tail;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_H >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class HEAD = void, class TAIL0 = void, class... TAIL>
union Variant_Union;

template <>
union Variant_Union<void, void> {
};

template <class HEAD, class TAIL0, class... TAIL>
union Variant_Union<HEAD, TAIL0, TAIL...> {

    Variant_DataImp<HEAD>         d_head;
    Variant_Union<TAIL0, TAIL...> d_tail;
};
// }}} END GENERATED CODE
#endif
#endif  // BSL_VARIANT_FULL_IMPLEMENTATION

                     // ==================================
                     // class Variant_CopyConstructVisitor
                     // ==================================

template <class VARIANT_BASE>
class Variant_CopyConstructVisitor {
    // This component-private class is a visitor that is used to implement the
    // copy constructor for 'bsl::variant'.

  private:
    // DATA
    VARIANT_BASE *d_variant_p;

  public:
    // CREATORS
    explicit Variant_CopyConstructVisitor(VARIANT_BASE *variant)
        // Create a 'Variant_CopyConstructVisitor' object that, when invoked,
        // will copy-construct an alternative in the specified 'variant'.
    : d_variant_p(variant)
    {
        BSLS_ASSERT_SAFE(d_variant_p);
    }

    // ACCESSORS
    template <size_t INDEX, class TYPE>
    void operator()(bsl::in_place_index_t<INDEX>, const TYPE& other) const
        // Copy-construct the alternative at index (template parameter) 'INDEX'
        // from the specified 'other' (i.e. the alternative that is being
        // visited).  Note that the allocator specified on construction of
        // '*d_variant_p' will be used.
    {
        d_variant_p->template baseEmplace<INDEX>(other);
    }
};

                     // ==================================
                     // class Variant_MoveConstructVisitor
                     // ==================================

template <class VARIANT_BASE>
class Variant_MoveConstructVisitor {
    // This component-private class is a visitor that is used to implement the
    // move constructor for 'bsl::variant'.

  private:
    // PRIVATE TYPES
    typedef BloombergLP::bslmf::MovableRefUtil MoveUtil;

    // DATA
    VARIANT_BASE *d_variant_p;

  public:
    // CREATORS
    explicit Variant_MoveConstructVisitor(VARIANT_BASE *variant)
        // Create a 'Variant_MoveConstructVisitor' object that, when invoked,
        // will move-construct an alternative in the specified 'variant'.
    : d_variant_p(variant)
    {
        BSLS_ASSERT_SAFE(d_variant_p);
    }

    // ACCESSORS
    template <size_t INDEX, class TYPE>
    void operator()(bsl::in_place_index_t<INDEX>, TYPE& other) const
        // Move-construct the alternative at index (template parameter) 'INDEX'
        // from the specified 'other' (i.e. the alternative that is being
        // visited).  Note that the allocator specified on construction of
        // '*d_variant_p' will be used.
    {
        d_variant_p->template baseEmplace<INDEX>(MoveUtil::move(other));
    }
};

                      // ===============================
                      // class Variant_CopyAssignVisitor
                      // ===============================

template <class VARIANT>
class Variant_CopyAssignVisitor {
    // This component-private class is a visitor that is used to implement the
    // copy assignment operator for 'bsl::variant'.

  private:
    // DATA
    VARIANT *d_variant_p;

  public:
    // CREATORS
    explicit Variant_CopyAssignVisitor(VARIANT *variant)
        // Create a 'Variant_CopyAssignVisitor' object that, when invoked, will
        // copy-assign to the active alternative of the specified 'variant'.
    : d_variant_p(variant)
    {
        BSLS_ASSERT_SAFE(d_variant_p);
    }


  public:
    // ACCESSORS
    template <size_t INDEX, class TYPE>
    void operator()(bsl::in_place_index_t<INDEX>, const TYPE& value) const
        // Copy-assign to the active alternative of '*d_variant_p' from the
        // specified 'value' (i.e. the alternative that is being visited).  The
        // behavior is undefined unless (template parameter) 'INDEX' is the
        // index of the active alternative of '*d_variant_p' (or, in C++03, the
        // index of an alternative that has the same type as the active
        // alternative).
    {
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
        bsl::get<INDEX>(*d_variant_p) = value;
#else
        // When invoking this visitor in C++03, 'INDEX' may not be the index of
        // the active alternative, but it will be an index of an alternative of
        // same type.  However, because 'TYPE' is deduced, it may be missing
        // cv-qualifications.  'ALT_TYPE' will give the correct
        // cv-qualification.
        typedef
            typename bsl::variant_alternative<INDEX, VARIANT>::type ALT_TYPE;
        Variant_UnsafeGet<ALT_TYPE>(*d_variant_p) = value;
#endif  // BSL_VARIANT_FULL_IMPLEMENTATION
    }
};

                      // ===============================
                      // class Variant_MoveAssignVisitor
                      // ===============================

template <class VARIANT>
class Variant_MoveAssignVisitor {
    // This component-private class is a visitor that is used to implement the
    // move assignment operator for 'bsl::variant'.

  private:
    // PRIVATE TYPES
    typedef BloombergLP::bslmf::MovableRefUtil MoveUtil;

    // DATA
    VARIANT *d_variant_p;

  public:
    // CREATORS
    explicit Variant_MoveAssignVisitor(VARIANT *variant)
        // Create a 'Variant_MoveAssignVisitor' object that, when invoked, will
        // move-assign to the active alternative of the specified 'variant'.
    : d_variant_p(variant)
    {
        BSLS_ASSERT_SAFE(d_variant_p);
    }

  public:
    // ACCESSORS
    template <size_t INDEX, class TYPE>
    void operator()(bsl::in_place_index_t<INDEX>, TYPE& value) const
        // Move-assign to the active alternative of '*d_variant_p' from the
        // specified 'value' (i.e. the alternative that is being visited).  The
        // behavior is undefined unless (template parameter) 'INDEX' is the
        // index of the active alternative of '*d_variant_p' (or, in C++03, the
        // index of an alternative that has the same type as the active
        // alternative).
    {
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
        bsl::get<INDEX>(*d_variant_p) = MoveUtil::move(value);
#else
        Variant_UnsafeGet<TYPE>(*d_variant_p)     = MoveUtil::move(value);
#endif  // BSL_VARIANT_FULL_IMPLEMENTATION
    }
};

                      // ================================
                      // struct Variant_DestructorVisitor
                      // ================================

struct Variant_DestructorVisitor {
    // This component-private struct is a visitor that destroys the active
    // alternative of the visited 'variant' object.

  public:
    // ACCESSORS
    template <class TYPE>
    void operator()(TYPE& object) const
        // Destroy the specified 'object', which is the alternative that is
        // being visited.
    {
        bslma::DestructionUtil::destroy(&object);
    }
};
                       // ==============================
                       // struct Variant_##NAME##Visitor
                       // ==============================

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
#define BSLSTL_VARIANT_RELOP_VISITOR_DEFINITON(NAME, OP)                      \
    template <class VARIANT>                                                  \
    struct Variant_##NAME##Visitor {                                          \
        /*  When using this visitor, construct the visitor using the left  */ \
        /*  operand, and call visitation on the right operand.             */ \
        explicit Variant_##NAME##Visitor(const VARIANT *variant)              \
        : d_variant_p(variant)                                                \
        {                                                                     \
            BSLS_ASSERT_SAFE(d_variant_p);                                    \
        }                                                                     \
                                                                              \
      private:                                                                \
        const VARIANT *d_variant_p;                                           \
                                                                              \
      public:                                                                 \
        template <size_t INDEX, class TYPE>                                   \
        bool operator()(bsl::in_place_index_t<INDEX>,                         \
                        const TYPE&                  value) const             \
        {                                                                     \
            return (bsl::get<INDEX>(*d_variant_p) OP value);                  \
        }                                                                     \
    };                                                                        \
                                                                              \
    template <class VARIANT>                                                  \
    bool Variant_ImpUtil<VARIANT>::NAME##Impl(const VARIANT& lhs,             \
                                              const VARIANT& rhs)             \
    {                                                                         \
        BSLS_ASSERT(lhs.index() == rhs.index() &&                             \
                    !lhs.valueless_by_exception());                           \
                                                                              \
        Variant_##NAME##Visitor<VARIANT> NAME##Visitor(                       \
                                                   BSLS_UTIL_ADDRESSOF(lhs)); \
        return BSLSTL_VARIANT_VISITID(bool, NAME##Visitor, rhs);              \
    }
#else
#define BSLSTL_VARIANT_RELOP_VISITOR_DEFINITON(NAME, OP)                      \
    template <class VARIANT>                                                  \
    struct Variant_##NAME##Visitor {                                          \
        Variant_##NAME##Visitor(const VARIANT *variant)                       \
        : d_variant_p(variant)                                                \
        {                                                                     \
            BSLS_ASSERT_SAFE(d_variant_p);                                    \
        }                                                                     \
                                                                              \
      private:                                                                \
        const VARIANT *d_variant_p;                                           \
                                                                              \
      public:                                                                 \
        template <size_t INDEX, class TYPE>                                   \
        bool operator()(bsl::in_place_index_t<INDEX>,                         \
                        TYPE&                  value) const                   \
        {                                                                     \
            /* When invoking this visitor in C++03, 'INDEX' may not be the */ \
            /* index of the active alternative, but it will be an index of */ \
            /* an alternative of same type.  However, because 'TYPE' is    */ \
            /* deduced, it may have incorrect cv-qualifications.           */ \
            /* 'ALT_TYPE' will give the correct cv-qualification.          */ \
            typedef typename bsl::variant_alternative<INDEX, VARIANT>::type   \
                                                                    ALT_TYPE; \
            return (Variant_UnsafeGet<ALT_TYPE>(*d_variant_p) OP value);      \
        }                                                                     \
    };                                                                        \
                                                                              \
    template <class VARIANT>                                                  \
    bool Variant_ImpUtil<VARIANT>::NAME##Impl(const VARIANT& lhs,             \
                                              const VARIANT& rhs)             \
    {                                                                         \
        BSLS_ASSERT(lhs.index() == rhs.index() &&                             \
                    !lhs.valueless_by_exception());                           \
                                                                              \
        Variant_##NAME##Visitor<VARIANT> NAME##Visitor(                       \
                                                   BSLS_UTIL_ADDRESSOF(lhs)); \
        return BSLSTL_VARIANT_VISITID(bool, NAME##Visitor, rhs);              \
    }
#endif  // BSL_VARIANT_FULL_IMPLEMENTATION
    // This macro is used to define the 'Variant_ImpUtil::*Impl' methods.

BSLSTL_VARIANT_RELOP_VISITOR_DEFINITON(Equal, ==)
BSLSTL_VARIANT_RELOP_VISITOR_DEFINITON(NotEqual, !=)
BSLSTL_VARIANT_RELOP_VISITOR_DEFINITON(LessThan, <)
BSLSTL_VARIANT_RELOP_VISITOR_DEFINITON(GreaterThan, >)
BSLSTL_VARIANT_RELOP_VISITOR_DEFINITON(LessOrEqual, <=)
BSLSTL_VARIANT_RELOP_VISITOR_DEFINITON(GreaterOrEqual, >=)

                         // =========================
                         // class Variant_SwapVisitor
                         // =========================

template <class VARIANT>
class Variant_SwapVisitor {
    // This component-private class is a visitor that is used to implement
    // 'bsl::variant::swap'.

  private:
    // DATA
    VARIANT *d_variant_p;

  public:
    // CREATORS
    explicit Variant_SwapVisitor(VARIANT *variant)
        // Create a 'Variant_SwapVisitor' object that, when invoked, will swap
        // the visited alternative with the active alternative of the specified
        // 'variant'.
    : d_variant_p(variant)
    {
        BSLS_ASSERT_SAFE(d_variant_p);
    }

    // ACCESSORS
    template <size_t INDEX, class TYPE>
    void operator()(bsl::in_place_index_t<INDEX>, TYPE& value) const
        // Swap the alternative having index (template parameter) 'INDEX' in
        // '*d_variant_p' with the specified 'value' (i.e. the alternative that
        // is being visited).  The behavior is undefined unless 'INDEX' is the
        // index of the active alternative of '*d_variant_p' (or, in C++03, the
        // index of an alternative that has the same type as the active
        // alternative).
    {
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
        BloombergLP::bslalg::SwapUtil::swap(
                           BSLS_UTIL_ADDRESSOF(value),
                           BSLS_UTIL_ADDRESSOF(bsl::get<INDEX>(*d_variant_p)));
#else
        // When invoking this visitor in C++03, 'INDEX' may not be the index of
        // the active alternative, but it will be an index of an alternative of
        // same type. Swap can not be invoked on a constant variant, so the cv
        // qualifications will match.
        BloombergLP::bslalg::SwapUtil::swap(
                 BSLS_UTIL_ADDRESSOF(value),
                 BSLS_UTIL_ADDRESSOF((Variant_UnsafeGet<TYPE>(*d_variant_p))));
#endif  // BSL_VARIANT_FULL_IMPLEMENTATION
    }
};

                         // =========================
                         // class Variant_HashVisitor
                         // =========================

template <class HASHALG>
class Variant_HashVisitor {
    // This component-private class is a visitor that is used to implement
    // 'hashAppend' for 'bsl::variant'.

  private:
    // DATA
    HASHALG& d_hashAlg;

  public:
    // CREATORS
    explicit Variant_HashVisitor(HASHALG& hashAlg)
        // Create a 'Variant_HashVisitor' object that, when invoked, appends to
        // the specified 'hashAlg'.
    : d_hashAlg(hashAlg)
    {
    }

    // ACCESSORS
    template <class TYPE>
    void operator()(TYPE& value) const
        // Append the specified 'value' (i.e., the alternative that is being
        // visited) to 'd_hashAlg'.
    {
        using BloombergLP::bslh::hashAppend;
        hashAppend(d_hashAlg, value);
    }
};

template <bool AA>
struct Variant_AllocatorBase {
    // This component-private struct keeps track of the allocator for a
    // 'bsl::variant' object.  The primary template is used when the 'variant'
    // is not allocator-aware (because it has no allocator-aware alternatives).

    // ACCESSORS
    BloombergLP::bslma::Allocator *mechanism() const
        // Return a null pointer.  Note that this method has the same return
        // type as the allocator-aware version so that the remainder of the
        // implementation of 'bsl::variant' is abstracted with respect to
        // whether or not the specialization is allocator-aware; this is why
        // both methods return 'bslma::Allocator*' instead of
        // 'bsl::allocator<char>'.  The returned pointer will be ignored (and
        // not dereferenced) when passed to
        // 'bslma::ConstructionUtil::construct'.
    {
        return NULL;
    }
};

template <>
struct Variant_AllocatorBase<true> {
    // This specialization is used when the 'variant' is allocator-aware.

    // TYPES
    typedef BloombergLP::bslmf::MovableRefUtil MoveUtil;
    typedef bsl::allocator<char>               allocator_type;

    // PUBLIC DATA
    allocator_type d_allocator;

    // CREATORS
    Variant_AllocatorBase() {}
        // Create a 'Variant_AllocatorBase' object that holds the currently
        // installed default allocator.

    Variant_AllocatorBase(const Variant_AllocatorBase& original)
        // Create a 'Variant_AllocatorBase' object that holds a copy of the
        // allocator held by the specified 'original'.
    : d_allocator(original.d_allocator)
    {
    }

    Variant_AllocatorBase(allocator_type allocator)
        // Create a 'Variant_AllocatorBase' object that holds a copy of the
        // specified 'allocator'.
    : d_allocator(allocator)
    {
    }

    // ACCESSORS
    BloombergLP::bslma::Allocator *mechanism() const
        // Return the mechanism of the stored allocator.
    {
        return d_allocator.mechanism();
    }
};

                            // ===================
                            // struct variant_base
                            // ===================

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_variant.h
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT
#define BSLSTL_VARIANT_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT_I
#define BSLSTL_VARIANT_VARIADIC_LIMIT_I BSLSTL_VARIANT_VARIADIC_LIMIT
#endif
template <class HEAD
#if BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 0
        , class TAIL_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 1
        , class TAIL_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 2
        , class TAIL_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 3
        , class TAIL_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 4
        , class TAIL_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 5
        , class TAIL_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 6
        , class TAIL_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 7
        , class TAIL_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 8
        , class TAIL_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 9
        , class TAIL_9 = BSLS_COMPILERFEATURES_NILT
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 9
        , class = BSLS_COMPILERFEATURES_NILT>
struct Variant_Base;

#if BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 0
template <class HEAD>
struct Variant_Base<HEAD>
: public BloombergLP::bslstl::Variant_AllocatorBase<
      BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD>::value> {

    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_AllocatorBase<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD>::value>
                                                              AllocBase;
    typedef BloombergLP::bslstl::Variant_Union<HEAD> Variant_Union;
    typedef bsl::variant<HEAD>                       Variant;

    struct NoAlloc {
    };

    typedef typename bsl::conditional<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD>::value,
        bsl::allocator<char>,
        NoAlloc>::type allocator_type;

    size_t d_type;

    Variant_Union d_union;

    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD>::value));

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    Variant_Base();

    Variant_Base(const Variant_Base& original);

    Variant_Base(Variant_Base&& original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 const Variant& original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 Variant&&      original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>);

#else

    Variant_Base();

    Variant_Base(const Variant& original);

    Variant_Base(BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>, const ARG& arg);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 const Variant&                          original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          const ARG&     arg);

#endif

    ~Variant_Base();

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <size_t INDEX>
    void baseEmplace();
#else
    template <size_t INDEX>
    void baseEmplace();

    template <size_t INDEX, class ARG>
    void baseEmplace(const ARG& arg);
#endif

    Variant_Base& operator=(const Variant_Base& rhs);

    Variant_Base& operator=(BloombergLP::bslmf::MovableRef<Variant_Base> rhs);

    void reset() BSLS_KEYWORD_NOEXCEPT;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 1
template <class HEAD, class TAIL_01>
struct Variant_Base<HEAD, TAIL_01>
: public BloombergLP::bslstl::Variant_AllocatorBase<
      BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                         TAIL_01>::value> {

    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_AllocatorBase<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                           TAIL_01>::value>
                                                              AllocBase;
    typedef BloombergLP::bslstl::Variant_Union<HEAD, TAIL_01> Variant_Union;
    typedef bsl::variant<HEAD, TAIL_01>                       Variant;

    struct NoAlloc {
    };

    typedef typename bsl::conditional<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                           TAIL_01>::value,
        bsl::allocator<char>,
        NoAlloc>::type allocator_type;

    size_t d_type;

    Variant_Union d_union;

    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD,
                                                           TAIL_01>::value));

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    Variant_Base();

    Variant_Base(const Variant_Base& original);

    Variant_Base(Variant_Base&& original);

    template <size_t INDEX, class ARGS_01>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 const Variant& original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 Variant&&      original);

    template <size_t INDEX, class ARGS_01>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01);

#else

    Variant_Base();

    Variant_Base(const Variant& original);

    Variant_Base(BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>, const ARG& arg);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 const Variant&                          original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          const ARG&     arg);

#endif

    ~Variant_Base();

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <size_t INDEX, class ARGS_01>
    void baseEmplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01));
#else
    template <size_t INDEX>
    void baseEmplace();

    template <size_t INDEX, class ARG>
    void baseEmplace(const ARG& arg);
#endif

    Variant_Base& operator=(const Variant_Base& rhs);

    Variant_Base& operator=(BloombergLP::bslmf::MovableRef<Variant_Base> rhs);

    void reset() BSLS_KEYWORD_NOEXCEPT;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
struct Variant_Base<HEAD, TAIL_01,
                          TAIL_02>
: public BloombergLP::bslstl::Variant_AllocatorBase<
      BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                         TAIL_01,
                                                         TAIL_02>::value> {

    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_AllocatorBase<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                           TAIL_01,
                                                           TAIL_02>::value>
                                                              AllocBase;
    typedef BloombergLP::bslstl::Variant_Union<HEAD, TAIL_01,
                                                     TAIL_02> Variant_Union;
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02>                       Variant;

    struct NoAlloc {
    };

    typedef typename bsl::conditional<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                           TAIL_01,
                                                           TAIL_02>::value,
        bsl::allocator<char>,
        NoAlloc>::type allocator_type;

    size_t d_type;

    Variant_Union d_union;

    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02>::value));

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    Variant_Base();

    Variant_Base(const Variant_Base& original);

    Variant_Base(Variant_Base&& original);

    template <size_t INDEX, class ARGS_01,
                            class ARGS_02>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 const Variant& original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 Variant&&      original);

    template <size_t INDEX, class ARGS_01,
                            class ARGS_02>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02);

#else

    Variant_Base();

    Variant_Base(const Variant& original);

    Variant_Base(BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>, const ARG& arg);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 const Variant&                          original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          const ARG&     arg);

#endif

    ~Variant_Base();

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <size_t INDEX, class ARGS_01,
                            class ARGS_02>
    void baseEmplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02));
#else
    template <size_t INDEX>
    void baseEmplace();

    template <size_t INDEX, class ARG>
    void baseEmplace(const ARG& arg);
#endif

    Variant_Base& operator=(const Variant_Base& rhs);

    Variant_Base& operator=(BloombergLP::bslmf::MovableRef<Variant_Base> rhs);

    void reset() BSLS_KEYWORD_NOEXCEPT;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
struct Variant_Base<HEAD, TAIL_01,
                          TAIL_02,
                          TAIL_03>
: public BloombergLP::bslstl::Variant_AllocatorBase<
      BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                         TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03>::value> {

    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_AllocatorBase<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03>::value>
                                                              AllocBase;
    typedef BloombergLP::bslstl::Variant_Union<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03> Variant_Union;
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03>                       Variant;

    struct NoAlloc {
    };

    typedef typename bsl::conditional<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03>::value,
        bsl::allocator<char>,
        NoAlloc>::type allocator_type;

    size_t d_type;

    Variant_Union d_union;

    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03>::value));

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    Variant_Base();

    Variant_Base(const Variant_Base& original);

    Variant_Base(Variant_Base&& original);

    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 const Variant& original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 Variant&&      original);

    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03);

#else

    Variant_Base();

    Variant_Base(const Variant& original);

    Variant_Base(BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>, const ARG& arg);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 const Variant&                          original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          const ARG&     arg);

#endif

    ~Variant_Base();

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03>
    void baseEmplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03));
#else
    template <size_t INDEX>
    void baseEmplace();

    template <size_t INDEX, class ARG>
    void baseEmplace(const ARG& arg);
#endif

    Variant_Base& operator=(const Variant_Base& rhs);

    Variant_Base& operator=(BloombergLP::bslmf::MovableRef<Variant_Base> rhs);

    void reset() BSLS_KEYWORD_NOEXCEPT;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
struct Variant_Base<HEAD, TAIL_01,
                          TAIL_02,
                          TAIL_03,
                          TAIL_04>
: public BloombergLP::bslstl::Variant_AllocatorBase<
      BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                         TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03,
                                                         TAIL_04>::value> {

    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_AllocatorBase<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04>::value>
                                                              AllocBase;
    typedef BloombergLP::bslstl::Variant_Union<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04> Variant_Union;
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04>                       Variant;

    struct NoAlloc {
    };

    typedef typename bsl::conditional<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04>::value,
        bsl::allocator<char>,
        NoAlloc>::type allocator_type;

    size_t d_type;

    Variant_Union d_union;

    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04>::value));

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    Variant_Base();

    Variant_Base(const Variant_Base& original);

    Variant_Base(Variant_Base&& original);

    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03,
                            class ARGS_04>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 const Variant& original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 Variant&&      original);

    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03,
                            class ARGS_04>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04);

#else

    Variant_Base();

    Variant_Base(const Variant& original);

    Variant_Base(BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>, const ARG& arg);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 const Variant&                          original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          const ARG&     arg);

#endif

    ~Variant_Base();

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03,
                            class ARGS_04>
    void baseEmplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04));
#else
    template <size_t INDEX>
    void baseEmplace();

    template <size_t INDEX, class ARG>
    void baseEmplace(const ARG& arg);
#endif

    Variant_Base& operator=(const Variant_Base& rhs);

    Variant_Base& operator=(BloombergLP::bslmf::MovableRef<Variant_Base> rhs);

    void reset() BSLS_KEYWORD_NOEXCEPT;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
struct Variant_Base<HEAD, TAIL_01,
                          TAIL_02,
                          TAIL_03,
                          TAIL_04,
                          TAIL_05>
: public BloombergLP::bslstl::Variant_AllocatorBase<
      BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                         TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03,
                                                         TAIL_04,
                                                         TAIL_05>::value> {

    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_AllocatorBase<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05>::value>
                                                              AllocBase;
    typedef BloombergLP::bslstl::Variant_Union<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05> Variant_Union;
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05>                       Variant;

    struct NoAlloc {
    };

    typedef typename bsl::conditional<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05>::value,
        bsl::allocator<char>,
        NoAlloc>::type allocator_type;

    size_t d_type;

    Variant_Union d_union;

    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05>::value));

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    Variant_Base();

    Variant_Base(const Variant_Base& original);

    Variant_Base(Variant_Base&& original);

    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03,
                            class ARGS_04,
                            class ARGS_05>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 const Variant& original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 Variant&&      original);

    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03,
                            class ARGS_04,
                            class ARGS_05>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05);

#else

    Variant_Base();

    Variant_Base(const Variant& original);

    Variant_Base(BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>, const ARG& arg);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 const Variant&                          original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          const ARG&     arg);

#endif

    ~Variant_Base();

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03,
                            class ARGS_04,
                            class ARGS_05>
    void baseEmplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05));
#else
    template <size_t INDEX>
    void baseEmplace();

    template <size_t INDEX, class ARG>
    void baseEmplace(const ARG& arg);
#endif

    Variant_Base& operator=(const Variant_Base& rhs);

    Variant_Base& operator=(BloombergLP::bslmf::MovableRef<Variant_Base> rhs);

    void reset() BSLS_KEYWORD_NOEXCEPT;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
struct Variant_Base<HEAD, TAIL_01,
                          TAIL_02,
                          TAIL_03,
                          TAIL_04,
                          TAIL_05,
                          TAIL_06>
: public BloombergLP::bslstl::Variant_AllocatorBase<
      BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                         TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03,
                                                         TAIL_04,
                                                         TAIL_05,
                                                         TAIL_06>::value> {

    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_AllocatorBase<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06>::value>
                                                              AllocBase;
    typedef BloombergLP::bslstl::Variant_Union<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06> Variant_Union;
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06>                       Variant;

    struct NoAlloc {
    };

    typedef typename bsl::conditional<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06>::value,
        bsl::allocator<char>,
        NoAlloc>::type allocator_type;

    size_t d_type;

    Variant_Union d_union;

    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06>::value));

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    Variant_Base();

    Variant_Base(const Variant_Base& original);

    Variant_Base(Variant_Base&& original);

    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03,
                            class ARGS_04,
                            class ARGS_05,
                            class ARGS_06>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 const Variant& original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 Variant&&      original);

    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03,
                            class ARGS_04,
                            class ARGS_05,
                            class ARGS_06>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06);

#else

    Variant_Base();

    Variant_Base(const Variant& original);

    Variant_Base(BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>, const ARG& arg);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 const Variant&                          original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          const ARG&     arg);

#endif

    ~Variant_Base();

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03,
                            class ARGS_04,
                            class ARGS_05,
                            class ARGS_06>
    void baseEmplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06));
#else
    template <size_t INDEX>
    void baseEmplace();

    template <size_t INDEX, class ARG>
    void baseEmplace(const ARG& arg);
#endif

    Variant_Base& operator=(const Variant_Base& rhs);

    Variant_Base& operator=(BloombergLP::bslmf::MovableRef<Variant_Base> rhs);

    void reset() BSLS_KEYWORD_NOEXCEPT;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
struct Variant_Base<HEAD, TAIL_01,
                          TAIL_02,
                          TAIL_03,
                          TAIL_04,
                          TAIL_05,
                          TAIL_06,
                          TAIL_07>
: public BloombergLP::bslstl::Variant_AllocatorBase<
      BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                         TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03,
                                                         TAIL_04,
                                                         TAIL_05,
                                                         TAIL_06,
                                                         TAIL_07>::value> {

    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_AllocatorBase<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07>::value>
                                                              AllocBase;
    typedef BloombergLP::bslstl::Variant_Union<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07> Variant_Union;
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06,
                               TAIL_07>                       Variant;

    struct NoAlloc {
    };

    typedef typename bsl::conditional<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07>::value,
        bsl::allocator<char>,
        NoAlloc>::type allocator_type;

    size_t d_type;

    Variant_Union d_union;

    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07>::value));

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    Variant_Base();

    Variant_Base(const Variant_Base& original);

    Variant_Base(Variant_Base&& original);

    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03,
                            class ARGS_04,
                            class ARGS_05,
                            class ARGS_06,
                            class ARGS_07>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 const Variant& original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 Variant&&      original);

    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03,
                            class ARGS_04,
                            class ARGS_05,
                            class ARGS_06,
                            class ARGS_07>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07);

#else

    Variant_Base();

    Variant_Base(const Variant& original);

    Variant_Base(BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>, const ARG& arg);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 const Variant&                          original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          const ARG&     arg);

#endif

    ~Variant_Base();

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03,
                            class ARGS_04,
                            class ARGS_05,
                            class ARGS_06,
                            class ARGS_07>
    void baseEmplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07));
#else
    template <size_t INDEX>
    void baseEmplace();

    template <size_t INDEX, class ARG>
    void baseEmplace(const ARG& arg);
#endif

    Variant_Base& operator=(const Variant_Base& rhs);

    Variant_Base& operator=(BloombergLP::bslmf::MovableRef<Variant_Base> rhs);

    void reset() BSLS_KEYWORD_NOEXCEPT;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
struct Variant_Base<HEAD, TAIL_01,
                          TAIL_02,
                          TAIL_03,
                          TAIL_04,
                          TAIL_05,
                          TAIL_06,
                          TAIL_07,
                          TAIL_08>
: public BloombergLP::bslstl::Variant_AllocatorBase<
      BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                         TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03,
                                                         TAIL_04,
                                                         TAIL_05,
                                                         TAIL_06,
                                                         TAIL_07,
                                                         TAIL_08>::value> {

    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_AllocatorBase<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08>::value>
                                                              AllocBase;
    typedef BloombergLP::bslstl::Variant_Union<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07,
                                                     TAIL_08> Variant_Union;
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06,
                               TAIL_07,
                               TAIL_08>                       Variant;

    struct NoAlloc {
    };

    typedef typename bsl::conditional<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08>::value,
        bsl::allocator<char>,
        NoAlloc>::type allocator_type;

    size_t d_type;

    Variant_Union d_union;

    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08>::value));

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    Variant_Base();

    Variant_Base(const Variant_Base& original);

    Variant_Base(Variant_Base&& original);

    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03,
                            class ARGS_04,
                            class ARGS_05,
                            class ARGS_06,
                            class ARGS_07,
                            class ARGS_08>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 const Variant& original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 Variant&&      original);

    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03,
                            class ARGS_04,
                            class ARGS_05,
                            class ARGS_06,
                            class ARGS_07,
                            class ARGS_08>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08);

#else

    Variant_Base();

    Variant_Base(const Variant& original);

    Variant_Base(BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>, const ARG& arg);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 const Variant&                          original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          const ARG&     arg);

#endif

    ~Variant_Base();

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03,
                            class ARGS_04,
                            class ARGS_05,
                            class ARGS_06,
                            class ARGS_07,
                            class ARGS_08>
    void baseEmplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08));
#else
    template <size_t INDEX>
    void baseEmplace();

    template <size_t INDEX, class ARG>
    void baseEmplace(const ARG& arg);
#endif

    Variant_Base& operator=(const Variant_Base& rhs);

    Variant_Base& operator=(BloombergLP::bslmf::MovableRef<Variant_Base> rhs);

    void reset() BSLS_KEYWORD_NOEXCEPT;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
struct Variant_Base<HEAD, TAIL_01,
                          TAIL_02,
                          TAIL_03,
                          TAIL_04,
                          TAIL_05,
                          TAIL_06,
                          TAIL_07,
                          TAIL_08,
                          TAIL_09>
: public BloombergLP::bslstl::Variant_AllocatorBase<
      BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                         TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03,
                                                         TAIL_04,
                                                         TAIL_05,
                                                         TAIL_06,
                                                         TAIL_07,
                                                         TAIL_08,
                                                         TAIL_09>::value> {

    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_AllocatorBase<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08,
                                                           TAIL_09>::value>
                                                              AllocBase;
    typedef BloombergLP::bslstl::Variant_Union<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07,
                                                     TAIL_08,
                                                     TAIL_09> Variant_Union;
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06,
                               TAIL_07,
                               TAIL_08,
                               TAIL_09>                       Variant;

    struct NoAlloc {
    };

    typedef typename bsl::conditional<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08,
                                                           TAIL_09>::value,
        bsl::allocator<char>,
        NoAlloc>::type allocator_type;

    size_t d_type;

    Variant_Union d_union;

    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08,
                                                            TAIL_09>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08,
                                                            TAIL_09>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08,
                                                           TAIL_09>::value));

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    Variant_Base();

    Variant_Base(const Variant_Base& original);

    Variant_Base(Variant_Base&& original);

    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03,
                            class ARGS_04,
                            class ARGS_05,
                            class ARGS_06,
                            class ARGS_07,
                            class ARGS_08,
                            class ARGS_09>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 const Variant& original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 Variant&&      original);

    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03,
                            class ARGS_04,
                            class ARGS_05,
                            class ARGS_06,
                            class ARGS_07,
                            class ARGS_08,
                            class ARGS_09>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09);

#else

    Variant_Base();

    Variant_Base(const Variant& original);

    Variant_Base(BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>, const ARG& arg);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 const Variant&                          original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          const ARG&     arg);

#endif

    ~Variant_Base();

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03,
                            class ARGS_04,
                            class ARGS_05,
                            class ARGS_06,
                            class ARGS_07,
                            class ARGS_08,
                            class ARGS_09>
    void baseEmplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09));
#else
    template <size_t INDEX>
    void baseEmplace();

    template <size_t INDEX, class ARG>
    void baseEmplace(const ARG& arg);
#endif

    Variant_Base& operator=(const Variant_Base& rhs);

    Variant_Base& operator=(BloombergLP::bslmf::MovableRef<Variant_Base> rhs);

    void reset() BSLS_KEYWORD_NOEXCEPT;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
struct Variant_Base<HEAD, TAIL_01,
                          TAIL_02,
                          TAIL_03,
                          TAIL_04,
                          TAIL_05,
                          TAIL_06,
                          TAIL_07,
                          TAIL_08,
                          TAIL_09,
                          TAIL_10>
: public BloombergLP::bslstl::Variant_AllocatorBase<
      BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                         TAIL_01,
                                                         TAIL_02,
                                                         TAIL_03,
                                                         TAIL_04,
                                                         TAIL_05,
                                                         TAIL_06,
                                                         TAIL_07,
                                                         TAIL_08,
                                                         TAIL_09,
                                                         TAIL_10>::value> {

    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_AllocatorBase<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08,
                                                           TAIL_09,
                                                           TAIL_10>::value>
                                                              AllocBase;
    typedef BloombergLP::bslstl::Variant_Union<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07,
                                                     TAIL_08,
                                                     TAIL_09,
                                                     TAIL_10> Variant_Union;
    typedef bsl::variant<HEAD, TAIL_01,
                               TAIL_02,
                               TAIL_03,
                               TAIL_04,
                               TAIL_05,
                               TAIL_06,
                               TAIL_07,
                               TAIL_08,
                               TAIL_09,
                               TAIL_10>                       Variant;

    struct NoAlloc {
    };

    typedef typename bsl::conditional<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08,
                                                           TAIL_09,
                                                           TAIL_10>::value,
        bsl::allocator<char>,
        NoAlloc>::type allocator_type;

    size_t d_type;

    Variant_Union d_union;

    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08,
                                                            TAIL_09,
                                                            TAIL_10>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08,
                                                            TAIL_09,
                                                            TAIL_10>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08,
                                                           TAIL_09,
                                                           TAIL_10>::value));

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    Variant_Base();

    Variant_Base(const Variant_Base& original);

    Variant_Base(Variant_Base&& original);

    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03,
                            class ARGS_04,
                            class ARGS_05,
                            class ARGS_06,
                            class ARGS_07,
                            class ARGS_08,
                            class ARGS_09,
                            class ARGS_10>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 const Variant& original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 Variant&&      original);

    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03,
                            class ARGS_04,
                            class ARGS_05,
                            class ARGS_06,
                            class ARGS_07,
                            class ARGS_08,
                            class ARGS_09,
                            class ARGS_10>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10);

#else

    Variant_Base();

    Variant_Base(const Variant& original);

    Variant_Base(BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>, const ARG& arg);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 const Variant&                          original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          const ARG&     arg);

#endif

    ~Variant_Base();

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <size_t INDEX, class ARGS_01,
                            class ARGS_02,
                            class ARGS_03,
                            class ARGS_04,
                            class ARGS_05,
                            class ARGS_06,
                            class ARGS_07,
                            class ARGS_08,
                            class ARGS_09,
                            class ARGS_10>
    void baseEmplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09),
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10));
#else
    template <size_t INDEX>
    void baseEmplace();

    template <size_t INDEX, class ARG>
    void baseEmplace(const ARG& arg);
#endif

    Variant_Base& operator=(const Variant_Base& rhs);

    Variant_Base& operator=(BloombergLP::bslmf::MovableRef<Variant_Base> rhs);

    void reset() BSLS_KEYWORD_NOEXCEPT;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_I >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class HEAD, class... TAIL>
struct Variant_Base
: public BloombergLP::bslstl::Variant_AllocatorBase<
      BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                         TAIL...>::value> {

    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_AllocatorBase<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                           TAIL...>::value>
                                                              AllocBase;
    typedef BloombergLP::bslstl::Variant_Union<HEAD, TAIL...> Variant_Union;
    typedef bsl::variant<HEAD, TAIL...>                       Variant;

    struct NoAlloc {
    };

    typedef typename bsl::conditional<
        BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                           TAIL...>::value,
        bsl::allocator<char>,
        NoAlloc>::type allocator_type;

    size_t d_type;

    Variant_Union d_union;

    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL...>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL...>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        Variant_Base,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD,
                                                           TAIL...>::value));

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    Variant_Base();

    Variant_Base(const Variant_Base& original);

    Variant_Base(Variant_Base&& original);

    template <size_t INDEX, class... ARGS>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>, ARGS&&... args);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 const Variant& original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type allocator,
                 Variant&&      original);

    template <size_t INDEX, class... ARGS>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          ARGS&&...      args);

#else

    Variant_Base();

    Variant_Base(const Variant& original);

    Variant_Base(BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::in_place_index_t<INDEX>, const ARG& arg);

    Variant_Base(bsl::allocator_arg_t, allocator_type allocator);

    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 const Variant&                          original);
    Variant_Base(bsl::allocator_arg_t,
                 allocator_type                          allocator,
                 BloombergLP::bslmf::MovableRef<Variant> original);

    template <size_t INDEX>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit Variant_Base(bsl::allocator_arg_t,
                          allocator_type allocator,
                          bsl::in_place_index_t<INDEX>,
                          const ARG&     arg);

#endif

    ~Variant_Base();

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <size_t INDEX, class... ARGS>
    void baseEmplace(ARGS&&...);
#else
    template <size_t INDEX>
    void baseEmplace();

    template <size_t INDEX, class ARG>
    void baseEmplace(const ARG& arg);
#endif

    Variant_Base& operator=(const Variant_Base& rhs);

    Variant_Base& operator=(BloombergLP::bslmf::MovableRef<Variant_Base> rhs);

    void reset() BSLS_KEYWORD_NOEXCEPT;
};
// }}} END GENERATED CODE
#endif

}  // close package namespace
}  // close enterprise namespace

namespace bsl {
                               // =============
                               // class variant
                               // =============

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_variant.h
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT
#define BSLSTL_VARIANT_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT_J
#define BSLSTL_VARIANT_VARIADIC_LIMIT_J BSLSTL_VARIANT_VARIADIC_LIMIT
#endif
#if BSLSTL_VARIANT_VARIADIC_LIMIT_J >= 0
template <class HEAD>
class variant<HEAD>
: private BloombergLP::bslstl::Variant_Base<HEAD>
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
,
  private BloombergLP::bslstl::Variant_SMFBase<
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD>::value,
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD>::value &&
          BloombergLP::bslstl::Variant_IsCopyAssignableAll<HEAD>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD>::value &&
          BloombergLP::bslstl::Variant_IsMoveAssignableAll<HEAD>::value>
#endif
{
  private:
    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_Base<HEAD>  Variant_Base;
    typedef BloombergLP::bslstl::Variant_Union<HEAD> Variant_Union;

    friend struct BloombergLP::bslstl::Variant_ImpUtil<variant>;

    friend struct BloombergLP::bslstl::Variant_Base<HEAD>;

  public:
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD>::value));

    typedef typename Variant_Base::allocator_type allocator_type;


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class t_FIRST_ALT = HEAD,
              class             = typename bsl::enable_if_t<
                  std::is_default_constructible<t_FIRST_ALT>::value> >
    variant()
    : Variant_Base()
    {
    }

    variant(const variant& original) = default;

    variant(variant&& original) = default;

    template <class TYPE>
    variant(BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&
                                                                    >::value> >
    explicit variant(bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               il)
    {
    }

    template <size_t   INDEX,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  0u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX)
                                                                    >::value> >
    explicit variant(bsl::in_place_index_t<INDEX>)
    : Variant_Base(bsl::in_place_index_t<INDEX>())
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class  = typename bsl::enable_if_t<
                  (INDEX < 1 +  0u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&
                                                                    >::value> >
    explicit variant(bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il)
    : Variant_Base(bsl::in_place_index_t<INDEX>(),
                   il)
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  std::is_default_constructible<FIRST>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator)
    : Variant_Base(bsl::allocator_arg_t(), allocator)
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsCopyConstructibleAll<FIRST>::value> >
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const variant& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, original)
    {
    }
    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsMoveConstructibleAll<FIRST>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator, variant&& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, std::move(original))
    {
    }

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>)
    : Variant_Base(
          bsl::allocator_arg_t{}
,
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&
                                                                    >::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il)
    : Variant_Base(
          bsl::allocator_arg_t{}
,
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          il)
    {
    }

    template <size_t   INDEX,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  0u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX)
                                                                    >::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>)
    : Variant_Base(bsl::allocator_arg_t{}
,
                   allocator,
                   bsl::in_place_index_t<INDEX>())
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  0u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&
                                                                    >::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il)
    : Variant_Base(bsl::allocator_arg_t{}
,
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   il)
    {
    }

#else

    variant();

    variant(const variant& original);

    variant(BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(const TYPE& value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     const ARG& arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::in_place_index_t<INDEX>, const ARG& arg);

    variant(bsl::allocator_arg_t, allocator_type allocator);

    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            const variant&                          original);
    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const TYPE&    value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     const ARG&     arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     const ARG&     arg);

#endif


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class    TYPE,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE>::value> >
    TYPE& emplace()
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(
                                           );

        return bsl::get<index>(*this);
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&
                                                                    >::value> >
    TYPE& emplace(std::initializer_list<INIT_LIST_TYPE> il)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(il);

        return bsl::get<index>(*this);
    }

    template <size_t   INDEX,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  0u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX)
                                                                    >::value> >
    typename variant_alternative<INDEX, variant<HEAD> >::type&
    emplace()
    {
        Variant_Base::template baseEmplace<INDEX>(
                                           );

        return bsl::get<INDEX>(*this);
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  0u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&
                                                                    >::value> >
    typename variant_alternative<INDEX, variant<HEAD> >::type&
    emplace(std::initializer_list<INIT_LIST_TYPE> il)
    {
        Variant_Base::template baseEmplace<INDEX>(il);

        return bsl::get<INDEX>(*this);
    }

#else

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace();

    template <class TYPE, class ARG>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace(const ARG& arg);

    template <size_t INDEX>
    typename variant_alternative<INDEX, variant<HEAD> >::type&
    emplace();

    template <size_t INDEX, class ARG>
    typename variant_alternative<INDEX, variant<HEAD> >::type&
    emplace(const ARG& arg);
#endif

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    variant& operator=(const variant& rhs) = default;

    variant& operator=(variant&& rhs) = default;

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) value)
    {
        const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

        if (index() == altIndex) {
            bsl::get<altIndex>(*this) = BSLS_COMPILERFEATURES_FORWARD(TYPE,
                                        value);
        }
        else {
            Variant_Base::template baseEmplace<altIndex>(
                BSLS_COMPILERFEATURES_FORWARD(TYPE, value));
        }

        return *this;
    }
#else
    variant& operator=(const variant& rhs);

    variant& operator=(BloombergLP::bslmf::MovableRef<variant> rhs);

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(const TYPE& value);

#endif
    void swap(variant& other);

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <bool USES_BSLMA_ALLOC = BloombergLP::bslstl::
                  Variant_UsesBslmaAllocatorAny<HEAD>::value,
              class = typename bsl::enable_if_t<USES_BSLMA_ALLOC> >
#endif
    allocator_type get_allocator() const BSLS_KEYWORD_NOEXCEPT
    {
        return allocator_type(Variant_Base::AllocBase::mechanism());
    }

    size_t index() const BSLS_KEYWORD_NOEXCEPT;

    bool valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_J >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_J >= 1
template <class HEAD, class TAIL_01>
class variant<HEAD, TAIL_01>
: private BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01>
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
,
  private BloombergLP::bslstl::Variant_SMFBase<
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD,
                                                          TAIL_01>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD,
                                                          TAIL_01>::value,
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD,
                                                          TAIL_01>::value &&
          BloombergLP::bslstl::Variant_IsCopyAssignableAll<HEAD,
                                                           TAIL_01>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD,
                                                          TAIL_01>::value &&
          BloombergLP::bslstl::Variant_IsMoveAssignableAll<HEAD,
                                                           TAIL_01>::value>
#endif
{
  private:
    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01>  Variant_Base;
    typedef BloombergLP::bslstl::Variant_Union<HEAD, TAIL_01> Variant_Union;

    friend struct BloombergLP::bslstl::Variant_ImpUtil<variant>;

    friend struct BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01>;

  public:
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD,
                                                           TAIL_01>::value));

    typedef typename Variant_Base::allocator_type allocator_type;


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class t_FIRST_ALT = HEAD,
              class             = typename bsl::enable_if_t<
                  std::is_default_constructible<t_FIRST_ALT>::value> >
    variant()
    : Variant_Base()
    {
    }

    variant(const variant& original) = default;

    variant(variant&& original) = default;

    template <class TYPE>
    variant(BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class ARGS_01,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01))
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               il,
               BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01))
    {
    }

    template <size_t   INDEX,
              class ARGS_01,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  1u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01>::value> >
    explicit variant(bsl::in_place_index_t<INDEX>,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
    : Variant_Base(bsl::in_place_index_t<INDEX>(),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01))
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class  = typename bsl::enable_if_t<
                  (INDEX < 1 +  1u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01>::value> >
    explicit variant(bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
    : Variant_Base(bsl::in_place_index_t<INDEX>(),
                   il,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01))
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  std::is_default_constructible<FIRST>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator)
    : Variant_Base(bsl::allocator_arg_t(), allocator)
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsCopyConstructibleAll<FIRST, TAIL_01>::value> >
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const variant& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, original)
    {
    }
    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsMoveConstructibleAll<FIRST, TAIL_01>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator, variant&& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, std::move(original))
    {
    }

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class ARGS_01,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
    : Variant_Base(
          bsl::allocator_arg_t{}
,
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          std::forward<ARGS_01>(args_01))
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
    : Variant_Base(
          bsl::allocator_arg_t{}
,
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          il,
          std::forward<ARGS_01>(args_01))
    {
    }

    template <size_t   INDEX,
              class ARGS_01,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  1u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
    : Variant_Base(bsl::allocator_arg_t{}
,
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   std::forward<ARGS_01>(args_01))
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  1u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
    : Variant_Base(bsl::allocator_arg_t{}
,
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   il,
                   std::forward<ARGS_01>(args_01))
    {
    }

#else

    variant();

    variant(const variant& original);

    variant(BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(const TYPE& value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     const ARG& arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::in_place_index_t<INDEX>, const ARG& arg);

    variant(bsl::allocator_arg_t, allocator_type allocator);

    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            const variant&                          original);
    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const TYPE&    value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     const ARG&     arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     const ARG&     arg);

#endif


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class    TYPE,
              class ARGS_01,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01>::value> >
    TYPE& emplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01));

        return bsl::get<index>(*this);
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01>::value> >
    TYPE& emplace(std::initializer_list<INIT_LIST_TYPE> il,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(il,
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01));

        return bsl::get<index>(*this);
    }

    template <size_t   INDEX,
              class ARGS_01,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  1u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01>::value> >
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01> >::type&
    emplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
    {
        Variant_Base::template baseEmplace<INDEX>(
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01));

        return bsl::get<INDEX>(*this);
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  1u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01>::value> >
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01> >::type&
    emplace(std::initializer_list<INIT_LIST_TYPE> il,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01)
    {
        Variant_Base::template baseEmplace<INDEX>(il,
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01));

        return bsl::get<INDEX>(*this);
    }

#else

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace();

    template <class TYPE, class ARG>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace(const ARG& arg);

    template <size_t INDEX>
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01> >::type&
    emplace();

    template <size_t INDEX, class ARG>
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01> >::type&
    emplace(const ARG& arg);
#endif

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    variant& operator=(const variant& rhs) = default;

    variant& operator=(variant&& rhs) = default;

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) value)
    {
        const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

        if (index() == altIndex) {
            bsl::get<altIndex>(*this) = BSLS_COMPILERFEATURES_FORWARD(TYPE,
                                        value);
        }
        else {
            Variant_Base::template baseEmplace<altIndex>(
                BSLS_COMPILERFEATURES_FORWARD(TYPE, value));
        }

        return *this;
    }
#else
    variant& operator=(const variant& rhs);

    variant& operator=(BloombergLP::bslmf::MovableRef<variant> rhs);

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(const TYPE& value);

#endif
    void swap(variant& other);

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <bool USES_BSLMA_ALLOC = BloombergLP::bslstl::
                  Variant_UsesBslmaAllocatorAny<HEAD, TAIL_01>::value,
              class = typename bsl::enable_if_t<USES_BSLMA_ALLOC> >
#endif
    allocator_type get_allocator() const BSLS_KEYWORD_NOEXCEPT
    {
        return allocator_type(Variant_Base::AllocBase::mechanism());
    }

    size_t index() const BSLS_KEYWORD_NOEXCEPT;

    bool valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_J >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_J >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
class variant<HEAD, TAIL_01,
                    TAIL_02>
: private BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                  TAIL_02>
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
,
  private BloombergLP::bslstl::Variant_SMFBase<
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02>::value,
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02>::value &&
          BloombergLP::bslstl::Variant_IsCopyAssignableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02>::value &&
          BloombergLP::bslstl::Variant_IsMoveAssignableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02>::value>
#endif
{
  private:
    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                    TAIL_02>  Variant_Base;
    typedef BloombergLP::bslstl::Variant_Union<HEAD, TAIL_01,
                                                     TAIL_02> Variant_Union;

    friend struct BloombergLP::bslstl::Variant_ImpUtil<variant>;

    friend struct BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                          TAIL_02>;

  public:
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02>::value));

    typedef typename Variant_Base::allocator_type allocator_type;


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class t_FIRST_ALT = HEAD,
              class             = typename bsl::enable_if_t<
                  std::is_default_constructible<t_FIRST_ALT>::value> >
    variant()
    : Variant_Base()
    {
    }

    variant(const variant& original) = default;

    variant(variant&& original) = default;

    template <class TYPE>
    variant(BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02))
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               il,
               BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02))
    {
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  2u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02>::value> >
    explicit variant(bsl::in_place_index_t<INDEX>,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
    : Variant_Base(bsl::in_place_index_t<INDEX>(),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02))
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class  = typename bsl::enable_if_t<
                  (INDEX < 1 +  2u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02>::value> >
    explicit variant(bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
    : Variant_Base(bsl::in_place_index_t<INDEX>(),
                   il,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02))
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  std::is_default_constructible<FIRST>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator)
    : Variant_Base(bsl::allocator_arg_t(), allocator)
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsCopyConstructibleAll<FIRST, TAIL_01,
                                                            TAIL_02>::value> >
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const variant& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, original)
    {
    }
    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsMoveConstructibleAll<FIRST, TAIL_01,
                                                            TAIL_02>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator, variant&& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, std::move(original))
    {
    }

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
    : Variant_Base(
          bsl::allocator_arg_t{}
,
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          std::forward<ARGS_01>(args_01),
          std::forward<ARGS_02>(args_02))
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
    : Variant_Base(
          bsl::allocator_arg_t{}
,
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          il,
          std::forward<ARGS_01>(args_01),
          std::forward<ARGS_02>(args_02))
    {
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  2u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
    : Variant_Base(bsl::allocator_arg_t{}
,
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   std::forward<ARGS_01>(args_01),
                   std::forward<ARGS_02>(args_02))
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  2u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
    : Variant_Base(bsl::allocator_arg_t{}
,
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   il,
                   std::forward<ARGS_01>(args_01),
                   std::forward<ARGS_02>(args_02))
    {
    }

#else

    variant();

    variant(const variant& original);

    variant(BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(const TYPE& value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     const ARG& arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::in_place_index_t<INDEX>, const ARG& arg);

    variant(bsl::allocator_arg_t, allocator_type allocator);

    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            const variant&                          original);
    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const TYPE&    value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     const ARG&     arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     const ARG&     arg);

#endif


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02>::value> >
    TYPE& emplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02));

        return bsl::get<index>(*this);
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02>::value> >
    TYPE& emplace(std::initializer_list<INIT_LIST_TYPE> il,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(il,
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02));

        return bsl::get<index>(*this);
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  2u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02>::value> >
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02> >::type&
    emplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
    {
        Variant_Base::template baseEmplace<INDEX>(
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02));

        return bsl::get<INDEX>(*this);
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  2u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02>::value> >
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02> >::type&
    emplace(std::initializer_list<INIT_LIST_TYPE> il,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02)
    {
        Variant_Base::template baseEmplace<INDEX>(il,
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02));

        return bsl::get<INDEX>(*this);
    }

#else

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace();

    template <class TYPE, class ARG>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace(const ARG& arg);

    template <size_t INDEX>
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02> >::type&
    emplace();

    template <size_t INDEX, class ARG>
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02> >::type&
    emplace(const ARG& arg);
#endif

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    variant& operator=(const variant& rhs) = default;

    variant& operator=(variant&& rhs) = default;

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) value)
    {
        const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

        if (index() == altIndex) {
            bsl::get<altIndex>(*this) = BSLS_COMPILERFEATURES_FORWARD(TYPE,
                                        value);
        }
        else {
            Variant_Base::template baseEmplace<altIndex>(
                BSLS_COMPILERFEATURES_FORWARD(TYPE, value));
        }

        return *this;
    }
#else
    variant& operator=(const variant& rhs);

    variant& operator=(BloombergLP::bslmf::MovableRef<variant> rhs);

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(const TYPE& value);

#endif
    void swap(variant& other);

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <bool USES_BSLMA_ALLOC = BloombergLP::bslstl::
                  Variant_UsesBslmaAllocatorAny<HEAD, TAIL_01,
                                                      TAIL_02>::value,
              class = typename bsl::enable_if_t<USES_BSLMA_ALLOC> >
#endif
    allocator_type get_allocator() const BSLS_KEYWORD_NOEXCEPT
    {
        return allocator_type(Variant_Base::AllocBase::mechanism());
    }

    size_t index() const BSLS_KEYWORD_NOEXCEPT;

    bool valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_J >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_J >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
class variant<HEAD, TAIL_01,
                    TAIL_02,
                    TAIL_03>
: private BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03>
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
,
  private BloombergLP::bslstl::Variant_SMFBase<
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03>::value,
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03>::value &&
          BloombergLP::bslstl::Variant_IsCopyAssignableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03>::value &&
          BloombergLP::bslstl::Variant_IsMoveAssignableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03>::value>
#endif
{
  private:
    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                    TAIL_02,
                                                    TAIL_03>  Variant_Base;
    typedef BloombergLP::bslstl::Variant_Union<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03> Variant_Union;

    friend struct BloombergLP::bslstl::Variant_ImpUtil<variant>;

    friend struct BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03>;

  public:
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03>::value));

    typedef typename Variant_Base::allocator_type allocator_type;


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class t_FIRST_ALT = HEAD,
              class             = typename bsl::enable_if_t<
                  std::is_default_constructible<t_FIRST_ALT>::value> >
    variant()
    : Variant_Base()
    {
    }

    variant(const variant& original) = default;

    variant(variant&& original) = default;

    template <class TYPE>
    variant(BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03))
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               il,
               BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03))
    {
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  3u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03>::value> >
    explicit variant(bsl::in_place_index_t<INDEX>,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
    : Variant_Base(bsl::in_place_index_t<INDEX>(),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03))
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class  = typename bsl::enable_if_t<
                  (INDEX < 1 +  3u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03>::value> >
    explicit variant(bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
    : Variant_Base(bsl::in_place_index_t<INDEX>(),
                   il,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03))
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  std::is_default_constructible<FIRST>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator)
    : Variant_Base(bsl::allocator_arg_t(), allocator)
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsCopyConstructibleAll<FIRST, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03>::value> >
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const variant& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, original)
    {
    }
    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsMoveConstructibleAll<FIRST, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator, variant&& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, std::move(original))
    {
    }

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
    : Variant_Base(
          bsl::allocator_arg_t{}
,
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          std::forward<ARGS_01>(args_01),
          std::forward<ARGS_02>(args_02),
          std::forward<ARGS_03>(args_03))
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
    : Variant_Base(
          bsl::allocator_arg_t{}
,
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          il,
          std::forward<ARGS_01>(args_01),
          std::forward<ARGS_02>(args_02),
          std::forward<ARGS_03>(args_03))
    {
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  3u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
    : Variant_Base(bsl::allocator_arg_t{}
,
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   std::forward<ARGS_01>(args_01),
                   std::forward<ARGS_02>(args_02),
                   std::forward<ARGS_03>(args_03))
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  3u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
    : Variant_Base(bsl::allocator_arg_t{}
,
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   il,
                   std::forward<ARGS_01>(args_01),
                   std::forward<ARGS_02>(args_02),
                   std::forward<ARGS_03>(args_03))
    {
    }

#else

    variant();

    variant(const variant& original);

    variant(BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(const TYPE& value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     const ARG& arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::in_place_index_t<INDEX>, const ARG& arg);

    variant(bsl::allocator_arg_t, allocator_type allocator);

    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            const variant&                          original);
    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const TYPE&    value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     const ARG&     arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     const ARG&     arg);

#endif


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03>::value> >
    TYPE& emplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03));

        return bsl::get<index>(*this);
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03>::value> >
    TYPE& emplace(std::initializer_list<INIT_LIST_TYPE> il,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(il,
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03));

        return bsl::get<index>(*this);
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  3u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03>::value> >
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03> >::type&
    emplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
    {
        Variant_Base::template baseEmplace<INDEX>(
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03));

        return bsl::get<INDEX>(*this);
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  3u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03>::value> >
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03> >::type&
    emplace(std::initializer_list<INIT_LIST_TYPE> il,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03)
    {
        Variant_Base::template baseEmplace<INDEX>(il,
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03));

        return bsl::get<INDEX>(*this);
    }

#else

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace();

    template <class TYPE, class ARG>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace(const ARG& arg);

    template <size_t INDEX>
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03> >::type&
    emplace();

    template <size_t INDEX, class ARG>
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03> >::type&
    emplace(const ARG& arg);
#endif

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    variant& operator=(const variant& rhs) = default;

    variant& operator=(variant&& rhs) = default;

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) value)
    {
        const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

        if (index() == altIndex) {
            bsl::get<altIndex>(*this) = BSLS_COMPILERFEATURES_FORWARD(TYPE,
                                        value);
        }
        else {
            Variant_Base::template baseEmplace<altIndex>(
                BSLS_COMPILERFEATURES_FORWARD(TYPE, value));
        }

        return *this;
    }
#else
    variant& operator=(const variant& rhs);

    variant& operator=(BloombergLP::bslmf::MovableRef<variant> rhs);

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(const TYPE& value);

#endif
    void swap(variant& other);

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <bool USES_BSLMA_ALLOC = BloombergLP::bslstl::
                  Variant_UsesBslmaAllocatorAny<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03>::value,
              class = typename bsl::enable_if_t<USES_BSLMA_ALLOC> >
#endif
    allocator_type get_allocator() const BSLS_KEYWORD_NOEXCEPT
    {
        return allocator_type(Variant_Base::AllocBase::mechanism());
    }

    size_t index() const BSLS_KEYWORD_NOEXCEPT;

    bool valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_J >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_J >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
class variant<HEAD, TAIL_01,
                    TAIL_02,
                    TAIL_03,
                    TAIL_04>
: private BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04>
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
,
  private BloombergLP::bslstl::Variant_SMFBase<
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04>::value,
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04>::value &&
          BloombergLP::bslstl::Variant_IsCopyAssignableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04>::value &&
          BloombergLP::bslstl::Variant_IsMoveAssignableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04>::value>
#endif
{
  private:
    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                    TAIL_02,
                                                    TAIL_03,
                                                    TAIL_04>  Variant_Base;
    typedef BloombergLP::bslstl::Variant_Union<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04> Variant_Union;

    friend struct BloombergLP::bslstl::Variant_ImpUtil<variant>;

    friend struct BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04>;

  public:
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04>::value));

    typedef typename Variant_Base::allocator_type allocator_type;


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class t_FIRST_ALT = HEAD,
              class             = typename bsl::enable_if_t<
                  std::is_default_constructible<t_FIRST_ALT>::value> >
    variant()
    : Variant_Base()
    {
    }

    variant(const variant& original) = default;

    variant(variant&& original) = default;

    template <class TYPE>
    variant(BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04))
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               il,
               BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04))
    {
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  4u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04>::value> >
    explicit variant(bsl::in_place_index_t<INDEX>,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
    : Variant_Base(bsl::in_place_index_t<INDEX>(),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04))
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class  = typename bsl::enable_if_t<
                  (INDEX < 1 +  4u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04>::value> >
    explicit variant(bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
    : Variant_Base(bsl::in_place_index_t<INDEX>(),
                   il,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04))
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  std::is_default_constructible<FIRST>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator)
    : Variant_Base(bsl::allocator_arg_t(), allocator)
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsCopyConstructibleAll<FIRST, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04>::value> >
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const variant& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, original)
    {
    }
    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsMoveConstructibleAll<FIRST, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator, variant&& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, std::move(original))
    {
    }

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
    : Variant_Base(
          bsl::allocator_arg_t{}
,
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          std::forward<ARGS_01>(args_01),
          std::forward<ARGS_02>(args_02),
          std::forward<ARGS_03>(args_03),
          std::forward<ARGS_04>(args_04))
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
    : Variant_Base(
          bsl::allocator_arg_t{}
,
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          il,
          std::forward<ARGS_01>(args_01),
          std::forward<ARGS_02>(args_02),
          std::forward<ARGS_03>(args_03),
          std::forward<ARGS_04>(args_04))
    {
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  4u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
    : Variant_Base(bsl::allocator_arg_t{}
,
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   std::forward<ARGS_01>(args_01),
                   std::forward<ARGS_02>(args_02),
                   std::forward<ARGS_03>(args_03),
                   std::forward<ARGS_04>(args_04))
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  4u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
    : Variant_Base(bsl::allocator_arg_t{}
,
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   il,
                   std::forward<ARGS_01>(args_01),
                   std::forward<ARGS_02>(args_02),
                   std::forward<ARGS_03>(args_03),
                   std::forward<ARGS_04>(args_04))
    {
    }

#else

    variant();

    variant(const variant& original);

    variant(BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(const TYPE& value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     const ARG& arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::in_place_index_t<INDEX>, const ARG& arg);

    variant(bsl::allocator_arg_t, allocator_type allocator);

    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            const variant&                          original);
    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const TYPE&    value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     const ARG&     arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     const ARG&     arg);

#endif


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04>::value> >
    TYPE& emplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04));

        return bsl::get<index>(*this);
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04>::value> >
    TYPE& emplace(std::initializer_list<INIT_LIST_TYPE> il,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(il,
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04));

        return bsl::get<index>(*this);
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  4u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04>::value> >
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04> >::type&
    emplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
    {
        Variant_Base::template baseEmplace<INDEX>(
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04));

        return bsl::get<INDEX>(*this);
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  4u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04>::value> >
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04> >::type&
    emplace(std::initializer_list<INIT_LIST_TYPE> il,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04)
    {
        Variant_Base::template baseEmplace<INDEX>(il,
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04));

        return bsl::get<INDEX>(*this);
    }

#else

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace();

    template <class TYPE, class ARG>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace(const ARG& arg);

    template <size_t INDEX>
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04> >::type&
    emplace();

    template <size_t INDEX, class ARG>
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04> >::type&
    emplace(const ARG& arg);
#endif

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    variant& operator=(const variant& rhs) = default;

    variant& operator=(variant&& rhs) = default;

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) value)
    {
        const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

        if (index() == altIndex) {
            bsl::get<altIndex>(*this) = BSLS_COMPILERFEATURES_FORWARD(TYPE,
                                        value);
        }
        else {
            Variant_Base::template baseEmplace<altIndex>(
                BSLS_COMPILERFEATURES_FORWARD(TYPE, value));
        }

        return *this;
    }
#else
    variant& operator=(const variant& rhs);

    variant& operator=(BloombergLP::bslmf::MovableRef<variant> rhs);

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(const TYPE& value);

#endif
    void swap(variant& other);

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <bool USES_BSLMA_ALLOC = BloombergLP::bslstl::
                  Variant_UsesBslmaAllocatorAny<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04>::value,
              class = typename bsl::enable_if_t<USES_BSLMA_ALLOC> >
#endif
    allocator_type get_allocator() const BSLS_KEYWORD_NOEXCEPT
    {
        return allocator_type(Variant_Base::AllocBase::mechanism());
    }

    size_t index() const BSLS_KEYWORD_NOEXCEPT;

    bool valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_J >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_J >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
class variant<HEAD, TAIL_01,
                    TAIL_02,
                    TAIL_03,
                    TAIL_04,
                    TAIL_05>
: private BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05>
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
,
  private BloombergLP::bslstl::Variant_SMFBase<
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05>::value,
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05>::value &&
          BloombergLP::bslstl::Variant_IsCopyAssignableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05>::value &&
          BloombergLP::bslstl::Variant_IsMoveAssignableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05>::value>
#endif
{
  private:
    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                    TAIL_02,
                                                    TAIL_03,
                                                    TAIL_04,
                                                    TAIL_05>  Variant_Base;
    typedef BloombergLP::bslstl::Variant_Union<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05> Variant_Union;

    friend struct BloombergLP::bslstl::Variant_ImpUtil<variant>;

    friend struct BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05>;

  public:
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05>::value));

    typedef typename Variant_Base::allocator_type allocator_type;


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class t_FIRST_ALT = HEAD,
              class             = typename bsl::enable_if_t<
                  std::is_default_constructible<t_FIRST_ALT>::value> >
    variant()
    : Variant_Base()
    {
    }

    variant(const variant& original) = default;

    variant(variant&& original) = default;

    template <class TYPE>
    variant(BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05))
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               il,
               BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05))
    {
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  5u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05>::value> >
    explicit variant(bsl::in_place_index_t<INDEX>,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
    : Variant_Base(bsl::in_place_index_t<INDEX>(),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05))
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class  = typename bsl::enable_if_t<
                  (INDEX < 1 +  5u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05>::value> >
    explicit variant(bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
    : Variant_Base(bsl::in_place_index_t<INDEX>(),
                   il,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05))
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  std::is_default_constructible<FIRST>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator)
    : Variant_Base(bsl::allocator_arg_t(), allocator)
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsCopyConstructibleAll<FIRST, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05>::value> >
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const variant& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, original)
    {
    }
    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsMoveConstructibleAll<FIRST, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator, variant&& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, std::move(original))
    {
    }

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
    : Variant_Base(
          bsl::allocator_arg_t{}
,
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          std::forward<ARGS_01>(args_01),
          std::forward<ARGS_02>(args_02),
          std::forward<ARGS_03>(args_03),
          std::forward<ARGS_04>(args_04),
          std::forward<ARGS_05>(args_05))
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
    : Variant_Base(
          bsl::allocator_arg_t{}
,
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          il,
          std::forward<ARGS_01>(args_01),
          std::forward<ARGS_02>(args_02),
          std::forward<ARGS_03>(args_03),
          std::forward<ARGS_04>(args_04),
          std::forward<ARGS_05>(args_05))
    {
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  5u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
    : Variant_Base(bsl::allocator_arg_t{}
,
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   std::forward<ARGS_01>(args_01),
                   std::forward<ARGS_02>(args_02),
                   std::forward<ARGS_03>(args_03),
                   std::forward<ARGS_04>(args_04),
                   std::forward<ARGS_05>(args_05))
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  5u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
    : Variant_Base(bsl::allocator_arg_t{}
,
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   il,
                   std::forward<ARGS_01>(args_01),
                   std::forward<ARGS_02>(args_02),
                   std::forward<ARGS_03>(args_03),
                   std::forward<ARGS_04>(args_04),
                   std::forward<ARGS_05>(args_05))
    {
    }

#else

    variant();

    variant(const variant& original);

    variant(BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(const TYPE& value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     const ARG& arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::in_place_index_t<INDEX>, const ARG& arg);

    variant(bsl::allocator_arg_t, allocator_type allocator);

    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            const variant&                          original);
    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const TYPE&    value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     const ARG&     arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     const ARG&     arg);

#endif


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05>::value> >
    TYPE& emplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05));

        return bsl::get<index>(*this);
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05>::value> >
    TYPE& emplace(std::initializer_list<INIT_LIST_TYPE> il,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(il,
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05));

        return bsl::get<index>(*this);
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  5u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05>::value> >
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05> >::type&
    emplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
    {
        Variant_Base::template baseEmplace<INDEX>(
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05));

        return bsl::get<INDEX>(*this);
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  5u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05>::value> >
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05> >::type&
    emplace(std::initializer_list<INIT_LIST_TYPE> il,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05)
    {
        Variant_Base::template baseEmplace<INDEX>(il,
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05));

        return bsl::get<INDEX>(*this);
    }

#else

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace();

    template <class TYPE, class ARG>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace(const ARG& arg);

    template <size_t INDEX>
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05> >::type&
    emplace();

    template <size_t INDEX, class ARG>
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05> >::type&
    emplace(const ARG& arg);
#endif

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    variant& operator=(const variant& rhs) = default;

    variant& operator=(variant&& rhs) = default;

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) value)
    {
        const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

        if (index() == altIndex) {
            bsl::get<altIndex>(*this) = BSLS_COMPILERFEATURES_FORWARD(TYPE,
                                        value);
        }
        else {
            Variant_Base::template baseEmplace<altIndex>(
                BSLS_COMPILERFEATURES_FORWARD(TYPE, value));
        }

        return *this;
    }
#else
    variant& operator=(const variant& rhs);

    variant& operator=(BloombergLP::bslmf::MovableRef<variant> rhs);

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(const TYPE& value);

#endif
    void swap(variant& other);

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <bool USES_BSLMA_ALLOC = BloombergLP::bslstl::
                  Variant_UsesBslmaAllocatorAny<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05>::value,
              class = typename bsl::enable_if_t<USES_BSLMA_ALLOC> >
#endif
    allocator_type get_allocator() const BSLS_KEYWORD_NOEXCEPT
    {
        return allocator_type(Variant_Base::AllocBase::mechanism());
    }

    size_t index() const BSLS_KEYWORD_NOEXCEPT;

    bool valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_J >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_J >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
class variant<HEAD, TAIL_01,
                    TAIL_02,
                    TAIL_03,
                    TAIL_04,
                    TAIL_05,
                    TAIL_06>
: private BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06>
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
,
  private BloombergLP::bslstl::Variant_SMFBase<
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06>::value,
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06>::value &&
          BloombergLP::bslstl::Variant_IsCopyAssignableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06>::value &&
          BloombergLP::bslstl::Variant_IsMoveAssignableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06>::value>
#endif
{
  private:
    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                    TAIL_02,
                                                    TAIL_03,
                                                    TAIL_04,
                                                    TAIL_05,
                                                    TAIL_06>  Variant_Base;
    typedef BloombergLP::bslstl::Variant_Union<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06> Variant_Union;

    friend struct BloombergLP::bslstl::Variant_ImpUtil<variant>;

    friend struct BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06>;

  public:
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06>::value));

    typedef typename Variant_Base::allocator_type allocator_type;


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class t_FIRST_ALT = HEAD,
              class             = typename bsl::enable_if_t<
                  std::is_default_constructible<t_FIRST_ALT>::value> >
    variant()
    : Variant_Base()
    {
    }

    variant(const variant& original) = default;

    variant(variant&& original) = default;

    template <class TYPE>
    variant(BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06))
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               il,
               BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06))
    {
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  6u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06>::value> >
    explicit variant(bsl::in_place_index_t<INDEX>,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
    : Variant_Base(bsl::in_place_index_t<INDEX>(),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06))
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class  = typename bsl::enable_if_t<
                  (INDEX < 1 +  6u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06>::value> >
    explicit variant(bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
    : Variant_Base(bsl::in_place_index_t<INDEX>(),
                   il,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06))
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  std::is_default_constructible<FIRST>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator)
    : Variant_Base(bsl::allocator_arg_t(), allocator)
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsCopyConstructibleAll<FIRST, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06>::value> >
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const variant& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, original)
    {
    }
    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsMoveConstructibleAll<FIRST, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator, variant&& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, std::move(original))
    {
    }

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
    : Variant_Base(
          bsl::allocator_arg_t{}
,
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          std::forward<ARGS_01>(args_01),
          std::forward<ARGS_02>(args_02),
          std::forward<ARGS_03>(args_03),
          std::forward<ARGS_04>(args_04),
          std::forward<ARGS_05>(args_05),
          std::forward<ARGS_06>(args_06))
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
    : Variant_Base(
          bsl::allocator_arg_t{}
,
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          il,
          std::forward<ARGS_01>(args_01),
          std::forward<ARGS_02>(args_02),
          std::forward<ARGS_03>(args_03),
          std::forward<ARGS_04>(args_04),
          std::forward<ARGS_05>(args_05),
          std::forward<ARGS_06>(args_06))
    {
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  6u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
    : Variant_Base(bsl::allocator_arg_t{}
,
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   std::forward<ARGS_01>(args_01),
                   std::forward<ARGS_02>(args_02),
                   std::forward<ARGS_03>(args_03),
                   std::forward<ARGS_04>(args_04),
                   std::forward<ARGS_05>(args_05),
                   std::forward<ARGS_06>(args_06))
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  6u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
    : Variant_Base(bsl::allocator_arg_t{}
,
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   il,
                   std::forward<ARGS_01>(args_01),
                   std::forward<ARGS_02>(args_02),
                   std::forward<ARGS_03>(args_03),
                   std::forward<ARGS_04>(args_04),
                   std::forward<ARGS_05>(args_05),
                   std::forward<ARGS_06>(args_06))
    {
    }

#else

    variant();

    variant(const variant& original);

    variant(BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(const TYPE& value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     const ARG& arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::in_place_index_t<INDEX>, const ARG& arg);

    variant(bsl::allocator_arg_t, allocator_type allocator);

    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            const variant&                          original);
    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const TYPE&    value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     const ARG&     arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     const ARG&     arg);

#endif


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06>::value> >
    TYPE& emplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06));

        return bsl::get<index>(*this);
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06>::value> >
    TYPE& emplace(std::initializer_list<INIT_LIST_TYPE> il,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(il,
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06));

        return bsl::get<index>(*this);
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  6u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06>::value> >
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06> >::type&
    emplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
    {
        Variant_Base::template baseEmplace<INDEX>(
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06));

        return bsl::get<INDEX>(*this);
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  6u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06>::value> >
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06> >::type&
    emplace(std::initializer_list<INIT_LIST_TYPE> il,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06)
    {
        Variant_Base::template baseEmplace<INDEX>(il,
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06));

        return bsl::get<INDEX>(*this);
    }

#else

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace();

    template <class TYPE, class ARG>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace(const ARG& arg);

    template <size_t INDEX>
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06> >::type&
    emplace();

    template <size_t INDEX, class ARG>
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06> >::type&
    emplace(const ARG& arg);
#endif

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    variant& operator=(const variant& rhs) = default;

    variant& operator=(variant&& rhs) = default;

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) value)
    {
        const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

        if (index() == altIndex) {
            bsl::get<altIndex>(*this) = BSLS_COMPILERFEATURES_FORWARD(TYPE,
                                        value);
        }
        else {
            Variant_Base::template baseEmplace<altIndex>(
                BSLS_COMPILERFEATURES_FORWARD(TYPE, value));
        }

        return *this;
    }
#else
    variant& operator=(const variant& rhs);

    variant& operator=(BloombergLP::bslmf::MovableRef<variant> rhs);

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(const TYPE& value);

#endif
    void swap(variant& other);

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <bool USES_BSLMA_ALLOC = BloombergLP::bslstl::
                  Variant_UsesBslmaAllocatorAny<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06>::value,
              class = typename bsl::enable_if_t<USES_BSLMA_ALLOC> >
#endif
    allocator_type get_allocator() const BSLS_KEYWORD_NOEXCEPT
    {
        return allocator_type(Variant_Base::AllocBase::mechanism());
    }

    size_t index() const BSLS_KEYWORD_NOEXCEPT;

    bool valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_J >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_J >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
class variant<HEAD, TAIL_01,
                    TAIL_02,
                    TAIL_03,
                    TAIL_04,
                    TAIL_05,
                    TAIL_06,
                    TAIL_07>
: private BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06,
                                                  TAIL_07>
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
,
  private BloombergLP::bslstl::Variant_SMFBase<
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07>::value,
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07>::value &&
          BloombergLP::bslstl::Variant_IsCopyAssignableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07>::value &&
          BloombergLP::bslstl::Variant_IsMoveAssignableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07>::value>
#endif
{
  private:
    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                    TAIL_02,
                                                    TAIL_03,
                                                    TAIL_04,
                                                    TAIL_05,
                                                    TAIL_06,
                                                    TAIL_07>  Variant_Base;
    typedef BloombergLP::bslstl::Variant_Union<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07> Variant_Union;

    friend struct BloombergLP::bslstl::Variant_ImpUtil<variant>;

    friend struct BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07>;

  public:
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07>::value));

    typedef typename Variant_Base::allocator_type allocator_type;


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class t_FIRST_ALT = HEAD,
              class             = typename bsl::enable_if_t<
                  std::is_default_constructible<t_FIRST_ALT>::value> >
    variant()
    : Variant_Base()
    {
    }

    variant(const variant& original) = default;

    variant(variant&& original) = default;

    template <class TYPE>
    variant(BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07))
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               il,
               BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07))
    {
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  7u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07>::value> >
    explicit variant(bsl::in_place_index_t<INDEX>,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
    : Variant_Base(bsl::in_place_index_t<INDEX>(),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07,
                                         args_07))
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class  = typename bsl::enable_if_t<
                  (INDEX < 1 +  7u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07>::value> >
    explicit variant(bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
    : Variant_Base(bsl::in_place_index_t<INDEX>(),
                   il,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07))
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  std::is_default_constructible<FIRST>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator)
    : Variant_Base(bsl::allocator_arg_t(), allocator)
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsCopyConstructibleAll<FIRST, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07>::value> >
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const variant& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, original)
    {
    }
    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsMoveConstructibleAll<FIRST, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator, variant&& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, std::move(original))
    {
    }

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
    : Variant_Base(
          bsl::allocator_arg_t{}
,
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          std::forward<ARGS_01>(args_01),
          std::forward<ARGS_02>(args_02),
          std::forward<ARGS_03>(args_03),
          std::forward<ARGS_04>(args_04),
          std::forward<ARGS_05>(args_05),
          std::forward<ARGS_06>(args_06),
          std::forward<ARGS_07>(args_07))
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
    : Variant_Base(
          bsl::allocator_arg_t{}
,
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          il,
          std::forward<ARGS_01>(args_01),
          std::forward<ARGS_02>(args_02),
          std::forward<ARGS_03>(args_03),
          std::forward<ARGS_04>(args_04),
          std::forward<ARGS_05>(args_05),
          std::forward<ARGS_06>(args_06),
          std::forward<ARGS_07>(args_07))
    {
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  7u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
    : Variant_Base(bsl::allocator_arg_t{}
,
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   std::forward<ARGS_01>(args_01),
                   std::forward<ARGS_02>(args_02),
                   std::forward<ARGS_03>(args_03),
                   std::forward<ARGS_04>(args_04),
                   std::forward<ARGS_05>(args_05),
                   std::forward<ARGS_06>(args_06),
                   std::forward<ARGS_07>(args_07))
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  7u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
    : Variant_Base(bsl::allocator_arg_t{}
,
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   il,
                   std::forward<ARGS_01>(args_01),
                   std::forward<ARGS_02>(args_02),
                   std::forward<ARGS_03>(args_03),
                   std::forward<ARGS_04>(args_04),
                   std::forward<ARGS_05>(args_05),
                   std::forward<ARGS_06>(args_06),
                   std::forward<ARGS_07>(args_07))
    {
    }

#else

    variant();

    variant(const variant& original);

    variant(BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(const TYPE& value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     const ARG& arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::in_place_index_t<INDEX>, const ARG& arg);

    variant(bsl::allocator_arg_t, allocator_type allocator);

    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            const variant&                          original);
    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const TYPE&    value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     const ARG&     arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     const ARG&     arg);

#endif


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07>::value> >
    TYPE& emplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07,
                                         args_07));

        return bsl::get<index>(*this);
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07>::value> >
    TYPE& emplace(std::initializer_list<INIT_LIST_TYPE> il,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(il,
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07,
                                         args_07));

        return bsl::get<index>(*this);
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  7u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07>::value> >
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07> >::type&
    emplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
    {
        Variant_Base::template baseEmplace<INDEX>(
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07,
                                         args_07));

        return bsl::get<INDEX>(*this);
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  7u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07>::value> >
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07> >::type&
    emplace(std::initializer_list<INIT_LIST_TYPE> il,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07)
    {
        Variant_Base::template baseEmplace<INDEX>(il,
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07,
                                         args_07));

        return bsl::get<INDEX>(*this);
    }

#else

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace();

    template <class TYPE, class ARG>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace(const ARG& arg);

    template <size_t INDEX>
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07> >::type&
    emplace();

    template <size_t INDEX, class ARG>
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07> >::type&
    emplace(const ARG& arg);
#endif

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    variant& operator=(const variant& rhs) = default;

    variant& operator=(variant&& rhs) = default;

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) value)
    {
        const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

        if (index() == altIndex) {
            bsl::get<altIndex>(*this) = BSLS_COMPILERFEATURES_FORWARD(TYPE,
                                        value);
        }
        else {
            Variant_Base::template baseEmplace<altIndex>(
                BSLS_COMPILERFEATURES_FORWARD(TYPE, value));
        }

        return *this;
    }
#else
    variant& operator=(const variant& rhs);

    variant& operator=(BloombergLP::bslmf::MovableRef<variant> rhs);

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(const TYPE& value);

#endif
    void swap(variant& other);

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <bool USES_BSLMA_ALLOC = BloombergLP::bslstl::
                  Variant_UsesBslmaAllocatorAny<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07>::value,
              class = typename bsl::enable_if_t<USES_BSLMA_ALLOC> >
#endif
    allocator_type get_allocator() const BSLS_KEYWORD_NOEXCEPT
    {
        return allocator_type(Variant_Base::AllocBase::mechanism());
    }

    size_t index() const BSLS_KEYWORD_NOEXCEPT;

    bool valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_J >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_J >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
class variant<HEAD, TAIL_01,
                    TAIL_02,
                    TAIL_03,
                    TAIL_04,
                    TAIL_05,
                    TAIL_06,
                    TAIL_07,
                    TAIL_08>
: private BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06,
                                                  TAIL_07,
                                                  TAIL_08>
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
,
  private BloombergLP::bslstl::Variant_SMFBase<
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07,
                                                          TAIL_08>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07,
                                                          TAIL_08>::value,
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07,
                                                          TAIL_08>::value &&
          BloombergLP::bslstl::Variant_IsCopyAssignableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07,
                                                          TAIL_08>::value &&
          BloombergLP::bslstl::Variant_IsMoveAssignableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08>::value>
#endif
{
  private:
    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                    TAIL_02,
                                                    TAIL_03,
                                                    TAIL_04,
                                                    TAIL_05,
                                                    TAIL_06,
                                                    TAIL_07,
                                                    TAIL_08>  Variant_Base;
    typedef BloombergLP::bslstl::Variant_Union<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07,
                                                     TAIL_08> Variant_Union;

    friend struct BloombergLP::bslstl::Variant_ImpUtil<variant>;

    friend struct BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07,
                                                          TAIL_08>;

  public:
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08>::value));

    typedef typename Variant_Base::allocator_type allocator_type;


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class t_FIRST_ALT = HEAD,
              class             = typename bsl::enable_if_t<
                  std::is_default_constructible<t_FIRST_ALT>::value> >
    variant()
    : Variant_Base()
    {
    }

    variant(const variant& original) = default;

    variant(variant&& original) = default;

    template <class TYPE>
    variant(BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08))
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               il,
               BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08))
    {
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  8u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08>::value> >
    explicit variant(bsl::in_place_index_t<INDEX>,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
    : Variant_Base(bsl::in_place_index_t<INDEX>(),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07,
                                         args_07),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08,
                                         args_08))
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class  = typename bsl::enable_if_t<
                  (INDEX < 1 +  8u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08>::value> >
    explicit variant(bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
    : Variant_Base(bsl::in_place_index_t<INDEX>(),
                   il,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08))
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  std::is_default_constructible<FIRST>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator)
    : Variant_Base(bsl::allocator_arg_t(), allocator)
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsCopyConstructibleAll<FIRST, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08>::value> >
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const variant& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, original)
    {
    }
    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsMoveConstructibleAll<FIRST, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator, variant&& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, std::move(original))
    {
    }

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
    : Variant_Base(
          bsl::allocator_arg_t{}
,
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          std::forward<ARGS_01>(args_01),
          std::forward<ARGS_02>(args_02),
          std::forward<ARGS_03>(args_03),
          std::forward<ARGS_04>(args_04),
          std::forward<ARGS_05>(args_05),
          std::forward<ARGS_06>(args_06),
          std::forward<ARGS_07>(args_07),
          std::forward<ARGS_08>(args_08))
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
    : Variant_Base(
          bsl::allocator_arg_t{}
,
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          il,
          std::forward<ARGS_01>(args_01),
          std::forward<ARGS_02>(args_02),
          std::forward<ARGS_03>(args_03),
          std::forward<ARGS_04>(args_04),
          std::forward<ARGS_05>(args_05),
          std::forward<ARGS_06>(args_06),
          std::forward<ARGS_07>(args_07),
          std::forward<ARGS_08>(args_08))
    {
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  8u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
    : Variant_Base(bsl::allocator_arg_t{}
,
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   std::forward<ARGS_01>(args_01),
                   std::forward<ARGS_02>(args_02),
                   std::forward<ARGS_03>(args_03),
                   std::forward<ARGS_04>(args_04),
                   std::forward<ARGS_05>(args_05),
                   std::forward<ARGS_06>(args_06),
                   std::forward<ARGS_07>(args_07),
                   std::forward<ARGS_08>(args_08))
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  8u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
    : Variant_Base(bsl::allocator_arg_t{}
,
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   il,
                   std::forward<ARGS_01>(args_01),
                   std::forward<ARGS_02>(args_02),
                   std::forward<ARGS_03>(args_03),
                   std::forward<ARGS_04>(args_04),
                   std::forward<ARGS_05>(args_05),
                   std::forward<ARGS_06>(args_06),
                   std::forward<ARGS_07>(args_07),
                   std::forward<ARGS_08>(args_08))
    {
    }

#else

    variant();

    variant(const variant& original);

    variant(BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(const TYPE& value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     const ARG& arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::in_place_index_t<INDEX>, const ARG& arg);

    variant(bsl::allocator_arg_t, allocator_type allocator);

    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            const variant&                          original);
    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const TYPE&    value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     const ARG&     arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     const ARG&     arg);

#endif


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08>::value> >
    TYPE& emplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07,
                                         args_07),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08,
                                         args_08));

        return bsl::get<index>(*this);
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08>::value> >
    TYPE& emplace(std::initializer_list<INIT_LIST_TYPE> il,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(il,
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07,
                                         args_07),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08,
                                         args_08));

        return bsl::get<index>(*this);
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  8u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08>::value> >
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08> >::type&
    emplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
    {
        Variant_Base::template baseEmplace<INDEX>(
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07,
                                         args_07),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08,
                                         args_08));

        return bsl::get<INDEX>(*this);
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  8u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08>::value> >
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08> >::type&
    emplace(std::initializer_list<INIT_LIST_TYPE> il,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08)
    {
        Variant_Base::template baseEmplace<INDEX>(il,
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07,
                                         args_07),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08,
                                         args_08));

        return bsl::get<INDEX>(*this);
    }

#else

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace();

    template <class TYPE, class ARG>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace(const ARG& arg);

    template <size_t INDEX>
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08> >::type&
    emplace();

    template <size_t INDEX, class ARG>
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08> >::type&
    emplace(const ARG& arg);
#endif

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    variant& operator=(const variant& rhs) = default;

    variant& operator=(variant&& rhs) = default;

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) value)
    {
        const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

        if (index() == altIndex) {
            bsl::get<altIndex>(*this) = BSLS_COMPILERFEATURES_FORWARD(TYPE,
                                        value);
        }
        else {
            Variant_Base::template baseEmplace<altIndex>(
                BSLS_COMPILERFEATURES_FORWARD(TYPE, value));
        }

        return *this;
    }
#else
    variant& operator=(const variant& rhs);

    variant& operator=(BloombergLP::bslmf::MovableRef<variant> rhs);

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(const TYPE& value);

#endif
    void swap(variant& other);

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <bool USES_BSLMA_ALLOC = BloombergLP::bslstl::
                  Variant_UsesBslmaAllocatorAny<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08>::value,
              class = typename bsl::enable_if_t<USES_BSLMA_ALLOC> >
#endif
    allocator_type get_allocator() const BSLS_KEYWORD_NOEXCEPT
    {
        return allocator_type(Variant_Base::AllocBase::mechanism());
    }

    size_t index() const BSLS_KEYWORD_NOEXCEPT;

    bool valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_J >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_J >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
class variant<HEAD, TAIL_01,
                    TAIL_02,
                    TAIL_03,
                    TAIL_04,
                    TAIL_05,
                    TAIL_06,
                    TAIL_07,
                    TAIL_08,
                    TAIL_09>
: private BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06,
                                                  TAIL_07,
                                                  TAIL_08,
                                                  TAIL_09>
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
,
  private BloombergLP::bslstl::Variant_SMFBase<
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07,
                                                          TAIL_08,
                                                          TAIL_09>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07,
                                                          TAIL_08,
                                                          TAIL_09>::value,
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07,
                                                          TAIL_08,
                                                          TAIL_09>::value &&
          BloombergLP::bslstl::Variant_IsCopyAssignableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08,
                                                           TAIL_09>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07,
                                                          TAIL_08,
                                                          TAIL_09>::value &&
          BloombergLP::bslstl::Variant_IsMoveAssignableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08,
                                                           TAIL_09>::value>
#endif
{
  private:
    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                    TAIL_02,
                                                    TAIL_03,
                                                    TAIL_04,
                                                    TAIL_05,
                                                    TAIL_06,
                                                    TAIL_07,
                                                    TAIL_08,
                                                    TAIL_09>  Variant_Base;
    typedef BloombergLP::bslstl::Variant_Union<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07,
                                                     TAIL_08,
                                                     TAIL_09> Variant_Union;

    friend struct BloombergLP::bslstl::Variant_ImpUtil<variant>;

    friend struct BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07,
                                                          TAIL_08,
                                                          TAIL_09>;

  public:
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08,
                                                            TAIL_09>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08,
                                                            TAIL_09>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08,
                                                           TAIL_09>::value));

    typedef typename Variant_Base::allocator_type allocator_type;


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class t_FIRST_ALT = HEAD,
              class             = typename bsl::enable_if_t<
                  std::is_default_constructible<t_FIRST_ALT>::value> >
    variant()
    : Variant_Base()
    {
    }

    variant(const variant& original) = default;

    variant(variant&& original) = default;

    template <class TYPE>
    variant(BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08,
                                              ARGS_09>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09))
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               il,
               BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09))
    {
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  9u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09>::value> >
    explicit variant(bsl::in_place_index_t<INDEX>,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
    : Variant_Base(bsl::in_place_index_t<INDEX>(),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07,
                                         args_07),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08,
                                         args_08),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_09,
                                         args_09))
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class  = typename bsl::enable_if_t<
                  (INDEX < 1 +  9u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09>::value> >
    explicit variant(bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
    : Variant_Base(bsl::in_place_index_t<INDEX>(),
                   il,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09))
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  std::is_default_constructible<FIRST>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator)
    : Variant_Base(bsl::allocator_arg_t(), allocator)
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsCopyConstructibleAll<FIRST, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08,
                                                            TAIL_09>::value> >
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const variant& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, original)
    {
    }
    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsMoveConstructibleAll<FIRST, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08,
                                                            TAIL_09>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator, variant&& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, std::move(original))
    {
    }

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08,
                                              ARGS_09>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
    : Variant_Base(
          bsl::allocator_arg_t{}
,
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          std::forward<ARGS_01>(args_01),
          std::forward<ARGS_02>(args_02),
          std::forward<ARGS_03>(args_03),
          std::forward<ARGS_04>(args_04),
          std::forward<ARGS_05>(args_05),
          std::forward<ARGS_06>(args_06),
          std::forward<ARGS_07>(args_07),
          std::forward<ARGS_08>(args_08),
          std::forward<ARGS_09>(args_09))
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
    : Variant_Base(
          bsl::allocator_arg_t{}
,
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          il,
          std::forward<ARGS_01>(args_01),
          std::forward<ARGS_02>(args_02),
          std::forward<ARGS_03>(args_03),
          std::forward<ARGS_04>(args_04),
          std::forward<ARGS_05>(args_05),
          std::forward<ARGS_06>(args_06),
          std::forward<ARGS_07>(args_07),
          std::forward<ARGS_08>(args_08),
          std::forward<ARGS_09>(args_09))
    {
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  9u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
    : Variant_Base(bsl::allocator_arg_t{}
,
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   std::forward<ARGS_01>(args_01),
                   std::forward<ARGS_02>(args_02),
                   std::forward<ARGS_03>(args_03),
                   std::forward<ARGS_04>(args_04),
                   std::forward<ARGS_05>(args_05),
                   std::forward<ARGS_06>(args_06),
                   std::forward<ARGS_07>(args_07),
                   std::forward<ARGS_08>(args_08),
                   std::forward<ARGS_09>(args_09))
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  9u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
    : Variant_Base(bsl::allocator_arg_t{}
,
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   il,
                   std::forward<ARGS_01>(args_01),
                   std::forward<ARGS_02>(args_02),
                   std::forward<ARGS_03>(args_03),
                   std::forward<ARGS_04>(args_04),
                   std::forward<ARGS_05>(args_05),
                   std::forward<ARGS_06>(args_06),
                   std::forward<ARGS_07>(args_07),
                   std::forward<ARGS_08>(args_08),
                   std::forward<ARGS_09>(args_09))
    {
    }

#else

    variant();

    variant(const variant& original);

    variant(BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(const TYPE& value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     const ARG& arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::in_place_index_t<INDEX>, const ARG& arg);

    variant(bsl::allocator_arg_t, allocator_type allocator);

    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            const variant&                          original);
    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const TYPE&    value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     const ARG&     arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     const ARG&     arg);

#endif


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08,
                                              ARGS_09>::value> >
    TYPE& emplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07,
                                         args_07),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08,
                                         args_08),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_09,
                                         args_09));

        return bsl::get<index>(*this);
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09>::value> >
    TYPE& emplace(std::initializer_list<INIT_LIST_TYPE> il,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(il,
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07,
                                         args_07),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08,
                                         args_08),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_09,
                                         args_09));

        return bsl::get<index>(*this);
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  9u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09>::value> >
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08,
                                                      TAIL_09> >::type&
    emplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
    {
        Variant_Base::template baseEmplace<INDEX>(
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07,
                                         args_07),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08,
                                         args_08),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_09,
                                         args_09));

        return bsl::get<INDEX>(*this);
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 +  9u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09>::value> >
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08,
                                                      TAIL_09> >::type&
    emplace(std::initializer_list<INIT_LIST_TYPE> il,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09)
    {
        Variant_Base::template baseEmplace<INDEX>(il,
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07,
                                         args_07),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08,
                                         args_08),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_09,
                                         args_09));

        return bsl::get<INDEX>(*this);
    }

#else

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace();

    template <class TYPE, class ARG>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace(const ARG& arg);

    template <size_t INDEX>
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08,
                                                      TAIL_09> >::type&
    emplace();

    template <size_t INDEX, class ARG>
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08,
                                                      TAIL_09> >::type&
    emplace(const ARG& arg);
#endif

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    variant& operator=(const variant& rhs) = default;

    variant& operator=(variant&& rhs) = default;

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) value)
    {
        const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

        if (index() == altIndex) {
            bsl::get<altIndex>(*this) = BSLS_COMPILERFEATURES_FORWARD(TYPE,
                                        value);
        }
        else {
            Variant_Base::template baseEmplace<altIndex>(
                BSLS_COMPILERFEATURES_FORWARD(TYPE, value));
        }

        return *this;
    }
#else
    variant& operator=(const variant& rhs);

    variant& operator=(BloombergLP::bslmf::MovableRef<variant> rhs);

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(const TYPE& value);

#endif
    void swap(variant& other);

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <bool USES_BSLMA_ALLOC = BloombergLP::bslstl::
                  Variant_UsesBslmaAllocatorAny<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08,
                                                      TAIL_09>::value,
              class = typename bsl::enable_if_t<USES_BSLMA_ALLOC> >
#endif
    allocator_type get_allocator() const BSLS_KEYWORD_NOEXCEPT
    {
        return allocator_type(Variant_Base::AllocBase::mechanism());
    }

    size_t index() const BSLS_KEYWORD_NOEXCEPT;

    bool valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_J >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_J >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
class variant<HEAD, TAIL_01,
                    TAIL_02,
                    TAIL_03,
                    TAIL_04,
                    TAIL_05,
                    TAIL_06,
                    TAIL_07,
                    TAIL_08,
                    TAIL_09,
                    TAIL_10>
: private BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06,
                                                  TAIL_07,
                                                  TAIL_08,
                                                  TAIL_09,
                                                  TAIL_10>
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
,
  private BloombergLP::bslstl::Variant_SMFBase<
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07,
                                                          TAIL_08,
                                                          TAIL_09,
                                                          TAIL_10>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07,
                                                          TAIL_08,
                                                          TAIL_09,
                                                          TAIL_10>::value,
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07,
                                                          TAIL_08,
                                                          TAIL_09,
                                                          TAIL_10>::value &&
          BloombergLP::bslstl::Variant_IsCopyAssignableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08,
                                                           TAIL_09,
                                                           TAIL_10>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD,
                                                          TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07,
                                                          TAIL_08,
                                                          TAIL_09,
                                                          TAIL_10>::value &&
          BloombergLP::bslstl::Variant_IsMoveAssignableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08,
                                                           TAIL_09,
                                                           TAIL_10>::value>
#endif
{
  private:
    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                    TAIL_02,
                                                    TAIL_03,
                                                    TAIL_04,
                                                    TAIL_05,
                                                    TAIL_06,
                                                    TAIL_07,
                                                    TAIL_08,
                                                    TAIL_09,
                                                    TAIL_10>  Variant_Base;
    typedef BloombergLP::bslstl::Variant_Union<HEAD, TAIL_01,
                                                     TAIL_02,
                                                     TAIL_03,
                                                     TAIL_04,
                                                     TAIL_05,
                                                     TAIL_06,
                                                     TAIL_07,
                                                     TAIL_08,
                                                     TAIL_09,
                                                     TAIL_10> Variant_Union;

    friend struct BloombergLP::bslstl::Variant_ImpUtil<variant>;

    friend struct BloombergLP::bslstl::Variant_Base<HEAD, TAIL_01,
                                                          TAIL_02,
                                                          TAIL_03,
                                                          TAIL_04,
                                                          TAIL_05,
                                                          TAIL_06,
                                                          TAIL_07,
                                                          TAIL_08,
                                                          TAIL_09,
                                                          TAIL_10>;

  public:
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08,
                                                            TAIL_09,
                                                            TAIL_10>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08,
                                                            TAIL_09,
                                                            TAIL_10>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD,
                                                           TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08,
                                                           TAIL_09,
                                                           TAIL_10>::value));

    typedef typename Variant_Base::allocator_type allocator_type;


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class t_FIRST_ALT = HEAD,
              class             = typename bsl::enable_if_t<
                  std::is_default_constructible<t_FIRST_ALT>::value> >
    variant()
    : Variant_Base()
    {
    }

    variant(const variant& original) = default;

    variant(variant&& original) = default;

    template <class TYPE>
    variant(BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class ARGS_10,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08,
                                              ARGS_09,
                                              ARGS_10>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10))
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class ARGS_10,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               il,
               BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
               BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10))
    {
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class ARGS_10,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 + 10u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10>::value> >
    explicit variant(bsl::in_place_index_t<INDEX>,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
    : Variant_Base(bsl::in_place_index_t<INDEX>(),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07,
                                         args_07),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08,
                                         args_08),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_09,
                                         args_09),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_10,
                                         args_10))
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class ARGS_10,
              class  = typename bsl::enable_if_t<
                  (INDEX < 1 + 10u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10>::value> >
    explicit variant(bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
    : Variant_Base(bsl::in_place_index_t<INDEX>(),
                   il,
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_01, args_01),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_02, args_02),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_03, args_03),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_04, args_04),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_05, args_05),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_06, args_06),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_07, args_07),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_08, args_08),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_09, args_09),
                   BSLS_COMPILERFEATURES_FORWARD(ARGS_10, args_10))
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  std::is_default_constructible<FIRST>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator)
    : Variant_Base(bsl::allocator_arg_t(), allocator)
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsCopyConstructibleAll<FIRST, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08,
                                                            TAIL_09,
                                                            TAIL_10>::value> >
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const variant& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, original)
    {
    }
    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsMoveConstructibleAll<FIRST, TAIL_01,
                                                            TAIL_02,
                                                            TAIL_03,
                                                            TAIL_04,
                                                            TAIL_05,
                                                            TAIL_06,
                                                            TAIL_07,
                                                            TAIL_08,
                                                            TAIL_09,
                                                            TAIL_10>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator, variant&& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, std::move(original))
    {
    }

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class ARGS_10,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08,
                                              ARGS_09,
                                              ARGS_10>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
    : Variant_Base(
          bsl::allocator_arg_t{}
,
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          std::forward<ARGS_01>(args_01),
          std::forward<ARGS_02>(args_02),
          std::forward<ARGS_03>(args_03),
          std::forward<ARGS_04>(args_04),
          std::forward<ARGS_05>(args_05),
          std::forward<ARGS_06>(args_06),
          std::forward<ARGS_07>(args_07),
          std::forward<ARGS_08>(args_08),
          std::forward<ARGS_09>(args_09),
          std::forward<ARGS_10>(args_10))
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class ARGS_10,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
    : Variant_Base(
          bsl::allocator_arg_t{}
,
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          il,
          std::forward<ARGS_01>(args_01),
          std::forward<ARGS_02>(args_02),
          std::forward<ARGS_03>(args_03),
          std::forward<ARGS_04>(args_04),
          std::forward<ARGS_05>(args_05),
          std::forward<ARGS_06>(args_06),
          std::forward<ARGS_07>(args_07),
          std::forward<ARGS_08>(args_08),
          std::forward<ARGS_09>(args_09),
          std::forward<ARGS_10>(args_10))
    {
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class ARGS_10,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 + 10u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
    : Variant_Base(bsl::allocator_arg_t{}
,
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   std::forward<ARGS_01>(args_01),
                   std::forward<ARGS_02>(args_02),
                   std::forward<ARGS_03>(args_03),
                   std::forward<ARGS_04>(args_04),
                   std::forward<ARGS_05>(args_05),
                   std::forward<ARGS_06>(args_06),
                   std::forward<ARGS_07>(args_07),
                   std::forward<ARGS_08>(args_08),
                   std::forward<ARGS_09>(args_09),
                   std::forward<ARGS_10>(args_10))
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class ARGS_10,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 + 10u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                     BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
    : Variant_Base(bsl::allocator_arg_t{}
,
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   il,
                   std::forward<ARGS_01>(args_01),
                   std::forward<ARGS_02>(args_02),
                   std::forward<ARGS_03>(args_03),
                   std::forward<ARGS_04>(args_04),
                   std::forward<ARGS_05>(args_05),
                   std::forward<ARGS_06>(args_06),
                   std::forward<ARGS_07>(args_07),
                   std::forward<ARGS_08>(args_08),
                   std::forward<ARGS_09>(args_09),
                   std::forward<ARGS_10>(args_10))
    {
    }

#else

    variant();

    variant(const variant& original);

    variant(BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(const TYPE& value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     const ARG& arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::in_place_index_t<INDEX>, const ARG& arg);

    variant(bsl::allocator_arg_t, allocator_type allocator);

    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            const variant&                          original);
    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const TYPE&    value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     const ARG&     arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     const ARG&     arg);

#endif


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class    TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class ARGS_10,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08,
                                              ARGS_09,
                                              ARGS_10>::value> >
    TYPE& emplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                  BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07,
                                         args_07),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08,
                                         args_08),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_09,
                                         args_09),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_10,
                                         args_10));

        return bsl::get<index>(*this);
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class ARGS_10,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10>::value> >
    TYPE& emplace(std::initializer_list<INIT_LIST_TYPE> il,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(il,
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07,
                                         args_07),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08,
                                         args_08),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_09,
                                         args_09),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_10,
                                         args_10));

        return bsl::get<index>(*this);
    }

    template <size_t   INDEX,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class ARGS_10,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 + 10u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10>::value> >
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08,
                                                      TAIL_09,
                                                      TAIL_10> >::type&
    emplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
    {
        Variant_Base::template baseEmplace<INDEX>(
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07,
                                         args_07),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08,
                                         args_08),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_09,
                                         args_09),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_10,
                                         args_10));

        return bsl::get<INDEX>(*this);
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class ARGS_01,
              class ARGS_02,
              class ARGS_03,
              class ARGS_04,
              class ARGS_05,
              class ARGS_06,
              class ARGS_07,
              class ARGS_08,
              class ARGS_09,
              class ARGS_10,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 + 10u) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10>::value> >
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08,
                                                      TAIL_09,
                                                      TAIL_10> >::type&
    emplace(std::initializer_list<INIT_LIST_TYPE> il,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_01) args_01,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_02) args_02,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_03) args_03,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_04) args_04,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_05) args_05,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_06) args_06,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_07) args_07,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_08) args_08,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_09) args_09,
                            BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_10) args_10)
    {
        Variant_Base::template baseEmplace<INDEX>(il,
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_01,
                                         args_01),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_02,
                                         args_02),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_03,
                                         args_03),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_04,
                                         args_04),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_05,
                                         args_05),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_06,
                                         args_06),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_07,
                                         args_07),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_08,
                                         args_08),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_09,
                                         args_09),
                                         BSLS_COMPILERFEATURES_FORWARD(ARGS_10,
                                         args_10));

        return bsl::get<INDEX>(*this);
    }

#else

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace();

    template <class TYPE, class ARG>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace(const ARG& arg);

    template <size_t INDEX>
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08,
                                                      TAIL_09,
                                                      TAIL_10> >::type&
    emplace();

    template <size_t INDEX, class ARG>
    typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08,
                                                      TAIL_09,
                                                      TAIL_10> >::type&
    emplace(const ARG& arg);
#endif

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    variant& operator=(const variant& rhs) = default;

    variant& operator=(variant&& rhs) = default;

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(BSLS_COMPILERFEATURES_FORWARD_REF(TYPE) value)
    {
        const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

        if (index() == altIndex) {
            bsl::get<altIndex>(*this) = BSLS_COMPILERFEATURES_FORWARD(TYPE,
                                        value);
        }
        else {
            Variant_Base::template baseEmplace<altIndex>(
                BSLS_COMPILERFEATURES_FORWARD(TYPE, value));
        }

        return *this;
    }
#else
    variant& operator=(const variant& rhs);

    variant& operator=(BloombergLP::bslmf::MovableRef<variant> rhs);

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(const TYPE& value);

#endif
    void swap(variant& other);

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <bool USES_BSLMA_ALLOC = BloombergLP::bslstl::
                  Variant_UsesBslmaAllocatorAny<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08,
                                                      TAIL_09,
                                                      TAIL_10>::value,
              class = typename bsl::enable_if_t<USES_BSLMA_ALLOC> >
#endif
    allocator_type get_allocator() const BSLS_KEYWORD_NOEXCEPT
    {
        return allocator_type(Variant_Base::AllocBase::mechanism());
    }

    size_t index() const BSLS_KEYWORD_NOEXCEPT;

    bool valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT;
};
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_J >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class HEAD, class... TAIL>
class variant
: private BloombergLP::bslstl::Variant_Base<HEAD, TAIL...>
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
,
  private BloombergLP::bslstl::Variant_SMFBase<
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD,
                                                          TAIL...>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD,
                                                          TAIL...>::value,
      BloombergLP::bslstl::Variant_IsCopyConstructibleAll<HEAD,
                                                          TAIL...>::value &&
          BloombergLP::bslstl::Variant_IsCopyAssignableAll<HEAD,
                                                           TAIL...>::value,
      BloombergLP::bslstl::Variant_IsMoveConstructibleAll<HEAD,
                                                          TAIL...>::value &&
          BloombergLP::bslstl::Variant_IsMoveAssignableAll<HEAD,
                                                           TAIL...>::value>
#endif
{
  private:
    typedef BloombergLP::bslmf::MovableRefUtil                MoveUtil;
    typedef BloombergLP::bslstl::Variant_Base<HEAD, TAIL...>  Variant_Base;
    typedef BloombergLP::bslstl::Variant_Union<HEAD, TAIL...> Variant_Union;

    friend struct BloombergLP::bslstl::Variant_ImpUtil<variant>;

    friend struct BloombergLP::bslstl::Variant_Base<HEAD, TAIL...>;

  public:
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslma::UsesBslmaAllocator,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL...>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::UsesAllocatorArgT,
        (BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD,
                                                            TAIL...>::value));
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
        variant,
        BloombergLP::bslmf::IsBitwiseMoveable,
        (BloombergLP::bslstl::Variant_IsBitwiseMoveableAll<HEAD,
                                                           TAIL...>::value));

    typedef typename Variant_Base::allocator_type allocator_type;


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class t_FIRST_ALT = HEAD,
              class             = typename bsl::enable_if_t<
                  std::is_default_constructible<t_FIRST_ALT>::value> >
    variant()
    : Variant_Base()
    {
    }

    variant(const variant& original) = default;

    variant(variant&& original) = default;

    template <class TYPE>
    variant(TYPE&& t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class... ARGS,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS...>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>, ARGS&&... args)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               std::forward<ARGS>(args)...)
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class... ARGS,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS...>::value> >
    explicit variant(bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     ARGS&&...                             args)
    : Variant_Base(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               il,
               std::forward<ARGS>(args)...)
    {
    }

    template <size_t   INDEX,
              class... ARGS,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 + sizeof...(TAIL)) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS...>::value> >
    explicit variant(bsl::in_place_index_t<INDEX>, ARGS&&... args)
    : Variant_Base(bsl::in_place_index_t<INDEX>(), std::forward<ARGS>(args)...)
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class... ARGS,
              class  = typename bsl::enable_if_t<
                  (INDEX < 1 + sizeof...(TAIL)) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS...>::value> >
    explicit variant(bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     ARGS&&...                             args)
    : Variant_Base(bsl::in_place_index_t<INDEX>(),
                   il,
                   std::forward<ARGS>(args)...)
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  std::is_default_constructible<FIRST>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator)
    : Variant_Base(bsl::allocator_arg_t(), allocator)
    {
    }

    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsCopyConstructibleAll<FIRST, TAIL...>::value> >
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const variant& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, original)
    {
    }
    template <class FIRST = HEAD,
              class       = typename bsl::enable_if_t<
                  BloombergLP::bslstl::
                      Variant_IsMoveConstructibleAll<FIRST, TAIL...>::value> >
    variant(bsl::allocator_arg_t, allocator_type allocator, variant&& original)
    : Variant_Base(bsl::allocator_arg_t(), allocator, std::move(original))
    {
    }

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            TYPE&&         t,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class    TYPE,
              class... ARGS,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS...>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     ARGS&&...      args)
    : Variant_Base(
          bsl::allocator_arg_t{},
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          std::forward<ARGS>(args)...)
    {
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class... ARGS,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS...>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_type_t<TYPE>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     ARGS&&...                             args)
    : Variant_Base(
          bsl::allocator_arg_t{},
          allocator,
          bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
          il,
          std::forward<ARGS>(args)...)
    {
    }

    template <size_t   INDEX,
              class... ARGS,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 + sizeof...(TAIL)) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS...>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     ARGS&&...      args)
    : Variant_Base(bsl::allocator_arg_t{},
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   std::forward<ARGS>(args)...)
    {
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class... ARGS,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 + sizeof...(TAIL)) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS...>::value> >
    explicit variant(bsl::allocator_arg_t,
                     allocator_type                        allocator,
                     bsl::in_place_index_t<INDEX>,
                     std::initializer_list<INIT_LIST_TYPE> il,
                     ARGS&&...                             args)
    : Variant_Base(bsl::allocator_arg_t{},
                   allocator,
                   bsl::in_place_index_t<INDEX>(),
                   il,
                   std::forward<ARGS>(args)...)
    {
    }

#else

    variant();

    variant(const variant& original);

    variant(BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(const TYPE& value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::in_place_type_t<TYPE>,
                     const ARG& arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::in_place_index_t<INDEX>, const ARG& arg);

    variant(bsl::allocator_arg_t, allocator_type allocator);

    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            const variant&                          original);
    variant(bsl::allocator_arg_t,
            allocator_type                          allocator,
            BloombergLP::bslmf::MovableRef<variant> original);

    template <class TYPE>
    variant(bsl::allocator_arg_t,
            allocator_type allocator,
            const TYPE&    value,
            BSLSTL_VARIANT_DECLARE_IF_CONSTRUCTS_FROM(variant, TYPE));

    template <class TYPE>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <class TYPE, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_type_t<TYPE>,
                     const ARG&     arg,
                     BSLSTL_VARIANT_DECLARE_IF_HAS_UNIQUE_TYPE(TYPE));

    template <size_t INDEX>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>);

    template <size_t INDEX, class ARG>
    explicit variant(bsl::allocator_arg_t,
                     allocator_type allocator,
                     bsl::in_place_index_t<INDEX>,
                     const ARG&     arg);

#endif


#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <class    TYPE,
              class... ARGS,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE, ARGS...>::value> >
    TYPE& emplace(ARGS&&... args)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(std::forward<ARGS>(args)...);

        return bsl::get<index>(*this);
    }

    template <class    TYPE,
              class    INIT_LIST_TYPE,
              class... ARGS,
              class =  typename bsl::enable_if_t<
                  BSLSTL_VARIANT_HAS_UNIQUE_TYPE(TYPE) &&
                  std::is_constructible<TYPE,
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS...>::value> >
    TYPE& emplace(std::initializer_list<INIT_LIST_TYPE> il, ARGS&&... args)
    {
        const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);
        Variant_Base::template baseEmplace<index>(il,
                                                  std::forward<ARGS>(args)...);

        return bsl::get<index>(*this);
    }

    template <size_t   INDEX,
              class... ARGS,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 + sizeof...(TAIL)) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        ARGS...>::value> >
    typename variant_alternative<INDEX, variant<HEAD, TAIL...> >::type&
    emplace(ARGS&&... args)
    {
        Variant_Base::template baseEmplace<INDEX>(std::forward<ARGS>(args)...);

        return bsl::get<INDEX>(*this);
    }

    template <size_t   INDEX,
              class    INIT_LIST_TYPE,
              class... ARGS,
              class =  typename bsl::enable_if_t<
                  (INDEX < 1 + sizeof...(TAIL)) &&
                  std::is_constructible<BSLSTL_VARIANT_TYPE_AT_INDEX(INDEX),
                                        std::initializer_list<INIT_LIST_TYPE>&,
                                        ARGS...>::value> >
    typename variant_alternative<INDEX, variant<HEAD, TAIL...> >::type&
    emplace(std::initializer_list<INIT_LIST_TYPE> il, ARGS&&... args)
    {
        Variant_Base::template baseEmplace<INDEX>(il,
                                                  std::forward<ARGS>(args)...);

        return bsl::get<INDEX>(*this);
    }

#else

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace();

    template <class TYPE, class ARG>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_HasUniqueType<TYPE, variant>::value,
        TYPE&>::type
    emplace(const ARG& arg);

    template <size_t INDEX>
    typename variant_alternative<INDEX, variant<HEAD, TAIL...> >::type&
    emplace();

    template <size_t INDEX, class ARG>
    typename variant_alternative<INDEX, variant<HEAD, TAIL...> >::type&
    emplace(const ARG& arg);
#endif

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    variant& operator=(const variant& rhs) = default;

    variant& operator=(variant&& rhs) = default;

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(TYPE&& value)
    {
        const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

        if (index() == altIndex) {
            bsl::get<altIndex>(*this) = std::forward<TYPE>(value);
        }
        else {
            Variant_Base::template baseEmplace<altIndex>(
                std::forward<TYPE>(value));
        }

        return *this;
    }
#else
    variant& operator=(const variant& rhs);

    variant& operator=(BloombergLP::bslmf::MovableRef<variant> rhs);

    template <class TYPE>
    typename bsl::enable_if<
        BloombergLP::bslstl::Variant_AssignsFromType<variant, TYPE>::value,
        variant&>::type
    operator=(const TYPE& value);

#endif
    void swap(variant& other);

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
    template <bool USES_BSLMA_ALLOC = BloombergLP::bslstl::
                  Variant_UsesBslmaAllocatorAny<HEAD, TAIL...>::value,
              class = typename bsl::enable_if_t<USES_BSLMA_ALLOC> >
#endif
    allocator_type get_allocator() const BSLS_KEYWORD_NOEXCEPT
    {
        return allocator_type(Variant_Base::AllocBase::mechanism());
    }

    size_t index() const BSLS_KEYWORD_NOEXCEPT;

    bool valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT;
};

// }}} END GENERATED CODE
#endif

}  // close namespace bsl

// ============================================================================
//                           INLINE DEFINITIONS
// ============================================================================

namespace BloombergLP {
namespace bslstl {

                          // ------------------------
                          // class Variant_NoSuchType
                          // ------------------------

// CREATORS
inline
BSLS_KEYWORD_CONSTEXPR Variant_NoSuchType::Variant_NoSuchType(int)
                                                          BSLS_KEYWORD_NOEXCEPT
{
}

                           // ---------------------
                           // class Variant_DataImp
                           // ---------------------

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
// CREATORS
template <class TYPE>
template <class... ARGS>
inline
Variant_DataImp<TYPE>::Variant_DataImp(ARGS&&... args)
{
    BloombergLP::bslma::ConstructionUtil::construct(
        d_buffer.address(), std::forward<ARGS>(args)...);
}
#endif  // BSL_VARIANT_FULL_IMPLEMENTATION

// MANIPULATORS
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
template <class TYPE>
inline
BSLS_KEYWORD_CONSTEXPR_CPP14 TYPE& Variant_DataImp<TYPE>::value() &
{
    return d_buffer.object();
}

template <class TYPE>
inline
BSLS_KEYWORD_CONSTEXPR_CPP14 TYPE&& Variant_DataImp<TYPE>::value() &&
{
    return std::move(d_buffer.object());
}
#else   // BSL_VARIANT_FULL_IMPLEMENTATION
template <class TYPE>
inline
TYPE& Variant_DataImp<TYPE>::value()
{
    return d_buffer.object();
}
#endif  // BSL_VARIANT_FULL_IMPLEMENTATION

// ACCESSORS
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
template <class TYPE>
inline
BSLS_KEYWORD_CONSTEXPR_CPP14 const TYPE& Variant_DataImp<TYPE>::value() const&
{
    return d_buffer.object();
}

template <class TYPE>
inline
BSLS_KEYWORD_CONSTEXPR_CPP14 const TYPE&&
Variant_DataImp<TYPE>::value() const&&
{
    return std::move(d_buffer.object());
}
#else   // BSL_VARIANT_FULL_IMPLEMENTATION
template <class TYPE>
inline
const TYPE& Variant_DataImp<TYPE>::value() const
{
    return d_buffer.object();
}
#endif  // BSL_VARIANT_FULL_IMPLEMENTATION

template <class VARIANT>
void variant_swapImpl(bsl::true_type, VARIANT& lhs, VARIANT& rhs)
    // This component-private function swaps the values of the specified 'lhs'
    // and 'rhs' when the type (template parameter) 'VARIANT' is an
    // allocator-aware variant.
{
    if (lhs.get_allocator() == rhs.get_allocator()) {
        lhs.swap(rhs);
        return;                                                       // RETURN
    }

    VARIANT futureLhs(bsl::allocator_arg, lhs.get_allocator(), rhs);
    VARIANT futureRhs(bsl::allocator_arg, rhs.get_allocator(), lhs);

    futureLhs.swap(lhs);
    futureRhs.swap(rhs);
}

template <class VARIANT>
void variant_swapImpl(bsl::false_type, VARIANT& lhs, VARIANT& rhs)
    // This component-private function swaps the values of the specified 'lhs'
    // and 'rhs' when the type (template parameter) 'VARIANT' is a
    // non-allocator-aware variant.
{
    lhs.swap(rhs);
}

                            // -------------------
                            // struct Variant_Base
                            // -------------------

// CREATORS
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
template <class HEAD, class... TAIL>
inline
Variant_Base<HEAD, TAIL...>::Variant_Base()
: AllocBase()
, d_type(0)
, d_union(bsl::in_place_index_t<0>(), AllocBase::mechanism())
{
}

template <class HEAD, class... TAIL>
inline
Variant_Base<HEAD, TAIL...>::Variant_Base(const Variant_Base& original)
: AllocBase()
, d_type(bsl::variant_npos)
{
    if (original.d_type != bsl::variant_npos) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void,
                               copyConstructor,
                               static_cast<const Variant&>(original));
    }
}

template <class HEAD, class... TAIL>
inline
Variant_Base<HEAD, TAIL...>::Variant_Base(Variant_Base&& original)
: AllocBase(original)
, d_type(bsl::variant_npos)
{
    if (original.d_type != bsl::variant_npos) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void,
                               moveConstructor,
                               static_cast<Variant&>(original));
    }
}

template <class HEAD, class... TAIL>
inline
Variant_Base<HEAD, TAIL...>::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator)
: AllocBase(allocator)
, d_type(0)
, d_union(bsl::in_place_index_t<0>(), AllocBase::mechanism())
{
}

template <class HEAD, class... TAIL>
inline
Variant_Base<HEAD, TAIL...>::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator,
                                          const Variant& original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    if (original.index() != bsl::variant_npos) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);
    }
}

template <class HEAD, class... TAIL>
inline
Variant_Base<HEAD, TAIL...>::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator,
                                          Variant&&      original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    if (original.index() != bsl::variant_npos) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, original);
    }
}

template <class HEAD, class... TAIL>
template <size_t INDEX, class... ARGS>
inline
Variant_Base<HEAD, TAIL...>::Variant_Base(bsl::in_place_index_t<INDEX>,
                                          ARGS&&... args)
: d_type(INDEX)
, d_union(bsl::in_place_index_t<INDEX>(),
          AllocBase::mechanism(),
          std::forward<ARGS>(args)...)
{
}

template <class HEAD, class... TAIL>
template <size_t INDEX, class... ARGS>
inline
Variant_Base<HEAD, TAIL...>::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator,
                                          bsl::in_place_index_t<INDEX>,
                                          ARGS&&...      args)
: AllocBase(allocator)
, d_type(INDEX)
, d_union(bsl::in_place_index_t<INDEX>(),
          AllocBase::mechanism(),
          std::forward<ARGS>(args)...)
{
}
#else  // BSL_VARIANT_FULL_IMPLEMENTATION
#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_variant.h
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT
#define BSLSTL_VARIANT_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT_K
#define BSLSTL_VARIANT_VARIADIC_LIMIT_K BSLSTL_VARIANT_VARIADIC_LIMIT
#endif
#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 0
template <class HEAD>
inline
Variant_Base<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::Variant_Base()
: AllocBase()
, d_type(0)
{
    typedef typename bsl::remove_cv<HEAD>::type ALT_TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                    reinterpret_cast<ALT_TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                    AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 1
template <class HEAD, class TAIL_01>
inline
Variant_Base<HEAD, TAIL_01,
                   BSLS_COMPILERFEATURES_FILLT( 9)>::Variant_Base()
: AllocBase()
, d_type(0)
{
    typedef typename bsl::remove_cv<HEAD>::type ALT_TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                    reinterpret_cast<ALT_TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                    AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   BSLS_COMPILERFEATURES_FILLT( 8)>::Variant_Base()
: AllocBase()
, d_type(0)
{
    typedef typename bsl::remove_cv<HEAD>::type ALT_TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                    reinterpret_cast<ALT_TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                    AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   BSLS_COMPILERFEATURES_FILLT( 7)>::Variant_Base()
: AllocBase()
, d_type(0)
{
    typedef typename bsl::remove_cv<HEAD>::type ALT_TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                    reinterpret_cast<ALT_TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                    AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   BSLS_COMPILERFEATURES_FILLT( 6)>::Variant_Base()
: AllocBase()
, d_type(0)
{
    typedef typename bsl::remove_cv<HEAD>::type ALT_TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                    reinterpret_cast<ALT_TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                    AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   BSLS_COMPILERFEATURES_FILLT( 5)>::Variant_Base()
: AllocBase()
, d_type(0)
{
    typedef typename bsl::remove_cv<HEAD>::type ALT_TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                    reinterpret_cast<ALT_TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                    AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   BSLS_COMPILERFEATURES_FILLT( 4)>::Variant_Base()
: AllocBase()
, d_type(0)
{
    typedef typename bsl::remove_cv<HEAD>::type ALT_TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                    reinterpret_cast<ALT_TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                    AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   BSLS_COMPILERFEATURES_FILLT( 3)>::Variant_Base()
: AllocBase()
, d_type(0)
{
    typedef typename bsl::remove_cv<HEAD>::type ALT_TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                    reinterpret_cast<ALT_TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                    AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   BSLS_COMPILERFEATURES_FILLT( 2)>::Variant_Base()
: AllocBase()
, d_type(0)
{
    typedef typename bsl::remove_cv<HEAD>::type ALT_TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                    reinterpret_cast<ALT_TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                    AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   BSLS_COMPILERFEATURES_FILLT( 1)>::Variant_Base()
: AllocBase()
, d_type(0)
{
    typedef typename bsl::remove_cv<HEAD>::type ALT_TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                    reinterpret_cast<ALT_TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                    AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   TAIL_10,
                   BSLS_COMPILERFEATURES_FILLT( 0)>::Variant_Base()
: AllocBase()
, d_type(0)
{
    typedef typename bsl::remove_cv<HEAD>::type ALT_TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                    reinterpret_cast<ALT_TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                    AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 0
template <class HEAD>
inline
Variant_Base<HEAD, BSLS_COMPILERFEATURES_FILLT(10)
                   >::Variant_Base(const Variant& original)
: AllocBase()
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);
        d_type = original.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 1
template <class HEAD, class TAIL_01>
inline
Variant_Base<HEAD, TAIL_01,
                   BSLS_COMPILERFEATURES_FILLT( 9)
                   >::Variant_Base(const Variant& original)
: AllocBase()
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);
        d_type = original.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   BSLS_COMPILERFEATURES_FILLT( 8)
                   >::Variant_Base(const Variant& original)
: AllocBase()
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);
        d_type = original.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   BSLS_COMPILERFEATURES_FILLT( 7)
                   >::Variant_Base(const Variant& original)
: AllocBase()
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);
        d_type = original.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   BSLS_COMPILERFEATURES_FILLT( 6)
                   >::Variant_Base(const Variant& original)
: AllocBase()
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);
        d_type = original.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   BSLS_COMPILERFEATURES_FILLT( 5)
                   >::Variant_Base(const Variant& original)
: AllocBase()
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);
        d_type = original.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   BSLS_COMPILERFEATURES_FILLT( 4)
                   >::Variant_Base(const Variant& original)
: AllocBase()
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);
        d_type = original.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   BSLS_COMPILERFEATURES_FILLT( 3)
                   >::Variant_Base(const Variant& original)
: AllocBase()
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);
        d_type = original.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   BSLS_COMPILERFEATURES_FILLT( 2)
                   >::Variant_Base(const Variant& original)
: AllocBase()
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);
        d_type = original.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   BSLS_COMPILERFEATURES_FILLT( 1)
                   >::Variant_Base(const Variant& original)
: AllocBase()
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);
        d_type = original.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   TAIL_10,
                   BSLS_COMPILERFEATURES_FILLT( 0)
                   >::Variant_Base(const Variant& original)
: AllocBase()
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);
        d_type = original.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 0
template <class HEAD>
inline
Variant_Base<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::Variant_Base(
                              BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(MoveUtil::access(original))
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);
        d_type = lvalue.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 1
template <class HEAD, class TAIL_01>
inline
Variant_Base<HEAD, TAIL_01,
                   BSLS_COMPILERFEATURES_FILLT( 9)>::Variant_Base(
                              BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(MoveUtil::access(original))
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);
        d_type = lvalue.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   BSLS_COMPILERFEATURES_FILLT( 8)>::Variant_Base(
                              BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(MoveUtil::access(original))
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);
        d_type = lvalue.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   BSLS_COMPILERFEATURES_FILLT( 7)>::Variant_Base(
                              BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(MoveUtil::access(original))
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);
        d_type = lvalue.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   BSLS_COMPILERFEATURES_FILLT( 6)>::Variant_Base(
                              BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(MoveUtil::access(original))
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);
        d_type = lvalue.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   BSLS_COMPILERFEATURES_FILLT( 5)>::Variant_Base(
                              BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(MoveUtil::access(original))
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);
        d_type = lvalue.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   BSLS_COMPILERFEATURES_FILLT( 4)>::Variant_Base(
                              BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(MoveUtil::access(original))
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);
        d_type = lvalue.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   BSLS_COMPILERFEATURES_FILLT( 3)>::Variant_Base(
                              BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(MoveUtil::access(original))
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);
        d_type = lvalue.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   BSLS_COMPILERFEATURES_FILLT( 2)>::Variant_Base(
                              BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(MoveUtil::access(original))
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);
        d_type = lvalue.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   BSLS_COMPILERFEATURES_FILLT( 1)>::Variant_Base(
                              BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(MoveUtil::access(original))
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);
        d_type = lvalue.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   TAIL_10,
                   BSLS_COMPILERFEATURES_FILLT( 0)>::Variant_Base(
                              BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(MoveUtil::access(original))
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);
        d_type = lvalue.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 0
template <class HEAD>
template <size_t INDEX>
inline
Variant_Base<HEAD, BSLS_COMPILERFEATURES_FILLT(10)
                   >::Variant_Base(bsl::in_place_index_t<INDEX>)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 1
template <class HEAD, class TAIL_01>
template <size_t INDEX>
inline
Variant_Base<HEAD, TAIL_01,
                   BSLS_COMPILERFEATURES_FILLT( 9)
                   >::Variant_Base(bsl::in_place_index_t<INDEX>)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
template <size_t INDEX>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   BSLS_COMPILERFEATURES_FILLT( 8)
                   >::Variant_Base(bsl::in_place_index_t<INDEX>)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
template <size_t INDEX>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   BSLS_COMPILERFEATURES_FILLT( 7)
                   >::Variant_Base(bsl::in_place_index_t<INDEX>)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
template <size_t INDEX>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   BSLS_COMPILERFEATURES_FILLT( 6)
                   >::Variant_Base(bsl::in_place_index_t<INDEX>)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
template <size_t INDEX>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   BSLS_COMPILERFEATURES_FILLT( 5)
                   >::Variant_Base(bsl::in_place_index_t<INDEX>)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
template <size_t INDEX>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   BSLS_COMPILERFEATURES_FILLT( 4)
                   >::Variant_Base(bsl::in_place_index_t<INDEX>)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
template <size_t INDEX>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   BSLS_COMPILERFEATURES_FILLT( 3)
                   >::Variant_Base(bsl::in_place_index_t<INDEX>)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
template <size_t INDEX>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   BSLS_COMPILERFEATURES_FILLT( 2)
                   >::Variant_Base(bsl::in_place_index_t<INDEX>)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
template <size_t INDEX>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   BSLS_COMPILERFEATURES_FILLT( 1)
                   >::Variant_Base(bsl::in_place_index_t<INDEX>)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
template <size_t INDEX>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   TAIL_10,
                   BSLS_COMPILERFEATURES_FILLT( 0)
                   >::Variant_Base(bsl::in_place_index_t<INDEX>)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 0
template <class HEAD>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, BSLS_COMPILERFEATURES_FILLT(10)
                   >::Variant_Base(bsl::in_place_index_t<INDEX>,
                                          const ARG& arg)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 1
template <class HEAD, class TAIL_01>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, TAIL_01,
                   BSLS_COMPILERFEATURES_FILLT( 9)
                   >::Variant_Base(bsl::in_place_index_t<INDEX>,
                                          const ARG& arg)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   BSLS_COMPILERFEATURES_FILLT( 8)
                   >::Variant_Base(bsl::in_place_index_t<INDEX>,
                                          const ARG& arg)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   BSLS_COMPILERFEATURES_FILLT( 7)
                   >::Variant_Base(bsl::in_place_index_t<INDEX>,
                                          const ARG& arg)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   BSLS_COMPILERFEATURES_FILLT( 6)
                   >::Variant_Base(bsl::in_place_index_t<INDEX>,
                                          const ARG& arg)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   BSLS_COMPILERFEATURES_FILLT( 5)
                   >::Variant_Base(bsl::in_place_index_t<INDEX>,
                                          const ARG& arg)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   BSLS_COMPILERFEATURES_FILLT( 4)
                   >::Variant_Base(bsl::in_place_index_t<INDEX>,
                                          const ARG& arg)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   BSLS_COMPILERFEATURES_FILLT( 3)
                   >::Variant_Base(bsl::in_place_index_t<INDEX>,
                                          const ARG& arg)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   BSLS_COMPILERFEATURES_FILLT( 2)
                   >::Variant_Base(bsl::in_place_index_t<INDEX>,
                                          const ARG& arg)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   BSLS_COMPILERFEATURES_FILLT( 1)
                   >::Variant_Base(bsl::in_place_index_t<INDEX>,
                                          const ARG& arg)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   TAIL_10,
                   BSLS_COMPILERFEATURES_FILLT( 0)
                   >::Variant_Base(bsl::in_place_index_t<INDEX>,
                                          const ARG& arg)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 0
template <class HEAD>
inline
Variant_Base<HEAD, BSLS_COMPILERFEATURES_FILLT(10)
                   >::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator)
: AllocBase(allocator)
, d_type(0)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<HEAD *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 1
template <class HEAD, class TAIL_01>
inline
Variant_Base<HEAD, TAIL_01,
                   BSLS_COMPILERFEATURES_FILLT( 9)
                   >::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator)
: AllocBase(allocator)
, d_type(0)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<HEAD *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   BSLS_COMPILERFEATURES_FILLT( 8)
                   >::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator)
: AllocBase(allocator)
, d_type(0)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<HEAD *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   BSLS_COMPILERFEATURES_FILLT( 7)
                   >::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator)
: AllocBase(allocator)
, d_type(0)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<HEAD *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   BSLS_COMPILERFEATURES_FILLT( 6)
                   >::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator)
: AllocBase(allocator)
, d_type(0)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<HEAD *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   BSLS_COMPILERFEATURES_FILLT( 5)
                   >::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator)
: AllocBase(allocator)
, d_type(0)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<HEAD *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   BSLS_COMPILERFEATURES_FILLT( 4)
                   >::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator)
: AllocBase(allocator)
, d_type(0)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<HEAD *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   BSLS_COMPILERFEATURES_FILLT( 3)
                   >::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator)
: AllocBase(allocator)
, d_type(0)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<HEAD *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   BSLS_COMPILERFEATURES_FILLT( 2)
                   >::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator)
: AllocBase(allocator)
, d_type(0)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<HEAD *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   BSLS_COMPILERFEATURES_FILLT( 1)
                   >::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator)
: AllocBase(allocator)
, d_type(0)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<HEAD *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   TAIL_10,
                   BSLS_COMPILERFEATURES_FILLT( 0)
                   >::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator)
: AllocBase(allocator)
, d_type(0)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<HEAD *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 0
template <class HEAD>
inline
Variant_Base<HEAD, BSLS_COMPILERFEATURES_FILLT(10)
                   >::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator,
                                          const Variant& original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);

        d_type = original.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 1
template <class HEAD, class TAIL_01>
inline
Variant_Base<HEAD, TAIL_01,
                   BSLS_COMPILERFEATURES_FILLT( 9)
                   >::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator,
                                          const Variant& original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);

        d_type = original.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   BSLS_COMPILERFEATURES_FILLT( 8)
                   >::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator,
                                          const Variant& original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);

        d_type = original.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   BSLS_COMPILERFEATURES_FILLT( 7)
                   >::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator,
                                          const Variant& original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);

        d_type = original.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   BSLS_COMPILERFEATURES_FILLT( 6)
                   >::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator,
                                          const Variant& original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);

        d_type = original.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   BSLS_COMPILERFEATURES_FILLT( 5)
                   >::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator,
                                          const Variant& original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);

        d_type = original.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   BSLS_COMPILERFEATURES_FILLT( 4)
                   >::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator,
                                          const Variant& original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);

        d_type = original.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   BSLS_COMPILERFEATURES_FILLT( 3)
                   >::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator,
                                          const Variant& original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);

        d_type = original.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   BSLS_COMPILERFEATURES_FILLT( 2)
                   >::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator,
                                          const Variant& original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);

        d_type = original.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   BSLS_COMPILERFEATURES_FILLT( 1)
                   >::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator,
                                          const Variant& original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);

        d_type = original.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   TAIL_10,
                   BSLS_COMPILERFEATURES_FILLT( 0)
                   >::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator,
                                          const Variant& original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);

        d_type = original.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 0
template <class HEAD>
inline
Variant_Base<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::Variant_Base(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);

        d_type = lvalue.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 1
template <class HEAD, class TAIL_01>
inline
Variant_Base<HEAD, TAIL_01,
                   BSLS_COMPILERFEATURES_FILLT( 9)>::Variant_Base(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);

        d_type = lvalue.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   BSLS_COMPILERFEATURES_FILLT( 8)>::Variant_Base(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);

        d_type = lvalue.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   BSLS_COMPILERFEATURES_FILLT( 7)>::Variant_Base(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);

        d_type = lvalue.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   BSLS_COMPILERFEATURES_FILLT( 6)>::Variant_Base(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);

        d_type = lvalue.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   BSLS_COMPILERFEATURES_FILLT( 5)>::Variant_Base(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);

        d_type = lvalue.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   BSLS_COMPILERFEATURES_FILLT( 4)>::Variant_Base(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);

        d_type = lvalue.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   BSLS_COMPILERFEATURES_FILLT( 3)>::Variant_Base(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);

        d_type = lvalue.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   BSLS_COMPILERFEATURES_FILLT( 2)>::Variant_Base(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);

        d_type = lvalue.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   BSLS_COMPILERFEATURES_FILLT( 1)>::Variant_Base(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);

        d_type = lvalue.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   TAIL_10,
                   BSLS_COMPILERFEATURES_FILLT( 0)>::Variant_Base(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);

        d_type = lvalue.d_type;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 0
template <class HEAD>
template <size_t INDEX>
inline
Variant_Base<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 1
template <class HEAD, class TAIL_01>
template <size_t INDEX>
inline
Variant_Base<HEAD, TAIL_01,
                   BSLS_COMPILERFEATURES_FILLT( 9)>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
template <size_t INDEX>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   BSLS_COMPILERFEATURES_FILLT( 8)>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
template <size_t INDEX>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   BSLS_COMPILERFEATURES_FILLT( 7)>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
template <size_t INDEX>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   BSLS_COMPILERFEATURES_FILLT( 6)>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
template <size_t INDEX>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   BSLS_COMPILERFEATURES_FILLT( 5)>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
template <size_t INDEX>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   BSLS_COMPILERFEATURES_FILLT( 4)>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
template <size_t INDEX>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   BSLS_COMPILERFEATURES_FILLT( 3)>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
template <size_t INDEX>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   BSLS_COMPILERFEATURES_FILLT( 2)>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
template <size_t INDEX>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   BSLS_COMPILERFEATURES_FILLT( 1)>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
template <size_t INDEX>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   TAIL_10,
                   BSLS_COMPILERFEATURES_FILLT( 0)>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 0
template <class HEAD>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>,
                                        const ARG&     arg)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 1
template <class HEAD, class TAIL_01>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, TAIL_01,
                   BSLS_COMPILERFEATURES_FILLT( 9)>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>,
                                        const ARG&     arg)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   BSLS_COMPILERFEATURES_FILLT( 8)>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>,
                                        const ARG&     arg)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   BSLS_COMPILERFEATURES_FILLT( 7)>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>,
                                        const ARG&     arg)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   BSLS_COMPILERFEATURES_FILLT( 6)>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>,
                                        const ARG&     arg)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   BSLS_COMPILERFEATURES_FILLT( 5)>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>,
                                        const ARG&     arg)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   BSLS_COMPILERFEATURES_FILLT( 4)>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>,
                                        const ARG&     arg)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   BSLS_COMPILERFEATURES_FILLT( 3)>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>,
                                        const ARG&     arg)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   BSLS_COMPILERFEATURES_FILLT( 2)>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>,
                                        const ARG&     arg)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   BSLS_COMPILERFEATURES_FILLT( 1)>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>,
                                        const ARG&     arg)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   TAIL_10,
                   BSLS_COMPILERFEATURES_FILLT( 0)>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>,
                                        const ARG&     arg)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_K >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class HEAD, class... TAIL>
inline
Variant_Base<HEAD, TAIL...>::Variant_Base()
: AllocBase()
, d_type(0)
{
    typedef typename bsl::remove_cv<HEAD>::type ALT_TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                    reinterpret_cast<ALT_TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                    AllocBase::mechanism());
}

template <class HEAD, class... TAIL>
inline
Variant_Base<HEAD, TAIL...>::Variant_Base(const Variant& original)
: AllocBase()
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);
        d_type = original.d_type;
    }
}

template <class HEAD, class... TAIL>
inline
Variant_Base<HEAD, TAIL...>::Variant_Base(
                              BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(MoveUtil::access(original))
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);
        d_type = lvalue.d_type;
    }
}

template <class HEAD, class... TAIL>
template <size_t INDEX>
inline
Variant_Base<HEAD, TAIL...>::Variant_Base(bsl::in_place_index_t<INDEX>)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}

template <class HEAD, class... TAIL>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, TAIL...>::Variant_Base(bsl::in_place_index_t<INDEX>,
                                          const ARG& arg)
: AllocBase()
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}

template <class HEAD, class... TAIL>
inline
Variant_Base<HEAD, TAIL...>::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator)
: AllocBase(allocator)
, d_type(0)
{
    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<HEAD *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}

template <class HEAD, class... TAIL>
inline
Variant_Base<HEAD, TAIL...>::Variant_Base(bsl::allocator_arg_t,
                                          allocator_type allocator,
                                          const Variant& original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    if (!original.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
            copyConstructor(this);
        BSLSTL_VARIANT_VISITID(void, copyConstructor, original);

        d_type = original.d_type;
    }
}

template <class HEAD, class... TAIL>
inline
Variant_Base<HEAD, TAIL...>::Variant_Base(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<Variant> original)
: AllocBase(allocator)
, d_type(bsl::variant_npos)
{
    Variant& lvalue = original;
    if (!lvalue.valueless_by_exception()) {
        BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
            moveConstructor(this);
        BSLSTL_VARIANT_VISITID(void, moveConstructor, lvalue);

        d_type = lvalue.d_type;
    }
}

template <class HEAD, class... TAIL>
template <size_t INDEX>
inline
Variant_Base<HEAD, TAIL...>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism());
}

template <class HEAD, class... TAIL>
template <size_t INDEX, class ARG>
inline
Variant_Base<HEAD, TAIL...>::Variant_Base(
                                        bsl::allocator_arg_t,
                                        allocator_type allocator,
                                        bsl::in_place_index_t<INDEX>,
                                        const ARG&     arg)
: AllocBase(allocator)
, d_type(INDEX)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    BloombergLP::bslma::ConstructionUtil::construct(
                        reinterpret_cast<TYPE *>(BSLS_UTIL_ADDRESSOF(d_union)),
                        AllocBase::mechanism(),
                        arg);
}
// }}} END GENERATED CODE
#endif
#endif  // BSL_VARIANT_FULL_IMPLEMENTATION

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_variant.h
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT
#define BSLSTL_VARIANT_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT_L
#define BSLSTL_VARIANT_VARIADIC_LIMIT_L BSLSTL_VARIANT_VARIADIC_LIMIT
#endif
#if BSLSTL_VARIANT_VARIADIC_LIMIT_L >= 0
template <class HEAD>
Variant_Base<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::~Variant_Base()
{
    reset();
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_L >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_L >= 1
template <class HEAD, class TAIL_01>
Variant_Base<HEAD, TAIL_01,
                   BSLS_COMPILERFEATURES_FILLT( 9)>::~Variant_Base()
{
    reset();
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_L >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_L >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   BSLS_COMPILERFEATURES_FILLT( 8)>::~Variant_Base()
{
    reset();
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_L >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_L >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   BSLS_COMPILERFEATURES_FILLT( 7)>::~Variant_Base()
{
    reset();
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_L >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_L >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   BSLS_COMPILERFEATURES_FILLT( 6)>::~Variant_Base()
{
    reset();
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_L >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_L >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   BSLS_COMPILERFEATURES_FILLT( 5)>::~Variant_Base()
{
    reset();
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_L >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_L >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   BSLS_COMPILERFEATURES_FILLT( 4)>::~Variant_Base()
{
    reset();
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_L >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_L >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   BSLS_COMPILERFEATURES_FILLT( 3)>::~Variant_Base()
{
    reset();
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_L >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_L >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   BSLS_COMPILERFEATURES_FILLT( 2)>::~Variant_Base()
{
    reset();
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_L >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_L >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   BSLS_COMPILERFEATURES_FILLT( 1)>::~Variant_Base()
{
    reset();
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_L >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_L >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   TAIL_10,
                   BSLS_COMPILERFEATURES_FILLT( 0)>::~Variant_Base()
{
    reset();
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_L >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class HEAD, class... TAIL>
Variant_Base<HEAD, TAIL...>::~Variant_Base()
{
    reset();
}
// }}} END GENERATED CODE
#endif
// MANIPULATORS
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
template <class HEAD, class... TAIL>
template <size_t INDEX, class... ARGS>
void Variant_Base<HEAD, TAIL...>::baseEmplace(ARGS&&... args)
{
    reset();

    // We need to assemble the construction arguments for the underlying
    //'Variant_DataImp' object here.  They require that allocator pointer is
    // the leading argument after 'Variant_Union' strips the 'INDEX'.  To be
    // able to get such argument set, we say that 'Variant_Union' is not
    // allocator aware.  If we were to have 'Variant_Union' be allocator aware
    // and use trailing allocator construction, we wouldn't be able to extract
    // the allocator to move it to the right position for the 'Variant_DataImp'
    // construct invocation.  If we were to have either 'Variant_Union' or
    // 'Variant_DataImp' use 'allocator_arg_t' semantics, it wouldn't work for
    // the non allocator aware variant where there is no allocator object.
    BloombergLP::bslma::ConstructionUtil::construct(
                                                BSLS_UTIL_ADDRESSOF(d_union),
                                                (void *)0,
                                                bsl::in_place_index_t<INDEX>{},
                                                AllocBase::mechanism(),
                                                std::forward<ARGS>(args)...);
    d_type = INDEX;
}

#else  // BSL_VARIANT_FULL_IMPLEMENTATION
#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_variant.h
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT
#define BSLSTL_VARIANT_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT_M
#define BSLSTL_VARIANT_VARIADIC_LIMIT_M BSLSTL_VARIANT_VARIADIC_LIMIT
#endif
#if BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 0
template <class HEAD>
template <size_t INDEX>
void Variant_Base<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::baseEmplace()
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();
    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism());
    d_type = INDEX;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 1
template <class HEAD, class TAIL_01>
template <size_t INDEX>
void Variant_Base<HEAD, TAIL_01,
                        BSLS_COMPILERFEATURES_FILLT( 9)>::baseEmplace()
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();
    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism());
    d_type = INDEX;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
template <size_t INDEX>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        BSLS_COMPILERFEATURES_FILLT( 8)>::baseEmplace()
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();
    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism());
    d_type = INDEX;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
template <size_t INDEX>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        BSLS_COMPILERFEATURES_FILLT( 7)>::baseEmplace()
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();
    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism());
    d_type = INDEX;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
template <size_t INDEX>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        TAIL_04,
                        BSLS_COMPILERFEATURES_FILLT( 6)>::baseEmplace()
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();
    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism());
    d_type = INDEX;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
template <size_t INDEX>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        TAIL_04,
                        TAIL_05,
                        BSLS_COMPILERFEATURES_FILLT( 5)>::baseEmplace()
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();
    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism());
    d_type = INDEX;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
template <size_t INDEX>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        TAIL_04,
                        TAIL_05,
                        TAIL_06,
                        BSLS_COMPILERFEATURES_FILLT( 4)>::baseEmplace()
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();
    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism());
    d_type = INDEX;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
template <size_t INDEX>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        TAIL_04,
                        TAIL_05,
                        TAIL_06,
                        TAIL_07,
                        BSLS_COMPILERFEATURES_FILLT( 3)>::baseEmplace()
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();
    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism());
    d_type = INDEX;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
template <size_t INDEX>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        TAIL_04,
                        TAIL_05,
                        TAIL_06,
                        TAIL_07,
                        TAIL_08,
                        BSLS_COMPILERFEATURES_FILLT( 2)>::baseEmplace()
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();
    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism());
    d_type = INDEX;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
template <size_t INDEX>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        TAIL_04,
                        TAIL_05,
                        TAIL_06,
                        TAIL_07,
                        TAIL_08,
                        TAIL_09,
                        BSLS_COMPILERFEATURES_FILLT( 1)>::baseEmplace()
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();
    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism());
    d_type = INDEX;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
template <size_t INDEX>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        TAIL_04,
                        TAIL_05,
                        TAIL_06,
                        TAIL_07,
                        TAIL_08,
                        TAIL_09,
                        TAIL_10,
                        BSLS_COMPILERFEATURES_FILLT( 0)>::baseEmplace()
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();
    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism());
    d_type = INDEX;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 0
template <class HEAD>
template <size_t INDEX, class ARG>
void Variant_Base<HEAD, BSLS_COMPILERFEATURES_FILLT(10)
                        >::baseEmplace(const ARG& arg)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();

    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism(),
                         arg);
    d_type = INDEX;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 1
template <class HEAD, class TAIL_01>
template <size_t INDEX, class ARG>
void Variant_Base<HEAD, TAIL_01,
                        BSLS_COMPILERFEATURES_FILLT( 9)
                        >::baseEmplace(const ARG& arg)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();

    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism(),
                         arg);
    d_type = INDEX;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
template <size_t INDEX, class ARG>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        BSLS_COMPILERFEATURES_FILLT( 8)
                        >::baseEmplace(const ARG& arg)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();

    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism(),
                         arg);
    d_type = INDEX;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
template <size_t INDEX, class ARG>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        BSLS_COMPILERFEATURES_FILLT( 7)
                        >::baseEmplace(const ARG& arg)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();

    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism(),
                         arg);
    d_type = INDEX;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
template <size_t INDEX, class ARG>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        TAIL_04,
                        BSLS_COMPILERFEATURES_FILLT( 6)
                        >::baseEmplace(const ARG& arg)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();

    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism(),
                         arg);
    d_type = INDEX;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
template <size_t INDEX, class ARG>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        TAIL_04,
                        TAIL_05,
                        BSLS_COMPILERFEATURES_FILLT( 5)
                        >::baseEmplace(const ARG& arg)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();

    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism(),
                         arg);
    d_type = INDEX;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
template <size_t INDEX, class ARG>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        TAIL_04,
                        TAIL_05,
                        TAIL_06,
                        BSLS_COMPILERFEATURES_FILLT( 4)
                        >::baseEmplace(const ARG& arg)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();

    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism(),
                         arg);
    d_type = INDEX;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
template <size_t INDEX, class ARG>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        TAIL_04,
                        TAIL_05,
                        TAIL_06,
                        TAIL_07,
                        BSLS_COMPILERFEATURES_FILLT( 3)
                        >::baseEmplace(const ARG& arg)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();

    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism(),
                         arg);
    d_type = INDEX;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
template <size_t INDEX, class ARG>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        TAIL_04,
                        TAIL_05,
                        TAIL_06,
                        TAIL_07,
                        TAIL_08,
                        BSLS_COMPILERFEATURES_FILLT( 2)
                        >::baseEmplace(const ARG& arg)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();

    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism(),
                         arg);
    d_type = INDEX;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
template <size_t INDEX, class ARG>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        TAIL_04,
                        TAIL_05,
                        TAIL_06,
                        TAIL_07,
                        TAIL_08,
                        TAIL_09,
                        BSLS_COMPILERFEATURES_FILLT( 1)
                        >::baseEmplace(const ARG& arg)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();

    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism(),
                         arg);
    d_type = INDEX;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
template <size_t INDEX, class ARG>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        TAIL_04,
                        TAIL_05,
                        TAIL_06,
                        TAIL_07,
                        TAIL_08,
                        TAIL_09,
                        TAIL_10,
                        BSLS_COMPILERFEATURES_FILLT( 0)
                        >::baseEmplace(const ARG& arg)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();

    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism(),
                         arg);
    d_type = INDEX;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_M >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class HEAD, class... TAIL>
template <size_t INDEX>
void Variant_Base<HEAD, TAIL...>::baseEmplace()
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();
    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism());
    d_type = INDEX;
}

template <class HEAD, class... TAIL>
template <size_t INDEX, class ARG>
void Variant_Base<HEAD, TAIL...>::baseEmplace(const ARG& arg)
{
    typedef typename bsl::remove_cv<
        typename bsl::variant_alternative<INDEX, Variant>::type>::type TYPE;

    reset();

    BloombergLP::bslma::ConstructionUtil::construct(
                         reinterpret_cast<TYPE *> BSLS_UTIL_ADDRESSOF(d_union),
                         AllocBase::mechanism(),
                         arg);
    d_type = INDEX;
}
// }}} END GENERATED CODE
#endif
#endif  // BSL_VARIANT_FULL_IMPLEMENTATION
#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_variant.h
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT
#define BSLSTL_VARIANT_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT_N
#define BSLSTL_VARIANT_VARIADIC_LIMIT_N BSLSTL_VARIANT_VARIADIC_LIMIT
#endif
#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 0
template <class HEAD>
inline
Variant_Base<HEAD>& Variant_Base<HEAD, BSLS_COMPILERFEATURES_FILLT(10)
                                       >::operator=(
                                                       const Variant_Base& rhs)
{
    if (&rhs != this) {
        if (this->d_type == rhs.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_CopyAssignVisitor<Variant>
                copyAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       copyAssign,
                                       static_cast<const Variant&>(rhs));
            }
        }
        else {
            reset();
            if (rhs.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
                    copyConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       copyConstructor,
                                       static_cast<const Variant&>(rhs));
            }
            d_type = rhs.d_type;
        }
    }
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 1
template <class HEAD, class TAIL_01>
inline
Variant_Base<HEAD, TAIL_01>& Variant_Base<HEAD, TAIL_01,
                                                BSLS_COMPILERFEATURES_FILLT( 9)
                                                >::operator=(
                                                       const Variant_Base& rhs)
{
    if (&rhs != this) {
        if (this->d_type == rhs.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_CopyAssignVisitor<Variant>
                copyAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       copyAssign,
                                       static_cast<const Variant&>(rhs));
            }
        }
        else {
            reset();
            if (rhs.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
                    copyConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       copyConstructor,
                                       static_cast<const Variant&>(rhs));
            }
            d_type = rhs.d_type;
        }
    }
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02>& Variant_Base<HEAD, TAIL_01,
                                                TAIL_02,
                                                BSLS_COMPILERFEATURES_FILLT( 8)
                                                >::operator=(
                                                       const Variant_Base& rhs)
{
    if (&rhs != this) {
        if (this->d_type == rhs.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_CopyAssignVisitor<Variant>
                copyAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       copyAssign,
                                       static_cast<const Variant&>(rhs));
            }
        }
        else {
            reset();
            if (rhs.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
                    copyConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       copyConstructor,
                                       static_cast<const Variant&>(rhs));
            }
            d_type = rhs.d_type;
        }
    }
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03>& Variant_Base<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                BSLS_COMPILERFEATURES_FILLT( 7)
                                                >::operator=(
                                                       const Variant_Base& rhs)
{
    if (&rhs != this) {
        if (this->d_type == rhs.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_CopyAssignVisitor<Variant>
                copyAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       copyAssign,
                                       static_cast<const Variant&>(rhs));
            }
        }
        else {
            reset();
            if (rhs.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
                    copyConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       copyConstructor,
                                       static_cast<const Variant&>(rhs));
            }
            d_type = rhs.d_type;
        }
    }
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04>& Variant_Base<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                TAIL_04,
                                                BSLS_COMPILERFEATURES_FILLT( 6)
                                                >::operator=(
                                                       const Variant_Base& rhs)
{
    if (&rhs != this) {
        if (this->d_type == rhs.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_CopyAssignVisitor<Variant>
                copyAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       copyAssign,
                                       static_cast<const Variant&>(rhs));
            }
        }
        else {
            reset();
            if (rhs.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
                    copyConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       copyConstructor,
                                       static_cast<const Variant&>(rhs));
            }
            d_type = rhs.d_type;
        }
    }
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05>& Variant_Base<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                TAIL_04,
                                                TAIL_05,
                                                BSLS_COMPILERFEATURES_FILLT( 5)
                                                >::operator=(
                                                       const Variant_Base& rhs)
{
    if (&rhs != this) {
        if (this->d_type == rhs.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_CopyAssignVisitor<Variant>
                copyAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       copyAssign,
                                       static_cast<const Variant&>(rhs));
            }
        }
        else {
            reset();
            if (rhs.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
                    copyConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       copyConstructor,
                                       static_cast<const Variant&>(rhs));
            }
            d_type = rhs.d_type;
        }
    }
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06>& Variant_Base<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                TAIL_04,
                                                TAIL_05,
                                                TAIL_06,
                                                BSLS_COMPILERFEATURES_FILLT( 4)
                                                >::operator=(
                                                       const Variant_Base& rhs)
{
    if (&rhs != this) {
        if (this->d_type == rhs.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_CopyAssignVisitor<Variant>
                copyAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       copyAssign,
                                       static_cast<const Variant&>(rhs));
            }
        }
        else {
            reset();
            if (rhs.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
                    copyConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       copyConstructor,
                                       static_cast<const Variant&>(rhs));
            }
            d_type = rhs.d_type;
        }
    }
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07>& Variant_Base<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                TAIL_04,
                                                TAIL_05,
                                                TAIL_06,
                                                TAIL_07,
                                                BSLS_COMPILERFEATURES_FILLT( 3)
                                                >::operator=(
                                                       const Variant_Base& rhs)
{
    if (&rhs != this) {
        if (this->d_type == rhs.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_CopyAssignVisitor<Variant>
                copyAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       copyAssign,
                                       static_cast<const Variant&>(rhs));
            }
        }
        else {
            reset();
            if (rhs.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
                    copyConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       copyConstructor,
                                       static_cast<const Variant&>(rhs));
            }
            d_type = rhs.d_type;
        }
    }
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08>& Variant_Base<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                TAIL_04,
                                                TAIL_05,
                                                TAIL_06,
                                                TAIL_07,
                                                TAIL_08,
                                                BSLS_COMPILERFEATURES_FILLT( 2)
                                                >::operator=(
                                                       const Variant_Base& rhs)
{
    if (&rhs != this) {
        if (this->d_type == rhs.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_CopyAssignVisitor<Variant>
                copyAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       copyAssign,
                                       static_cast<const Variant&>(rhs));
            }
        }
        else {
            reset();
            if (rhs.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
                    copyConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       copyConstructor,
                                       static_cast<const Variant&>(rhs));
            }
            d_type = rhs.d_type;
        }
    }
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09>& Variant_Base<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                TAIL_04,
                                                TAIL_05,
                                                TAIL_06,
                                                TAIL_07,
                                                TAIL_08,
                                                TAIL_09,
                                                BSLS_COMPILERFEATURES_FILLT( 1)
                                                >::operator=(
                                                       const Variant_Base& rhs)
{
    if (&rhs != this) {
        if (this->d_type == rhs.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_CopyAssignVisitor<Variant>
                copyAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       copyAssign,
                                       static_cast<const Variant&>(rhs));
            }
        }
        else {
            reset();
            if (rhs.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
                    copyConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       copyConstructor,
                                       static_cast<const Variant&>(rhs));
            }
            d_type = rhs.d_type;
        }
    }
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   TAIL_10>& Variant_Base<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                TAIL_04,
                                                TAIL_05,
                                                TAIL_06,
                                                TAIL_07,
                                                TAIL_08,
                                                TAIL_09,
                                                TAIL_10,
                                                BSLS_COMPILERFEATURES_FILLT( 0)
                                                >::operator=(
                                                       const Variant_Base& rhs)
{
    if (&rhs != this) {
        if (this->d_type == rhs.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_CopyAssignVisitor<Variant>
                copyAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       copyAssign,
                                       static_cast<const Variant&>(rhs));
            }
        }
        else {
            reset();
            if (rhs.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
                    copyConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       copyConstructor,
                                       static_cast<const Variant&>(rhs));
            }
            d_type = rhs.d_type;
        }
    }
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 0
template <class HEAD>
inline
Variant_Base<HEAD>& Variant_Base<HEAD, BSLS_COMPILERFEATURES_FILLT(10)
                                       >::operator=(
                              BloombergLP::bslmf::MovableRef<Variant_Base> rhs)
{
    Variant_Base& lvalue = rhs;
    if (&lvalue != this) {
        if (this->d_type == lvalue.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_MoveAssignVisitor<Variant>
                moveAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       moveAssign,
                                       static_cast<Variant&>(lvalue));
            }
        }
        else {
            reset();
            if (lvalue.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       moveConstructor,
                                       static_cast<Variant&>(lvalue));
            }
            d_type = lvalue.d_type;
        }
    }
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 1
template <class HEAD, class TAIL_01>
inline
Variant_Base<HEAD, TAIL_01>& Variant_Base<HEAD, TAIL_01,
                                                BSLS_COMPILERFEATURES_FILLT( 9)
                                                >::operator=(
                              BloombergLP::bslmf::MovableRef<Variant_Base> rhs)
{
    Variant_Base& lvalue = rhs;
    if (&lvalue != this) {
        if (this->d_type == lvalue.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_MoveAssignVisitor<Variant>
                moveAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       moveAssign,
                                       static_cast<Variant&>(lvalue));
            }
        }
        else {
            reset();
            if (lvalue.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       moveConstructor,
                                       static_cast<Variant&>(lvalue));
            }
            d_type = lvalue.d_type;
        }
    }
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02>& Variant_Base<HEAD, TAIL_01,
                                                TAIL_02,
                                                BSLS_COMPILERFEATURES_FILLT( 8)
                                                >::operator=(
                              BloombergLP::bslmf::MovableRef<Variant_Base> rhs)
{
    Variant_Base& lvalue = rhs;
    if (&lvalue != this) {
        if (this->d_type == lvalue.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_MoveAssignVisitor<Variant>
                moveAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       moveAssign,
                                       static_cast<Variant&>(lvalue));
            }
        }
        else {
            reset();
            if (lvalue.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       moveConstructor,
                                       static_cast<Variant&>(lvalue));
            }
            d_type = lvalue.d_type;
        }
    }
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03>& Variant_Base<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                BSLS_COMPILERFEATURES_FILLT( 7)
                                                >::operator=(
                              BloombergLP::bslmf::MovableRef<Variant_Base> rhs)
{
    Variant_Base& lvalue = rhs;
    if (&lvalue != this) {
        if (this->d_type == lvalue.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_MoveAssignVisitor<Variant>
                moveAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       moveAssign,
                                       static_cast<Variant&>(lvalue));
            }
        }
        else {
            reset();
            if (lvalue.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       moveConstructor,
                                       static_cast<Variant&>(lvalue));
            }
            d_type = lvalue.d_type;
        }
    }
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04>& Variant_Base<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                TAIL_04,
                                                BSLS_COMPILERFEATURES_FILLT( 6)
                                                >::operator=(
                              BloombergLP::bslmf::MovableRef<Variant_Base> rhs)
{
    Variant_Base& lvalue = rhs;
    if (&lvalue != this) {
        if (this->d_type == lvalue.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_MoveAssignVisitor<Variant>
                moveAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       moveAssign,
                                       static_cast<Variant&>(lvalue));
            }
        }
        else {
            reset();
            if (lvalue.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       moveConstructor,
                                       static_cast<Variant&>(lvalue));
            }
            d_type = lvalue.d_type;
        }
    }
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05>& Variant_Base<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                TAIL_04,
                                                TAIL_05,
                                                BSLS_COMPILERFEATURES_FILLT( 5)
                                                >::operator=(
                              BloombergLP::bslmf::MovableRef<Variant_Base> rhs)
{
    Variant_Base& lvalue = rhs;
    if (&lvalue != this) {
        if (this->d_type == lvalue.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_MoveAssignVisitor<Variant>
                moveAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       moveAssign,
                                       static_cast<Variant&>(lvalue));
            }
        }
        else {
            reset();
            if (lvalue.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       moveConstructor,
                                       static_cast<Variant&>(lvalue));
            }
            d_type = lvalue.d_type;
        }
    }
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06>& Variant_Base<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                TAIL_04,
                                                TAIL_05,
                                                TAIL_06,
                                                BSLS_COMPILERFEATURES_FILLT( 4)
                                                >::operator=(
                              BloombergLP::bslmf::MovableRef<Variant_Base> rhs)
{
    Variant_Base& lvalue = rhs;
    if (&lvalue != this) {
        if (this->d_type == lvalue.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_MoveAssignVisitor<Variant>
                moveAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       moveAssign,
                                       static_cast<Variant&>(lvalue));
            }
        }
        else {
            reset();
            if (lvalue.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       moveConstructor,
                                       static_cast<Variant&>(lvalue));
            }
            d_type = lvalue.d_type;
        }
    }
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07>& Variant_Base<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                TAIL_04,
                                                TAIL_05,
                                                TAIL_06,
                                                TAIL_07,
                                                BSLS_COMPILERFEATURES_FILLT( 3)
                                                >::operator=(
                              BloombergLP::bslmf::MovableRef<Variant_Base> rhs)
{
    Variant_Base& lvalue = rhs;
    if (&lvalue != this) {
        if (this->d_type == lvalue.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_MoveAssignVisitor<Variant>
                moveAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       moveAssign,
                                       static_cast<Variant&>(lvalue));
            }
        }
        else {
            reset();
            if (lvalue.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       moveConstructor,
                                       static_cast<Variant&>(lvalue));
            }
            d_type = lvalue.d_type;
        }
    }
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08>& Variant_Base<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                TAIL_04,
                                                TAIL_05,
                                                TAIL_06,
                                                TAIL_07,
                                                TAIL_08,
                                                BSLS_COMPILERFEATURES_FILLT( 2)
                                                >::operator=(
                              BloombergLP::bslmf::MovableRef<Variant_Base> rhs)
{
    Variant_Base& lvalue = rhs;
    if (&lvalue != this) {
        if (this->d_type == lvalue.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_MoveAssignVisitor<Variant>
                moveAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       moveAssign,
                                       static_cast<Variant&>(lvalue));
            }
        }
        else {
            reset();
            if (lvalue.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       moveConstructor,
                                       static_cast<Variant&>(lvalue));
            }
            d_type = lvalue.d_type;
        }
    }
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09>& Variant_Base<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                TAIL_04,
                                                TAIL_05,
                                                TAIL_06,
                                                TAIL_07,
                                                TAIL_08,
                                                TAIL_09,
                                                BSLS_COMPILERFEATURES_FILLT( 1)
                                                >::operator=(
                              BloombergLP::bslmf::MovableRef<Variant_Base> rhs)
{
    Variant_Base& lvalue = rhs;
    if (&lvalue != this) {
        if (this->d_type == lvalue.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_MoveAssignVisitor<Variant>
                moveAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       moveAssign,
                                       static_cast<Variant&>(lvalue));
            }
        }
        else {
            reset();
            if (lvalue.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       moveConstructor,
                                       static_cast<Variant&>(lvalue));
            }
            d_type = lvalue.d_type;
        }
    }
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
inline
Variant_Base<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   TAIL_10>& Variant_Base<HEAD, TAIL_01,
                                                TAIL_02,
                                                TAIL_03,
                                                TAIL_04,
                                                TAIL_05,
                                                TAIL_06,
                                                TAIL_07,
                                                TAIL_08,
                                                TAIL_09,
                                                TAIL_10,
                                                BSLS_COMPILERFEATURES_FILLT( 0)
                                                >::operator=(
                              BloombergLP::bslmf::MovableRef<Variant_Base> rhs)
{
    Variant_Base& lvalue = rhs;
    if (&lvalue != this) {
        if (this->d_type == lvalue.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_MoveAssignVisitor<Variant>
                moveAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       moveAssign,
                                       static_cast<Variant&>(lvalue));
            }
        }
        else {
            reset();
            if (lvalue.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       moveConstructor,
                                       static_cast<Variant&>(lvalue));
            }
            d_type = lvalue.d_type;
        }
    }
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 10

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 0
template <class HEAD>
void Variant_Base<HEAD, BSLS_COMPILERFEATURES_FILLT(10)
                        >::reset() BSLS_KEYWORD_NOEXCEPT
{
    if (d_type != bsl::variant_npos) {
        BloombergLP::bslstl::Variant_DestructorVisitor destructor;
        bsl::visit(destructor, static_cast<Variant&>(*this));
        d_type = bsl::variant_npos;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 1
template <class HEAD, class TAIL_01>
void Variant_Base<HEAD, TAIL_01,
                        BSLS_COMPILERFEATURES_FILLT( 9)
                        >::reset() BSLS_KEYWORD_NOEXCEPT
{
    if (d_type != bsl::variant_npos) {
        BloombergLP::bslstl::Variant_DestructorVisitor destructor;
        bsl::visit(destructor, static_cast<Variant&>(*this));
        d_type = bsl::variant_npos;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        BSLS_COMPILERFEATURES_FILLT( 8)
                        >::reset() BSLS_KEYWORD_NOEXCEPT
{
    if (d_type != bsl::variant_npos) {
        BloombergLP::bslstl::Variant_DestructorVisitor destructor;
        bsl::visit(destructor, static_cast<Variant&>(*this));
        d_type = bsl::variant_npos;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        BSLS_COMPILERFEATURES_FILLT( 7)
                        >::reset() BSLS_KEYWORD_NOEXCEPT
{
    if (d_type != bsl::variant_npos) {
        BloombergLP::bslstl::Variant_DestructorVisitor destructor;
        bsl::visit(destructor, static_cast<Variant&>(*this));
        d_type = bsl::variant_npos;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        TAIL_04,
                        BSLS_COMPILERFEATURES_FILLT( 6)
                        >::reset() BSLS_KEYWORD_NOEXCEPT
{
    if (d_type != bsl::variant_npos) {
        BloombergLP::bslstl::Variant_DestructorVisitor destructor;
        bsl::visit(destructor, static_cast<Variant&>(*this));
        d_type = bsl::variant_npos;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        TAIL_04,
                        TAIL_05,
                        BSLS_COMPILERFEATURES_FILLT( 5)
                        >::reset() BSLS_KEYWORD_NOEXCEPT
{
    if (d_type != bsl::variant_npos) {
        BloombergLP::bslstl::Variant_DestructorVisitor destructor;
        bsl::visit(destructor, static_cast<Variant&>(*this));
        d_type = bsl::variant_npos;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        TAIL_04,
                        TAIL_05,
                        TAIL_06,
                        BSLS_COMPILERFEATURES_FILLT( 4)
                        >::reset() BSLS_KEYWORD_NOEXCEPT
{
    if (d_type != bsl::variant_npos) {
        BloombergLP::bslstl::Variant_DestructorVisitor destructor;
        bsl::visit(destructor, static_cast<Variant&>(*this));
        d_type = bsl::variant_npos;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        TAIL_04,
                        TAIL_05,
                        TAIL_06,
                        TAIL_07,
                        BSLS_COMPILERFEATURES_FILLT( 3)
                        >::reset() BSLS_KEYWORD_NOEXCEPT
{
    if (d_type != bsl::variant_npos) {
        BloombergLP::bslstl::Variant_DestructorVisitor destructor;
        bsl::visit(destructor, static_cast<Variant&>(*this));
        d_type = bsl::variant_npos;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        TAIL_04,
                        TAIL_05,
                        TAIL_06,
                        TAIL_07,
                        TAIL_08,
                        BSLS_COMPILERFEATURES_FILLT( 2)
                        >::reset() BSLS_KEYWORD_NOEXCEPT
{
    if (d_type != bsl::variant_npos) {
        BloombergLP::bslstl::Variant_DestructorVisitor destructor;
        bsl::visit(destructor, static_cast<Variant&>(*this));
        d_type = bsl::variant_npos;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        TAIL_04,
                        TAIL_05,
                        TAIL_06,
                        TAIL_07,
                        TAIL_08,
                        TAIL_09,
                        BSLS_COMPILERFEATURES_FILLT( 1)
                        >::reset() BSLS_KEYWORD_NOEXCEPT
{
    if (d_type != bsl::variant_npos) {
        BloombergLP::bslstl::Variant_DestructorVisitor destructor;
        bsl::visit(destructor, static_cast<Variant&>(*this));
        d_type = bsl::variant_npos;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
void Variant_Base<HEAD, TAIL_01,
                        TAIL_02,
                        TAIL_03,
                        TAIL_04,
                        TAIL_05,
                        TAIL_06,
                        TAIL_07,
                        TAIL_08,
                        TAIL_09,
                        TAIL_10,
                        BSLS_COMPILERFEATURES_FILLT( 0)
                        >::reset() BSLS_KEYWORD_NOEXCEPT
{
    if (d_type != bsl::variant_npos) {
        BloombergLP::bslstl::Variant_DestructorVisitor destructor;
        bsl::visit(destructor, static_cast<Variant&>(*this));
        d_type = bsl::variant_npos;
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_N >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class HEAD, class... TAIL>
inline
Variant_Base<HEAD, TAIL...>& Variant_Base<HEAD, TAIL...>::operator=(
                                                       const Variant_Base& rhs)
{
    if (&rhs != this) {
        if (this->d_type == rhs.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_CopyAssignVisitor<Variant>
                copyAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       copyAssign,
                                       static_cast<const Variant&>(rhs));
            }
        }
        else {
            reset();
            if (rhs.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_CopyConstructVisitor<Variant_Base>
                    copyConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       copyConstructor,
                                       static_cast<const Variant&>(rhs));
            }
            d_type = rhs.d_type;
        }
    }
    return *this;
}

template <class HEAD, class... TAIL>
inline
Variant_Base<HEAD, TAIL...>& Variant_Base<HEAD, TAIL...>::operator=(
                              BloombergLP::bslmf::MovableRef<Variant_Base> rhs)
{
    Variant_Base& lvalue = rhs;
    if (&lvalue != this) {
        if (this->d_type == lvalue.d_type) {
            if (d_type != bsl::variant_npos) {
                Variant& self = static_cast<Variant&>(*this);
                BloombergLP::bslstl::Variant_MoveAssignVisitor<Variant>
                moveAssign(BSLS_UTIL_ADDRESSOF(self));
                BSLSTL_VARIANT_VISITID(void,
                                       moveAssign,
                                       static_cast<Variant&>(lvalue));
            }
        }
        else {
            reset();
            if (lvalue.d_type != bsl::variant_npos) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void,
                                       moveConstructor,
                                       static_cast<Variant&>(lvalue));
            }
            d_type = lvalue.d_type;
        }
    }
    return *this;
}
template <class HEAD, class... TAIL>
void Variant_Base<HEAD, TAIL...>::reset() BSLS_KEYWORD_NOEXCEPT
{
    if (d_type != bsl::variant_npos) {
        BloombergLP::bslstl::Variant_DestructorVisitor destructor;
        bsl::visit(destructor, static_cast<Variant&>(*this));
        d_type = bsl::variant_npos;
    }
}
// }}} END GENERATED CODE
#endif
}  // close package namespace
}  // close enterprise namespace

namespace bsl {

                               // -------------
                               // class variant
                               // -------------

// CREATORS
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
template <class HEAD, class... TAIL>
template <class TYPE>
inline
variant<HEAD, TAIL...>::variant(
                       TYPE&& value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       std::forward<TYPE>(value))
{
}

template <class HEAD, class... TAIL>
template <class TYPE>
inline
variant<HEAD, TAIL...>::variant(
                       bsl::allocator_arg_t,
                       allocator_type allocator,
                       TYPE&&         value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::allocator_arg_t{},
       allocator,
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       std::forward<TYPE>(value))
{
}
#else  // BSL_VARIANT_FULL_IMPLEMENTATION
#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_variant.h
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT
#define BSLSTL_VARIANT_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT_O
#define BSLSTL_VARIANT_VARIADIC_LIMIT_O BSLSTL_VARIANT_VARIADIC_LIMIT
#endif
#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0
template <class HEAD>
inline
variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::variant()
: Variant_Base()
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1
template <class HEAD, class TAIL_01>
inline
variant<HEAD, TAIL_01,
              BSLS_COMPILERFEATURES_FILLT( 9)>::variant()
: Variant_Base()
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              BSLS_COMPILERFEATURES_FILLT( 8)>::variant()
: Variant_Base()
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              BSLS_COMPILERFEATURES_FILLT( 7)>::variant()
: Variant_Base()
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              BSLS_COMPILERFEATURES_FILLT( 6)>::variant()
: Variant_Base()
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              BSLS_COMPILERFEATURES_FILLT( 5)>::variant()
: Variant_Base()
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              BSLS_COMPILERFEATURES_FILLT( 4)>::variant()
: Variant_Base()
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              BSLS_COMPILERFEATURES_FILLT( 3)>::variant()
: Variant_Base()
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              BSLS_COMPILERFEATURES_FILLT( 2)>::variant()
: Variant_Base()
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              BSLS_COMPILERFEATURES_FILLT( 1)>::variant()
: Variant_Base()
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10,
              BSLS_COMPILERFEATURES_FILLT( 0)>::variant()
: Variant_Base()
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0
template <class HEAD>
inline
variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)
              >::variant(const variant& original)
: Variant_Base(original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1
template <class HEAD, class TAIL_01>
inline
variant<HEAD, TAIL_01,
              BSLS_COMPILERFEATURES_FILLT( 9)
              >::variant(const variant& original)
: Variant_Base(original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              BSLS_COMPILERFEATURES_FILLT( 8)
              >::variant(const variant& original)
: Variant_Base(original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              BSLS_COMPILERFEATURES_FILLT( 7)
              >::variant(const variant& original)
: Variant_Base(original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              BSLS_COMPILERFEATURES_FILLT( 6)
              >::variant(const variant& original)
: Variant_Base(original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              BSLS_COMPILERFEATURES_FILLT( 5)
              >::variant(const variant& original)
: Variant_Base(original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              BSLS_COMPILERFEATURES_FILLT( 4)
              >::variant(const variant& original)
: Variant_Base(original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              BSLS_COMPILERFEATURES_FILLT( 3)
              >::variant(const variant& original)
: Variant_Base(original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              BSLS_COMPILERFEATURES_FILLT( 2)
              >::variant(const variant& original)
: Variant_Base(original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              BSLS_COMPILERFEATURES_FILLT( 1)
              >::variant(const variant& original)
: Variant_Base(original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10,
              BSLS_COMPILERFEATURES_FILLT( 0)
              >::variant(const variant& original)
: Variant_Base(original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0
template <class HEAD>
inline
variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::variant(
                              BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1
template <class HEAD, class TAIL_01>
inline
variant<HEAD, TAIL_01,
              BSLS_COMPILERFEATURES_FILLT( 9)>::variant(
                              BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              BSLS_COMPILERFEATURES_FILLT( 8)>::variant(
                              BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              BSLS_COMPILERFEATURES_FILLT( 7)>::variant(
                              BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              BSLS_COMPILERFEATURES_FILLT( 6)>::variant(
                              BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              BSLS_COMPILERFEATURES_FILLT( 5)>::variant(
                              BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              BSLS_COMPILERFEATURES_FILLT( 4)>::variant(
                              BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              BSLS_COMPILERFEATURES_FILLT( 3)>::variant(
                              BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              BSLS_COMPILERFEATURES_FILLT( 2)>::variant(
                              BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              BSLS_COMPILERFEATURES_FILLT( 1)>::variant(
                              BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10,
              BSLS_COMPILERFEATURES_FILLT( 0)>::variant(
                              BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0
template <class HEAD>
template <class TYPE>
inline
variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::variant(
                       const TYPE& value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1
template <class HEAD, class TAIL_01>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              BSLS_COMPILERFEATURES_FILLT( 9)>::variant(
                       const TYPE& value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              BSLS_COMPILERFEATURES_FILLT( 8)>::variant(
                       const TYPE& value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              BSLS_COMPILERFEATURES_FILLT( 7)>::variant(
                       const TYPE& value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              BSLS_COMPILERFEATURES_FILLT( 6)>::variant(
                       const TYPE& value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              BSLS_COMPILERFEATURES_FILLT( 5)>::variant(
                       const TYPE& value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              BSLS_COMPILERFEATURES_FILLT( 4)>::variant(
                       const TYPE& value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              BSLS_COMPILERFEATURES_FILLT( 3)>::variant(
                       const TYPE& value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              BSLS_COMPILERFEATURES_FILLT( 2)>::variant(
                       const TYPE& value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              BSLS_COMPILERFEATURES_FILLT( 1)>::variant(
                       const TYPE& value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10,
              BSLS_COMPILERFEATURES_FILLT( 0)>::variant(
                       const TYPE& value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0
template <class HEAD>
template <class TYPE>
inline
variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)
              >::variant(bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1
template <class HEAD, class TAIL_01>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              BSLS_COMPILERFEATURES_FILLT( 9)
              >::variant(bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              BSLS_COMPILERFEATURES_FILLT( 8)
              >::variant(bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              BSLS_COMPILERFEATURES_FILLT( 7)
              >::variant(bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              BSLS_COMPILERFEATURES_FILLT( 6)
              >::variant(bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              BSLS_COMPILERFEATURES_FILLT( 5)
              >::variant(bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              BSLS_COMPILERFEATURES_FILLT( 4)
              >::variant(bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              BSLS_COMPILERFEATURES_FILLT( 3)
              >::variant(bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              BSLS_COMPILERFEATURES_FILLT( 2)
              >::variant(bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              BSLS_COMPILERFEATURES_FILLT( 1)
              >::variant(bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10,
              BSLS_COMPILERFEATURES_FILLT( 0)
              >::variant(bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0
template <class HEAD>
template <class TYPE, class ARG>
inline
variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)
              >::variant(bsl::in_place_type_t<TYPE>,
                                const ARG& arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1
template <class HEAD, class TAIL_01>
template <class TYPE, class ARG>
inline
variant<HEAD, TAIL_01,
              BSLS_COMPILERFEATURES_FILLT( 9)
              >::variant(bsl::in_place_type_t<TYPE>,
                                const ARG& arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
template <class TYPE, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              BSLS_COMPILERFEATURES_FILLT( 8)
              >::variant(bsl::in_place_type_t<TYPE>,
                                const ARG& arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
template <class TYPE, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              BSLS_COMPILERFEATURES_FILLT( 7)
              >::variant(bsl::in_place_type_t<TYPE>,
                                const ARG& arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
template <class TYPE, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              BSLS_COMPILERFEATURES_FILLT( 6)
              >::variant(bsl::in_place_type_t<TYPE>,
                                const ARG& arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
template <class TYPE, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              BSLS_COMPILERFEATURES_FILLT( 5)
              >::variant(bsl::in_place_type_t<TYPE>,
                                const ARG& arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
template <class TYPE, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              BSLS_COMPILERFEATURES_FILLT( 4)
              >::variant(bsl::in_place_type_t<TYPE>,
                                const ARG& arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
template <class TYPE, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              BSLS_COMPILERFEATURES_FILLT( 3)
              >::variant(bsl::in_place_type_t<TYPE>,
                                const ARG& arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
template <class TYPE, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              BSLS_COMPILERFEATURES_FILLT( 2)
              >::variant(bsl::in_place_type_t<TYPE>,
                                const ARG& arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
template <class TYPE, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              BSLS_COMPILERFEATURES_FILLT( 1)
              >::variant(bsl::in_place_type_t<TYPE>,
                                const ARG& arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
template <class TYPE, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10,
              BSLS_COMPILERFEATURES_FILLT( 0)
              >::variant(bsl::in_place_type_t<TYPE>,
                                const ARG& arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0
template <class HEAD>
template <size_t INDEX>
inline
variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)
              >::variant(bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::in_place_index_t<INDEX>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1
template <class HEAD, class TAIL_01>
template <size_t INDEX>
inline
variant<HEAD, TAIL_01,
              BSLS_COMPILERFEATURES_FILLT( 9)
              >::variant(bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::in_place_index_t<INDEX>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
template <size_t INDEX>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              BSLS_COMPILERFEATURES_FILLT( 8)
              >::variant(bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::in_place_index_t<INDEX>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
template <size_t INDEX>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              BSLS_COMPILERFEATURES_FILLT( 7)
              >::variant(bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::in_place_index_t<INDEX>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
template <size_t INDEX>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              BSLS_COMPILERFEATURES_FILLT( 6)
              >::variant(bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::in_place_index_t<INDEX>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
template <size_t INDEX>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              BSLS_COMPILERFEATURES_FILLT( 5)
              >::variant(bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::in_place_index_t<INDEX>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
template <size_t INDEX>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              BSLS_COMPILERFEATURES_FILLT( 4)
              >::variant(bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::in_place_index_t<INDEX>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
template <size_t INDEX>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              BSLS_COMPILERFEATURES_FILLT( 3)
              >::variant(bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::in_place_index_t<INDEX>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
template <size_t INDEX>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              BSLS_COMPILERFEATURES_FILLT( 2)
              >::variant(bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::in_place_index_t<INDEX>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
template <size_t INDEX>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              BSLS_COMPILERFEATURES_FILLT( 1)
              >::variant(bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::in_place_index_t<INDEX>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
template <size_t INDEX>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10,
              BSLS_COMPILERFEATURES_FILLT( 0)
              >::variant(bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::in_place_index_t<INDEX>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0
template <class HEAD>
template <size_t INDEX, class ARG>
inline
variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)
              >::variant(bsl::in_place_index_t<INDEX>, const ARG& arg)
: Variant_Base(bsl::in_place_index_t<INDEX>(), arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1
template <class HEAD, class TAIL_01>
template <size_t INDEX, class ARG>
inline
variant<HEAD, TAIL_01,
              BSLS_COMPILERFEATURES_FILLT( 9)
              >::variant(bsl::in_place_index_t<INDEX>, const ARG& arg)
: Variant_Base(bsl::in_place_index_t<INDEX>(), arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
template <size_t INDEX, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              BSLS_COMPILERFEATURES_FILLT( 8)
              >::variant(bsl::in_place_index_t<INDEX>, const ARG& arg)
: Variant_Base(bsl::in_place_index_t<INDEX>(), arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
template <size_t INDEX, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              BSLS_COMPILERFEATURES_FILLT( 7)
              >::variant(bsl::in_place_index_t<INDEX>, const ARG& arg)
: Variant_Base(bsl::in_place_index_t<INDEX>(), arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
template <size_t INDEX, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              BSLS_COMPILERFEATURES_FILLT( 6)
              >::variant(bsl::in_place_index_t<INDEX>, const ARG& arg)
: Variant_Base(bsl::in_place_index_t<INDEX>(), arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
template <size_t INDEX, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              BSLS_COMPILERFEATURES_FILLT( 5)
              >::variant(bsl::in_place_index_t<INDEX>, const ARG& arg)
: Variant_Base(bsl::in_place_index_t<INDEX>(), arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
template <size_t INDEX, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              BSLS_COMPILERFEATURES_FILLT( 4)
              >::variant(bsl::in_place_index_t<INDEX>, const ARG& arg)
: Variant_Base(bsl::in_place_index_t<INDEX>(), arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
template <size_t INDEX, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              BSLS_COMPILERFEATURES_FILLT( 3)
              >::variant(bsl::in_place_index_t<INDEX>, const ARG& arg)
: Variant_Base(bsl::in_place_index_t<INDEX>(), arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
template <size_t INDEX, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              BSLS_COMPILERFEATURES_FILLT( 2)
              >::variant(bsl::in_place_index_t<INDEX>, const ARG& arg)
: Variant_Base(bsl::in_place_index_t<INDEX>(), arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
template <size_t INDEX, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              BSLS_COMPILERFEATURES_FILLT( 1)
              >::variant(bsl::in_place_index_t<INDEX>, const ARG& arg)
: Variant_Base(bsl::in_place_index_t<INDEX>(), arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
template <size_t INDEX, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10,
              BSLS_COMPILERFEATURES_FILLT( 0)
              >::variant(bsl::in_place_index_t<INDEX>, const ARG& arg)
: Variant_Base(bsl::in_place_index_t<INDEX>(), arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0
template <class HEAD>
inline
variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)
              >::variant(bsl::allocator_arg_t, allocator_type allocator)
: Variant_Base(bsl::allocator_arg_t(), allocator)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1
template <class HEAD, class TAIL_01>
inline
variant<HEAD, TAIL_01,
              BSLS_COMPILERFEATURES_FILLT( 9)
              >::variant(bsl::allocator_arg_t, allocator_type allocator)
: Variant_Base(bsl::allocator_arg_t(), allocator)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              BSLS_COMPILERFEATURES_FILLT( 8)
              >::variant(bsl::allocator_arg_t, allocator_type allocator)
: Variant_Base(bsl::allocator_arg_t(), allocator)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              BSLS_COMPILERFEATURES_FILLT( 7)
              >::variant(bsl::allocator_arg_t, allocator_type allocator)
: Variant_Base(bsl::allocator_arg_t(), allocator)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              BSLS_COMPILERFEATURES_FILLT( 6)
              >::variant(bsl::allocator_arg_t, allocator_type allocator)
: Variant_Base(bsl::allocator_arg_t(), allocator)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              BSLS_COMPILERFEATURES_FILLT( 5)
              >::variant(bsl::allocator_arg_t, allocator_type allocator)
: Variant_Base(bsl::allocator_arg_t(), allocator)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              BSLS_COMPILERFEATURES_FILLT( 4)
              >::variant(bsl::allocator_arg_t, allocator_type allocator)
: Variant_Base(bsl::allocator_arg_t(), allocator)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              BSLS_COMPILERFEATURES_FILLT( 3)
              >::variant(bsl::allocator_arg_t, allocator_type allocator)
: Variant_Base(bsl::allocator_arg_t(), allocator)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              BSLS_COMPILERFEATURES_FILLT( 2)
              >::variant(bsl::allocator_arg_t, allocator_type allocator)
: Variant_Base(bsl::allocator_arg_t(), allocator)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              BSLS_COMPILERFEATURES_FILLT( 1)
              >::variant(bsl::allocator_arg_t, allocator_type allocator)
: Variant_Base(bsl::allocator_arg_t(), allocator)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10,
              BSLS_COMPILERFEATURES_FILLT( 0)
              >::variant(bsl::allocator_arg_t, allocator_type allocator)
: Variant_Base(bsl::allocator_arg_t(), allocator)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0
template <class HEAD>
inline
variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                const variant& original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1
template <class HEAD, class TAIL_01>
inline
variant<HEAD, TAIL_01,
              BSLS_COMPILERFEATURES_FILLT( 9)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                const variant& original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              BSLS_COMPILERFEATURES_FILLT( 8)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                const variant& original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              BSLS_COMPILERFEATURES_FILLT( 7)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                const variant& original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              BSLS_COMPILERFEATURES_FILLT( 6)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                const variant& original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              BSLS_COMPILERFEATURES_FILLT( 5)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                const variant& original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              BSLS_COMPILERFEATURES_FILLT( 4)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                const variant& original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              BSLS_COMPILERFEATURES_FILLT( 3)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                const variant& original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              BSLS_COMPILERFEATURES_FILLT( 2)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                const variant& original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              BSLS_COMPILERFEATURES_FILLT( 1)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                const variant& original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10,
              BSLS_COMPILERFEATURES_FILLT( 0)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                const variant& original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0
template <class HEAD>
inline
variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::variant(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1
template <class HEAD, class TAIL_01>
inline
variant<HEAD, TAIL_01,
              BSLS_COMPILERFEATURES_FILLT( 9)>::variant(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              BSLS_COMPILERFEATURES_FILLT( 8)>::variant(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              BSLS_COMPILERFEATURES_FILLT( 7)>::variant(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              BSLS_COMPILERFEATURES_FILLT( 6)>::variant(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              BSLS_COMPILERFEATURES_FILLT( 5)>::variant(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              BSLS_COMPILERFEATURES_FILLT( 4)>::variant(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              BSLS_COMPILERFEATURES_FILLT( 3)>::variant(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              BSLS_COMPILERFEATURES_FILLT( 2)>::variant(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              BSLS_COMPILERFEATURES_FILLT( 1)>::variant(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10,
              BSLS_COMPILERFEATURES_FILLT( 0)>::variant(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0
template <class HEAD>
template <class TYPE>
inline
variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::variant(
                       bsl::allocator_arg_t,
                       allocator_type allocator,
                       const TYPE&    value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::allocator_arg_t(),
       allocator,
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1
template <class HEAD, class TAIL_01>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              BSLS_COMPILERFEATURES_FILLT( 9)>::variant(
                       bsl::allocator_arg_t,
                       allocator_type allocator,
                       const TYPE&    value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::allocator_arg_t(),
       allocator,
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              BSLS_COMPILERFEATURES_FILLT( 8)>::variant(
                       bsl::allocator_arg_t,
                       allocator_type allocator,
                       const TYPE&    value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::allocator_arg_t(),
       allocator,
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              BSLS_COMPILERFEATURES_FILLT( 7)>::variant(
                       bsl::allocator_arg_t,
                       allocator_type allocator,
                       const TYPE&    value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::allocator_arg_t(),
       allocator,
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              BSLS_COMPILERFEATURES_FILLT( 6)>::variant(
                       bsl::allocator_arg_t,
                       allocator_type allocator,
                       const TYPE&    value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::allocator_arg_t(),
       allocator,
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              BSLS_COMPILERFEATURES_FILLT( 5)>::variant(
                       bsl::allocator_arg_t,
                       allocator_type allocator,
                       const TYPE&    value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::allocator_arg_t(),
       allocator,
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              BSLS_COMPILERFEATURES_FILLT( 4)>::variant(
                       bsl::allocator_arg_t,
                       allocator_type allocator,
                       const TYPE&    value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::allocator_arg_t(),
       allocator,
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              BSLS_COMPILERFEATURES_FILLT( 3)>::variant(
                       bsl::allocator_arg_t,
                       allocator_type allocator,
                       const TYPE&    value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::allocator_arg_t(),
       allocator,
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              BSLS_COMPILERFEATURES_FILLT( 2)>::variant(
                       bsl::allocator_arg_t,
                       allocator_type allocator,
                       const TYPE&    value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::allocator_arg_t(),
       allocator,
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              BSLS_COMPILERFEATURES_FILLT( 1)>::variant(
                       bsl::allocator_arg_t,
                       allocator_type allocator,
                       const TYPE&    value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::allocator_arg_t(),
       allocator,
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10,
              BSLS_COMPILERFEATURES_FILLT( 0)>::variant(
                       bsl::allocator_arg_t,
                       allocator_type allocator,
                       const TYPE&    value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::allocator_arg_t(),
       allocator,
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0
template <class HEAD>
template <class TYPE>
inline
variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1
template <class HEAD, class TAIL_01>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              BSLS_COMPILERFEATURES_FILLT( 9)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              BSLS_COMPILERFEATURES_FILLT( 8)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              BSLS_COMPILERFEATURES_FILLT( 7)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              BSLS_COMPILERFEATURES_FILLT( 6)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              BSLS_COMPILERFEATURES_FILLT( 5)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              BSLS_COMPILERFEATURES_FILLT( 4)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              BSLS_COMPILERFEATURES_FILLT( 3)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              BSLS_COMPILERFEATURES_FILLT( 2)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              BSLS_COMPILERFEATURES_FILLT( 1)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
template <class TYPE>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10,
              BSLS_COMPILERFEATURES_FILLT( 0)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0
template <class HEAD>
template <class TYPE, class ARG>
inline
variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                const ARG&     arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1
template <class HEAD, class TAIL_01>
template <class TYPE, class ARG>
inline
variant<HEAD, TAIL_01,
              BSLS_COMPILERFEATURES_FILLT( 9)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                const ARG&     arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
template <class TYPE, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              BSLS_COMPILERFEATURES_FILLT( 8)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                const ARG&     arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
template <class TYPE, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              BSLS_COMPILERFEATURES_FILLT( 7)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                const ARG&     arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
template <class TYPE, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              BSLS_COMPILERFEATURES_FILLT( 6)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                const ARG&     arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
template <class TYPE, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              BSLS_COMPILERFEATURES_FILLT( 5)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                const ARG&     arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
template <class TYPE, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              BSLS_COMPILERFEATURES_FILLT( 4)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                const ARG&     arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
template <class TYPE, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              BSLS_COMPILERFEATURES_FILLT( 3)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                const ARG&     arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
template <class TYPE, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              BSLS_COMPILERFEATURES_FILLT( 2)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                const ARG&     arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
template <class TYPE, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              BSLS_COMPILERFEATURES_FILLT( 1)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                const ARG&     arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
template <class TYPE, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10,
              BSLS_COMPILERFEATURES_FILLT( 0)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                const ARG&     arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0
template <class HEAD>
template <size_t INDEX>
inline
variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1
template <class HEAD, class TAIL_01>
template <size_t INDEX>
inline
variant<HEAD, TAIL_01,
              BSLS_COMPILERFEATURES_FILLT( 9)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
template <size_t INDEX>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              BSLS_COMPILERFEATURES_FILLT( 8)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
template <size_t INDEX>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              BSLS_COMPILERFEATURES_FILLT( 7)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
template <size_t INDEX>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              BSLS_COMPILERFEATURES_FILLT( 6)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
template <size_t INDEX>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              BSLS_COMPILERFEATURES_FILLT( 5)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
template <size_t INDEX>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              BSLS_COMPILERFEATURES_FILLT( 4)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
template <size_t INDEX>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              BSLS_COMPILERFEATURES_FILLT( 3)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
template <size_t INDEX>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              BSLS_COMPILERFEATURES_FILLT( 2)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
template <size_t INDEX>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              BSLS_COMPILERFEATURES_FILLT( 1)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
template <size_t INDEX>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10,
              BSLS_COMPILERFEATURES_FILLT( 0)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>())
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0
template <class HEAD>
template <size_t INDEX, class ARG>
inline
variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>,
                                const ARG& arg)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1
template <class HEAD, class TAIL_01>
template <size_t INDEX, class ARG>
inline
variant<HEAD, TAIL_01,
              BSLS_COMPILERFEATURES_FILLT( 9)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>,
                                const ARG& arg)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
template <size_t INDEX, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              BSLS_COMPILERFEATURES_FILLT( 8)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>,
                                const ARG& arg)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
template <size_t INDEX, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              BSLS_COMPILERFEATURES_FILLT( 7)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>,
                                const ARG& arg)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
template <size_t INDEX, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              BSLS_COMPILERFEATURES_FILLT( 6)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>,
                                const ARG& arg)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
template <size_t INDEX, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              BSLS_COMPILERFEATURES_FILLT( 5)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>,
                                const ARG& arg)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
template <size_t INDEX, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              BSLS_COMPILERFEATURES_FILLT( 4)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>,
                                const ARG& arg)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
template <size_t INDEX, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              BSLS_COMPILERFEATURES_FILLT( 3)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>,
                                const ARG& arg)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
template <size_t INDEX, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              BSLS_COMPILERFEATURES_FILLT( 2)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>,
                                const ARG& arg)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
template <size_t INDEX, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              BSLS_COMPILERFEATURES_FILLT( 1)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>,
                                const ARG& arg)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
template <size_t INDEX, class ARG>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10,
              BSLS_COMPILERFEATURES_FILLT( 0)>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>,
                                const ARG& arg)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>(),
               arg)
{
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_O >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class HEAD, class... TAIL>
inline
variant<HEAD, TAIL...>::variant()
: Variant_Base()
{
}

template <class HEAD, class... TAIL>
inline
variant<HEAD, TAIL...>::variant(const variant& original)
: Variant_Base(original)
{
}

template <class HEAD, class... TAIL>
inline
variant<HEAD, TAIL...>::variant(
                              BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(original)
{
}

template <class HEAD, class... TAIL>
template <class TYPE>
inline
variant<HEAD, TAIL...>::variant(
                       const TYPE& value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}

template <class HEAD, class... TAIL>
template <class TYPE>
inline
variant<HEAD, TAIL...>::variant(bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}

template <class HEAD, class... TAIL>
template <class TYPE, class ARG>
inline
variant<HEAD, TAIL...>::variant(bsl::in_place_type_t<TYPE>,
                                const ARG& arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}

template <class HEAD, class... TAIL>
template <size_t INDEX>
inline
variant<HEAD, TAIL...>::variant(bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::in_place_index_t<INDEX>())
{
}

template <class HEAD, class... TAIL>
template <size_t INDEX, class ARG>
inline
variant<HEAD, TAIL...>::variant(bsl::in_place_index_t<INDEX>, const ARG& arg)
: Variant_Base(bsl::in_place_index_t<INDEX>(), arg)
{
}

template <class HEAD, class... TAIL>
inline
variant<HEAD, TAIL...>::variant(bsl::allocator_arg_t, allocator_type allocator)
: Variant_Base(bsl::allocator_arg_t(), allocator)
{
}

template <class HEAD, class... TAIL>
inline
variant<HEAD, TAIL...>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                const variant& original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}

template <class HEAD, class... TAIL>
inline
variant<HEAD, TAIL...>::variant(
                             bsl::allocator_arg_t,
                             allocator_type                          allocator,
                             BloombergLP::bslmf::MovableRef<variant> original)
: Variant_Base(bsl::allocator_arg_t(), allocator, original)
{
}

template <class HEAD, class... TAIL>
template <class TYPE>
inline
variant<HEAD, TAIL...>::variant(
                       bsl::allocator_arg_t,
                       allocator_type allocator,
                       const TYPE&    value,
                       BSLSTL_VARIANT_DEFINE_IF_CONSTRUCTS_FROM(variant, TYPE))
: Variant_Base(
       bsl::allocator_arg_t(),
       allocator,
       bsl::in_place_index_t<BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant)>(),
       value)
{
}

template <class HEAD, class... TAIL>
template <class TYPE>
inline
variant<HEAD, TAIL...>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>())
{
}

template <class HEAD, class... TAIL>
template <class TYPE, class ARG>
inline
variant<HEAD, TAIL...>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_type_t<TYPE>,
                                const ARG&     arg,
                                BSLSTL_VARIANT_DEFINE_IF_HAS_UNIQUE_TYPE(TYPE))
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, variant)>(),
               arg)
{
}

template <class HEAD, class... TAIL>
template <size_t INDEX>
inline
variant<HEAD, TAIL...>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>())
{
}

template <class HEAD, class... TAIL>
template <size_t INDEX, class ARG>
inline
variant<HEAD, TAIL...>::variant(bsl::allocator_arg_t,
                                allocator_type allocator,
                                bsl::in_place_index_t<INDEX>,
                                const ARG& arg)
: Variant_Base(bsl::allocator_arg_t(),
               allocator,
               bsl::in_place_index_t<INDEX>(),
               arg)
{
}
// }}} END GENERATED CODE
#endif
#endif  // BSL_VARIANT_FULL_IMPLEMENTATION

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_variant.h
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT
#define BSLSTL_VARIANT_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT_P
#define BSLSTL_VARIANT_VARIADIC_LIMIT_P BSLSTL_VARIANT_VARIADIC_LIMIT
#endif
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 0
template <class HEAD>
template <class TYPE>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD> >::value,
    TYPE&>::type
variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::emplace()
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>();

    return bsl::get<index>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 1
template <class HEAD, class TAIL_01>
template <class TYPE>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD, TAIL_01> >::value,
    TYPE&>::type
variant<HEAD, TAIL_01,
              BSLS_COMPILERFEATURES_FILLT( 9)>::emplace()
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>();

    return bsl::get<index>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
template <class TYPE>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD, TAIL_01,
                                                             TAIL_02> >::value,
    TYPE&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              BSLS_COMPILERFEATURES_FILLT( 8)>::emplace()
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>();

    return bsl::get<index>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
template <class TYPE>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03> >::value,
    TYPE&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              BSLS_COMPILERFEATURES_FILLT( 7)>::emplace()
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>();

    return bsl::get<index>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
template <class TYPE>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03,
                                                             TAIL_04> >::value,
    TYPE&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              BSLS_COMPILERFEATURES_FILLT( 6)>::emplace()
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>();

    return bsl::get<index>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
template <class TYPE>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03,
                                                             TAIL_04,
                                                             TAIL_05> >::value,
    TYPE&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              BSLS_COMPILERFEATURES_FILLT( 5)>::emplace()
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>();

    return bsl::get<index>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
template <class TYPE>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03,
                                                             TAIL_04,
                                                             TAIL_05,
                                                             TAIL_06> >::value,
    TYPE&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              BSLS_COMPILERFEATURES_FILLT( 4)>::emplace()
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>();

    return bsl::get<index>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
template <class TYPE>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03,
                                                             TAIL_04,
                                                             TAIL_05,
                                                             TAIL_06,
                                                             TAIL_07> >::value,
    TYPE&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              BSLS_COMPILERFEATURES_FILLT( 3)>::emplace()
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>();

    return bsl::get<index>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
template <class TYPE>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03,
                                                             TAIL_04,
                                                             TAIL_05,
                                                             TAIL_06,
                                                             TAIL_07,
                                                             TAIL_08> >::value,
    TYPE&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              BSLS_COMPILERFEATURES_FILLT( 2)>::emplace()
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>();

    return bsl::get<index>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
template <class TYPE>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03,
                                                             TAIL_04,
                                                             TAIL_05,
                                                             TAIL_06,
                                                             TAIL_07,
                                                             TAIL_08,
                                                             TAIL_09> >::value,
    TYPE&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              BSLS_COMPILERFEATURES_FILLT( 1)>::emplace()
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>();

    return bsl::get<index>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
template <class TYPE>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03,
                                                             TAIL_04,
                                                             TAIL_05,
                                                             TAIL_06,
                                                             TAIL_07,
                                                             TAIL_08,
                                                             TAIL_09,
                                                             TAIL_10> >::value,
    TYPE&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10,
              BSLS_COMPILERFEATURES_FILLT( 0)>::emplace()
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>();

    return bsl::get<index>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 0
template <class HEAD>
template <class TYPE, class ARG>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD> >::value,
    TYPE&>::type
variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::emplace(const ARG& arg)
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>(arg);

    return bsl::get<index>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 1
template <class HEAD, class TAIL_01>
template <class TYPE, class ARG>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD, TAIL_01> >::value,
    TYPE&>::type
variant<HEAD, TAIL_01,
              BSLS_COMPILERFEATURES_FILLT( 9)>::emplace(const ARG& arg)
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>(arg);

    return bsl::get<index>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
template <class TYPE, class ARG>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD, TAIL_01,
                                                             TAIL_02> >::value,
    TYPE&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              BSLS_COMPILERFEATURES_FILLT( 8)>::emplace(const ARG& arg)
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>(arg);

    return bsl::get<index>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
template <class TYPE, class ARG>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03> >::value,
    TYPE&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              BSLS_COMPILERFEATURES_FILLT( 7)>::emplace(const ARG& arg)
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>(arg);

    return bsl::get<index>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
template <class TYPE, class ARG>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03,
                                                             TAIL_04> >::value,
    TYPE&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              BSLS_COMPILERFEATURES_FILLT( 6)>::emplace(const ARG& arg)
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>(arg);

    return bsl::get<index>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
template <class TYPE, class ARG>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03,
                                                             TAIL_04,
                                                             TAIL_05> >::value,
    TYPE&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              BSLS_COMPILERFEATURES_FILLT( 5)>::emplace(const ARG& arg)
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>(arg);

    return bsl::get<index>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
template <class TYPE, class ARG>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03,
                                                             TAIL_04,
                                                             TAIL_05,
                                                             TAIL_06> >::value,
    TYPE&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              BSLS_COMPILERFEATURES_FILLT( 4)>::emplace(const ARG& arg)
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>(arg);

    return bsl::get<index>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
template <class TYPE, class ARG>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03,
                                                             TAIL_04,
                                                             TAIL_05,
                                                             TAIL_06,
                                                             TAIL_07> >::value,
    TYPE&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              BSLS_COMPILERFEATURES_FILLT( 3)>::emplace(const ARG& arg)
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>(arg);

    return bsl::get<index>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
template <class TYPE, class ARG>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03,
                                                             TAIL_04,
                                                             TAIL_05,
                                                             TAIL_06,
                                                             TAIL_07,
                                                             TAIL_08> >::value,
    TYPE&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              BSLS_COMPILERFEATURES_FILLT( 2)>::emplace(const ARG& arg)
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>(arg);

    return bsl::get<index>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
template <class TYPE, class ARG>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03,
                                                             TAIL_04,
                                                             TAIL_05,
                                                             TAIL_06,
                                                             TAIL_07,
                                                             TAIL_08,
                                                             TAIL_09> >::value,
    TYPE&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              BSLS_COMPILERFEATURES_FILLT( 1)>::emplace(const ARG& arg)
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>(arg);

    return bsl::get<index>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
template <class TYPE, class ARG>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD, TAIL_01,
                                                             TAIL_02,
                                                             TAIL_03,
                                                             TAIL_04,
                                                             TAIL_05,
                                                             TAIL_06,
                                                             TAIL_07,
                                                             TAIL_08,
                                                             TAIL_09,
                                                             TAIL_10> >::value,
    TYPE&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10,
              BSLS_COMPILERFEATURES_FILLT( 0)>::emplace(const ARG& arg)
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>(arg);

    return bsl::get<index>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 0
template <class HEAD>
template <size_t INDEX>
typename variant_alternative<INDEX, variant<HEAD> >::type&
variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::emplace()
{
    Variant_Base::template baseEmplace<INDEX>();

    return bsl::get<INDEX>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 1
template <class HEAD, class TAIL_01>
template <size_t INDEX>
typename variant_alternative<INDEX, variant<HEAD, TAIL_01> >::type&
variant<HEAD, TAIL_01,
              BSLS_COMPILERFEATURES_FILLT( 9)>::emplace()
{
    Variant_Base::template baseEmplace<INDEX>();

    return bsl::get<INDEX>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
template <size_t INDEX>
typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                  TAIL_02> >::type&
variant<HEAD, TAIL_01,
              TAIL_02,
              BSLS_COMPILERFEATURES_FILLT( 8)>::emplace()
{
    Variant_Base::template baseEmplace<INDEX>();

    return bsl::get<INDEX>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
template <size_t INDEX>
typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03> >::type&
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              BSLS_COMPILERFEATURES_FILLT( 7)>::emplace()
{
    Variant_Base::template baseEmplace<INDEX>();

    return bsl::get<INDEX>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
template <size_t INDEX>
typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04> >::type&
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              BSLS_COMPILERFEATURES_FILLT( 6)>::emplace()
{
    Variant_Base::template baseEmplace<INDEX>();

    return bsl::get<INDEX>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
template <size_t INDEX>
typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05> >::type&
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              BSLS_COMPILERFEATURES_FILLT( 5)>::emplace()
{
    Variant_Base::template baseEmplace<INDEX>();

    return bsl::get<INDEX>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
template <size_t INDEX>
typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06> >::type&
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              BSLS_COMPILERFEATURES_FILLT( 4)>::emplace()
{
    Variant_Base::template baseEmplace<INDEX>();

    return bsl::get<INDEX>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
template <size_t INDEX>
typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06,
                                                  TAIL_07> >::type&
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              BSLS_COMPILERFEATURES_FILLT( 3)>::emplace()
{
    Variant_Base::template baseEmplace<INDEX>();

    return bsl::get<INDEX>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
template <size_t INDEX>
typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06,
                                                  TAIL_07,
                                                  TAIL_08> >::type&
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              BSLS_COMPILERFEATURES_FILLT( 2)>::emplace()
{
    Variant_Base::template baseEmplace<INDEX>();

    return bsl::get<INDEX>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
template <size_t INDEX>
typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06,
                                                  TAIL_07,
                                                  TAIL_08,
                                                  TAIL_09> >::type&
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              BSLS_COMPILERFEATURES_FILLT( 1)>::emplace()
{
    Variant_Base::template baseEmplace<INDEX>();

    return bsl::get<INDEX>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
template <size_t INDEX>
typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06,
                                                  TAIL_07,
                                                  TAIL_08,
                                                  TAIL_09,
                                                  TAIL_10> >::type&
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10,
              BSLS_COMPILERFEATURES_FILLT( 0)>::emplace()
{
    Variant_Base::template baseEmplace<INDEX>();

    return bsl::get<INDEX>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 0
template <class HEAD>
template <size_t INDEX, class ARG>
typename variant_alternative<INDEX, variant<HEAD> >::type&
variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::emplace(const ARG& arg)
{
    Variant_Base::template baseEmplace<INDEX>(arg);

    return bsl::get<INDEX>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 1
template <class HEAD, class TAIL_01>
template <size_t INDEX, class ARG>
typename variant_alternative<INDEX, variant<HEAD, TAIL_01> >::type&
variant<HEAD, TAIL_01,
              BSLS_COMPILERFEATURES_FILLT( 9)>::emplace(const ARG& arg)
{
    Variant_Base::template baseEmplace<INDEX>(arg);

    return bsl::get<INDEX>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
template <size_t INDEX, class ARG>
typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                  TAIL_02> >::type&
variant<HEAD, TAIL_01,
              TAIL_02,
              BSLS_COMPILERFEATURES_FILLT( 8)>::emplace(const ARG& arg)
{
    Variant_Base::template baseEmplace<INDEX>(arg);

    return bsl::get<INDEX>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
template <size_t INDEX, class ARG>
typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03> >::type&
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              BSLS_COMPILERFEATURES_FILLT( 7)>::emplace(const ARG& arg)
{
    Variant_Base::template baseEmplace<INDEX>(arg);

    return bsl::get<INDEX>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
template <size_t INDEX, class ARG>
typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04> >::type&
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              BSLS_COMPILERFEATURES_FILLT( 6)>::emplace(const ARG& arg)
{
    Variant_Base::template baseEmplace<INDEX>(arg);

    return bsl::get<INDEX>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
template <size_t INDEX, class ARG>
typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05> >::type&
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              BSLS_COMPILERFEATURES_FILLT( 5)>::emplace(const ARG& arg)
{
    Variant_Base::template baseEmplace<INDEX>(arg);

    return bsl::get<INDEX>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
template <size_t INDEX, class ARG>
typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06> >::type&
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              BSLS_COMPILERFEATURES_FILLT( 4)>::emplace(const ARG& arg)
{
    Variant_Base::template baseEmplace<INDEX>(arg);

    return bsl::get<INDEX>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
template <size_t INDEX, class ARG>
typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06,
                                                  TAIL_07> >::type&
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              BSLS_COMPILERFEATURES_FILLT( 3)>::emplace(const ARG& arg)
{
    Variant_Base::template baseEmplace<INDEX>(arg);

    return bsl::get<INDEX>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
template <size_t INDEX, class ARG>
typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06,
                                                  TAIL_07,
                                                  TAIL_08> >::type&
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              BSLS_COMPILERFEATURES_FILLT( 2)>::emplace(const ARG& arg)
{
    Variant_Base::template baseEmplace<INDEX>(arg);

    return bsl::get<INDEX>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
template <size_t INDEX, class ARG>
typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06,
                                                  TAIL_07,
                                                  TAIL_08,
                                                  TAIL_09> >::type&
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              BSLS_COMPILERFEATURES_FILLT( 1)>::emplace(const ARG& arg)
{
    Variant_Base::template baseEmplace<INDEX>(arg);

    return bsl::get<INDEX>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
template <size_t INDEX, class ARG>
typename variant_alternative<INDEX, variant<HEAD, TAIL_01,
                                                  TAIL_02,
                                                  TAIL_03,
                                                  TAIL_04,
                                                  TAIL_05,
                                                  TAIL_06,
                                                  TAIL_07,
                                                  TAIL_08,
                                                  TAIL_09,
                                                  TAIL_10> >::type&
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10,
              BSLS_COMPILERFEATURES_FILLT( 0)>::emplace(const ARG& arg)
{
    Variant_Base::template baseEmplace<INDEX>(arg);

    return bsl::get<INDEX>(*this);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 10

#endif

#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 0
template <class HEAD>
inline
variant<HEAD>& variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)
                             >::operator=(const variant& rhs)
{
    Variant_Base::operator=(static_cast<const Variant_Base&>(rhs));
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 1
template <class HEAD, class TAIL_01>
inline
variant<HEAD, TAIL_01>& variant<HEAD, TAIL_01,
                                      BSLS_COMPILERFEATURES_FILLT( 9)
                                      >::operator=(const variant& rhs)
{
    Variant_Base::operator=(static_cast<const Variant_Base&>(rhs));
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
inline
variant<HEAD, TAIL_01,
              TAIL_02>& variant<HEAD, TAIL_01,
                                      TAIL_02,
                                      BSLS_COMPILERFEATURES_FILLT( 8)
                                      >::operator=(const variant& rhs)
{
    Variant_Base::operator=(static_cast<const Variant_Base&>(rhs));
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03>& variant<HEAD, TAIL_01,
                                      TAIL_02,
                                      TAIL_03,
                                      BSLS_COMPILERFEATURES_FILLT( 7)
                                      >::operator=(const variant& rhs)
{
    Variant_Base::operator=(static_cast<const Variant_Base&>(rhs));
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04>& variant<HEAD, TAIL_01,
                                      TAIL_02,
                                      TAIL_03,
                                      TAIL_04,
                                      BSLS_COMPILERFEATURES_FILLT( 6)
                                      >::operator=(const variant& rhs)
{
    Variant_Base::operator=(static_cast<const Variant_Base&>(rhs));
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05>& variant<HEAD, TAIL_01,
                                      TAIL_02,
                                      TAIL_03,
                                      TAIL_04,
                                      TAIL_05,
                                      BSLS_COMPILERFEATURES_FILLT( 5)
                                      >::operator=(const variant& rhs)
{
    Variant_Base::operator=(static_cast<const Variant_Base&>(rhs));
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06>& variant<HEAD, TAIL_01,
                                      TAIL_02,
                                      TAIL_03,
                                      TAIL_04,
                                      TAIL_05,
                                      TAIL_06,
                                      BSLS_COMPILERFEATURES_FILLT( 4)
                                      >::operator=(const variant& rhs)
{
    Variant_Base::operator=(static_cast<const Variant_Base&>(rhs));
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07>& variant<HEAD, TAIL_01,
                                      TAIL_02,
                                      TAIL_03,
                                      TAIL_04,
                                      TAIL_05,
                                      TAIL_06,
                                      TAIL_07,
                                      BSLS_COMPILERFEATURES_FILLT( 3)
                                      >::operator=(const variant& rhs)
{
    Variant_Base::operator=(static_cast<const Variant_Base&>(rhs));
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08>& variant<HEAD, TAIL_01,
                                      TAIL_02,
                                      TAIL_03,
                                      TAIL_04,
                                      TAIL_05,
                                      TAIL_06,
                                      TAIL_07,
                                      TAIL_08,
                                      BSLS_COMPILERFEATURES_FILLT( 2)
                                      >::operator=(const variant& rhs)
{
    Variant_Base::operator=(static_cast<const Variant_Base&>(rhs));
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09>& variant<HEAD, TAIL_01,
                                      TAIL_02,
                                      TAIL_03,
                                      TAIL_04,
                                      TAIL_05,
                                      TAIL_06,
                                      TAIL_07,
                                      TAIL_08,
                                      TAIL_09,
                                      BSLS_COMPILERFEATURES_FILLT( 1)
                                      >::operator=(const variant& rhs)
{
    Variant_Base::operator=(static_cast<const Variant_Base&>(rhs));
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10>& variant<HEAD, TAIL_01,
                                      TAIL_02,
                                      TAIL_03,
                                      TAIL_04,
                                      TAIL_05,
                                      TAIL_06,
                                      TAIL_07,
                                      TAIL_08,
                                      TAIL_09,
                                      TAIL_10,
                                      BSLS_COMPILERFEATURES_FILLT( 0)
                                      >::operator=(const variant& rhs)
{
    Variant_Base::operator=(static_cast<const Variant_Base&>(rhs));
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 0
template <class HEAD>
inline
variant<HEAD>& variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::operator=(
                                   BloombergLP::bslmf::MovableRef<variant> rhs)
{
    variant<HEAD>& lvalue = rhs;
    Variant_Base::operator=(
                           MoveUtil::move(static_cast<Variant_Base&>(lvalue)));
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 1
template <class HEAD, class TAIL_01>
inline
variant<HEAD, TAIL_01>& variant<HEAD, TAIL_01,
                                      BSLS_COMPILERFEATURES_FILLT( 9)
                                      >::operator=(
                                   BloombergLP::bslmf::MovableRef<variant> rhs)
{
    variant<HEAD, TAIL_01>& lvalue = rhs;
    Variant_Base::operator=(
                           MoveUtil::move(static_cast<Variant_Base&>(lvalue)));
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
inline
variant<HEAD, TAIL_01,
              TAIL_02>& variant<HEAD, TAIL_01,
                                      TAIL_02,
                                      BSLS_COMPILERFEATURES_FILLT( 8)
                                      >::operator=(
                                   BloombergLP::bslmf::MovableRef<variant> rhs)
{
    variant<HEAD, TAIL_01,
                  TAIL_02>& lvalue = rhs;
    Variant_Base::operator=(
                           MoveUtil::move(static_cast<Variant_Base&>(lvalue)));
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03>& variant<HEAD, TAIL_01,
                                      TAIL_02,
                                      TAIL_03,
                                      BSLS_COMPILERFEATURES_FILLT( 7)
                                      >::operator=(
                                   BloombergLP::bslmf::MovableRef<variant> rhs)
{
    variant<HEAD, TAIL_01,
                  TAIL_02,
                  TAIL_03>& lvalue = rhs;
    Variant_Base::operator=(
                           MoveUtil::move(static_cast<Variant_Base&>(lvalue)));
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04>& variant<HEAD, TAIL_01,
                                      TAIL_02,
                                      TAIL_03,
                                      TAIL_04,
                                      BSLS_COMPILERFEATURES_FILLT( 6)
                                      >::operator=(
                                   BloombergLP::bslmf::MovableRef<variant> rhs)
{
    variant<HEAD, TAIL_01,
                  TAIL_02,
                  TAIL_03,
                  TAIL_04>& lvalue = rhs;
    Variant_Base::operator=(
                           MoveUtil::move(static_cast<Variant_Base&>(lvalue)));
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05>& variant<HEAD, TAIL_01,
                                      TAIL_02,
                                      TAIL_03,
                                      TAIL_04,
                                      TAIL_05,
                                      BSLS_COMPILERFEATURES_FILLT( 5)
                                      >::operator=(
                                   BloombergLP::bslmf::MovableRef<variant> rhs)
{
    variant<HEAD, TAIL_01,
                  TAIL_02,
                  TAIL_03,
                  TAIL_04,
                  TAIL_05>& lvalue = rhs;
    Variant_Base::operator=(
                           MoveUtil::move(static_cast<Variant_Base&>(lvalue)));
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06>& variant<HEAD, TAIL_01,
                                      TAIL_02,
                                      TAIL_03,
                                      TAIL_04,
                                      TAIL_05,
                                      TAIL_06,
                                      BSLS_COMPILERFEATURES_FILLT( 4)
                                      >::operator=(
                                   BloombergLP::bslmf::MovableRef<variant> rhs)
{
    variant<HEAD, TAIL_01,
                  TAIL_02,
                  TAIL_03,
                  TAIL_04,
                  TAIL_05,
                  TAIL_06>& lvalue = rhs;
    Variant_Base::operator=(
                           MoveUtil::move(static_cast<Variant_Base&>(lvalue)));
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07>& variant<HEAD, TAIL_01,
                                      TAIL_02,
                                      TAIL_03,
                                      TAIL_04,
                                      TAIL_05,
                                      TAIL_06,
                                      TAIL_07,
                                      BSLS_COMPILERFEATURES_FILLT( 3)
                                      >::operator=(
                                   BloombergLP::bslmf::MovableRef<variant> rhs)
{
    variant<HEAD, TAIL_01,
                  TAIL_02,
                  TAIL_03,
                  TAIL_04,
                  TAIL_05,
                  TAIL_06,
                  TAIL_07>& lvalue = rhs;
    Variant_Base::operator=(
                           MoveUtil::move(static_cast<Variant_Base&>(lvalue)));
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08>& variant<HEAD, TAIL_01,
                                      TAIL_02,
                                      TAIL_03,
                                      TAIL_04,
                                      TAIL_05,
                                      TAIL_06,
                                      TAIL_07,
                                      TAIL_08,
                                      BSLS_COMPILERFEATURES_FILLT( 2)
                                      >::operator=(
                                   BloombergLP::bslmf::MovableRef<variant> rhs)
{
    variant<HEAD, TAIL_01,
                  TAIL_02,
                  TAIL_03,
                  TAIL_04,
                  TAIL_05,
                  TAIL_06,
                  TAIL_07,
                  TAIL_08>& lvalue = rhs;
    Variant_Base::operator=(
                           MoveUtil::move(static_cast<Variant_Base&>(lvalue)));
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09>& variant<HEAD, TAIL_01,
                                      TAIL_02,
                                      TAIL_03,
                                      TAIL_04,
                                      TAIL_05,
                                      TAIL_06,
                                      TAIL_07,
                                      TAIL_08,
                                      TAIL_09,
                                      BSLS_COMPILERFEATURES_FILLT( 1)
                                      >::operator=(
                                   BloombergLP::bslmf::MovableRef<variant> rhs)
{
    variant<HEAD, TAIL_01,
                  TAIL_02,
                  TAIL_03,
                  TAIL_04,
                  TAIL_05,
                  TAIL_06,
                  TAIL_07,
                  TAIL_08,
                  TAIL_09>& lvalue = rhs;
    Variant_Base::operator=(
                           MoveUtil::move(static_cast<Variant_Base&>(lvalue)));
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
inline
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10>& variant<HEAD, TAIL_01,
                                      TAIL_02,
                                      TAIL_03,
                                      TAIL_04,
                                      TAIL_05,
                                      TAIL_06,
                                      TAIL_07,
                                      TAIL_08,
                                      TAIL_09,
                                      TAIL_10,
                                      BSLS_COMPILERFEATURES_FILLT( 0)
                                      >::operator=(
                                   BloombergLP::bslmf::MovableRef<variant> rhs)
{
    variant<HEAD, TAIL_01,
                  TAIL_02,
                  TAIL_03,
                  TAIL_04,
                  TAIL_05,
                  TAIL_06,
                  TAIL_07,
                  TAIL_08,
                  TAIL_09,
                  TAIL_10>& lvalue = rhs;
    Variant_Base::operator=(
                           MoveUtil::move(static_cast<Variant_Base&>(lvalue)));
    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 10

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 0
template <class HEAD>
template <class TYPE>
inline
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_AssignsFromType<variant<HEAD>,
                                                 TYPE>::value,
    variant<HEAD>&>::type
variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::operator=(const TYPE& rhs)
{
    const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

    if (index() == altIndex) {
        bsl::get<altIndex>(*this) = rhs;
    } else {
        emplace<altIndex>(rhs);
    }

    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 1
template <class HEAD, class TAIL_01>
template <class TYPE>
inline
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_AssignsFromType<variant<HEAD, TAIL_01>,
                                                 TYPE>::value,
    variant<HEAD, TAIL_01>&>::type
variant<HEAD, TAIL_01,
              BSLS_COMPILERFEATURES_FILLT( 9)>::operator=(const TYPE& rhs)
{
    const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

    if (index() == altIndex) {
        bsl::get<altIndex>(*this) = rhs;
    } else {
        emplace<altIndex>(rhs);
    }

    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
template <class TYPE>
inline
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_AssignsFromType<variant<HEAD, TAIL_01,
                                                               TAIL_02>,
                                                 TYPE>::value,
    variant<HEAD, TAIL_01,
                  TAIL_02>&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              BSLS_COMPILERFEATURES_FILLT( 8)>::operator=(const TYPE& rhs)
{
    const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

    if (index() == altIndex) {
        bsl::get<altIndex>(*this) = rhs;
    } else {
        emplace<altIndex>(rhs);
    }

    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
template <class TYPE>
inline
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_AssignsFromType<variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03>,
                                                 TYPE>::value,
    variant<HEAD, TAIL_01,
                  TAIL_02,
                  TAIL_03>&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              BSLS_COMPILERFEATURES_FILLT( 7)>::operator=(const TYPE& rhs)
{
    const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

    if (index() == altIndex) {
        bsl::get<altIndex>(*this) = rhs;
    } else {
        emplace<altIndex>(rhs);
    }

    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
template <class TYPE>
inline
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_AssignsFromType<variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03,
                                                               TAIL_04>,
                                                 TYPE>::value,
    variant<HEAD, TAIL_01,
                  TAIL_02,
                  TAIL_03,
                  TAIL_04>&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              BSLS_COMPILERFEATURES_FILLT( 6)>::operator=(const TYPE& rhs)
{
    const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

    if (index() == altIndex) {
        bsl::get<altIndex>(*this) = rhs;
    } else {
        emplace<altIndex>(rhs);
    }

    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
template <class TYPE>
inline
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_AssignsFromType<variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03,
                                                               TAIL_04,
                                                               TAIL_05>,
                                                 TYPE>::value,
    variant<HEAD, TAIL_01,
                  TAIL_02,
                  TAIL_03,
                  TAIL_04,
                  TAIL_05>&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              BSLS_COMPILERFEATURES_FILLT( 5)>::operator=(const TYPE& rhs)
{
    const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

    if (index() == altIndex) {
        bsl::get<altIndex>(*this) = rhs;
    } else {
        emplace<altIndex>(rhs);
    }

    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
template <class TYPE>
inline
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_AssignsFromType<variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03,
                                                               TAIL_04,
                                                               TAIL_05,
                                                               TAIL_06>,
                                                 TYPE>::value,
    variant<HEAD, TAIL_01,
                  TAIL_02,
                  TAIL_03,
                  TAIL_04,
                  TAIL_05,
                  TAIL_06>&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              BSLS_COMPILERFEATURES_FILLT( 4)>::operator=(const TYPE& rhs)
{
    const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

    if (index() == altIndex) {
        bsl::get<altIndex>(*this) = rhs;
    } else {
        emplace<altIndex>(rhs);
    }

    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
template <class TYPE>
inline
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_AssignsFromType<variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03,
                                                               TAIL_04,
                                                               TAIL_05,
                                                               TAIL_06,
                                                               TAIL_07>,
                                                 TYPE>::value,
    variant<HEAD, TAIL_01,
                  TAIL_02,
                  TAIL_03,
                  TAIL_04,
                  TAIL_05,
                  TAIL_06,
                  TAIL_07>&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              BSLS_COMPILERFEATURES_FILLT( 3)>::operator=(const TYPE& rhs)
{
    const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

    if (index() == altIndex) {
        bsl::get<altIndex>(*this) = rhs;
    } else {
        emplace<altIndex>(rhs);
    }

    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
template <class TYPE>
inline
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_AssignsFromType<variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03,
                                                               TAIL_04,
                                                               TAIL_05,
                                                               TAIL_06,
                                                               TAIL_07,
                                                               TAIL_08>,
                                                 TYPE>::value,
    variant<HEAD, TAIL_01,
                  TAIL_02,
                  TAIL_03,
                  TAIL_04,
                  TAIL_05,
                  TAIL_06,
                  TAIL_07,
                  TAIL_08>&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              BSLS_COMPILERFEATURES_FILLT( 2)>::operator=(const TYPE& rhs)
{
    const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

    if (index() == altIndex) {
        bsl::get<altIndex>(*this) = rhs;
    } else {
        emplace<altIndex>(rhs);
    }

    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
template <class TYPE>
inline
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_AssignsFromType<variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03,
                                                               TAIL_04,
                                                               TAIL_05,
                                                               TAIL_06,
                                                               TAIL_07,
                                                               TAIL_08,
                                                               TAIL_09>,
                                                 TYPE>::value,
    variant<HEAD, TAIL_01,
                  TAIL_02,
                  TAIL_03,
                  TAIL_04,
                  TAIL_05,
                  TAIL_06,
                  TAIL_07,
                  TAIL_08,
                  TAIL_09>&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              BSLS_COMPILERFEATURES_FILLT( 1)>::operator=(const TYPE& rhs)
{
    const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

    if (index() == altIndex) {
        bsl::get<altIndex>(*this) = rhs;
    } else {
        emplace<altIndex>(rhs);
    }

    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
template <class TYPE>
inline
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_AssignsFromType<variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03,
                                                               TAIL_04,
                                                               TAIL_05,
                                                               TAIL_06,
                                                               TAIL_07,
                                                               TAIL_08,
                                                               TAIL_09,
                                                               TAIL_10>,
                                                 TYPE>::value,
    variant<HEAD, TAIL_01,
                  TAIL_02,
                  TAIL_03,
                  TAIL_04,
                  TAIL_05,
                  TAIL_06,
                  TAIL_07,
                  TAIL_08,
                  TAIL_09,
                  TAIL_10>&>::type
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10,
              BSLS_COMPILERFEATURES_FILLT( 0)>::operator=(const TYPE& rhs)
{
    const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

    if (index() == altIndex) {
        bsl::get<altIndex>(*this) = rhs;
    } else {
        emplace<altIndex>(rhs);
    }

    return *this;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 10


#endif
#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 0
template <class HEAD>
inline
void variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)>::swap(variant& other)
{
    if (!valueless_by_exception()) {
        if (index() == other.index()) {
            BloombergLP::bslstl::Variant_SwapVisitor<variant> swapper(this);
            BSLSTL_VARIANT_VISITID(void, swapper, other);
        }
        else {
            variant tmpThis(MoveUtil::move(*this));
            this->reset();
            if (!other.valueless_by_exception()) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
            }
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(BSLS_UTIL_ADDRESSOF(other));
            BSLSTL_VARIANT_VISITID(void, moveConstructor, tmpThis);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            other.d_type = tmpThis.index();
#endif
        }
    }
    else {
        if (!other.valueless_by_exception()) {
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(this);
            BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
        }
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 1
template <class HEAD, class TAIL_01>
inline
void variant<HEAD, TAIL_01,
                   BSLS_COMPILERFEATURES_FILLT( 9)>::swap(variant& other)
{
    if (!valueless_by_exception()) {
        if (index() == other.index()) {
            BloombergLP::bslstl::Variant_SwapVisitor<variant> swapper(this);
            BSLSTL_VARIANT_VISITID(void, swapper, other);
        }
        else {
            variant tmpThis(MoveUtil::move(*this));
            this->reset();
            if (!other.valueless_by_exception()) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
            }
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(BSLS_UTIL_ADDRESSOF(other));
            BSLSTL_VARIANT_VISITID(void, moveConstructor, tmpThis);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            other.d_type = tmpThis.index();
#endif
        }
    }
    else {
        if (!other.valueless_by_exception()) {
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(this);
            BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
        }
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
inline
void variant<HEAD, TAIL_01,
                   TAIL_02,
                   BSLS_COMPILERFEATURES_FILLT( 8)>::swap(variant& other)
{
    if (!valueless_by_exception()) {
        if (index() == other.index()) {
            BloombergLP::bslstl::Variant_SwapVisitor<variant> swapper(this);
            BSLSTL_VARIANT_VISITID(void, swapper, other);
        }
        else {
            variant tmpThis(MoveUtil::move(*this));
            this->reset();
            if (!other.valueless_by_exception()) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
            }
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(BSLS_UTIL_ADDRESSOF(other));
            BSLSTL_VARIANT_VISITID(void, moveConstructor, tmpThis);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            other.d_type = tmpThis.index();
#endif
        }
    }
    else {
        if (!other.valueless_by_exception()) {
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(this);
            BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
        }
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
inline
void variant<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   BSLS_COMPILERFEATURES_FILLT( 7)>::swap(variant& other)
{
    if (!valueless_by_exception()) {
        if (index() == other.index()) {
            BloombergLP::bslstl::Variant_SwapVisitor<variant> swapper(this);
            BSLSTL_VARIANT_VISITID(void, swapper, other);
        }
        else {
            variant tmpThis(MoveUtil::move(*this));
            this->reset();
            if (!other.valueless_by_exception()) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
            }
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(BSLS_UTIL_ADDRESSOF(other));
            BSLSTL_VARIANT_VISITID(void, moveConstructor, tmpThis);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            other.d_type = tmpThis.index();
#endif
        }
    }
    else {
        if (!other.valueless_by_exception()) {
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(this);
            BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
        }
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
inline
void variant<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   BSLS_COMPILERFEATURES_FILLT( 6)>::swap(variant& other)
{
    if (!valueless_by_exception()) {
        if (index() == other.index()) {
            BloombergLP::bslstl::Variant_SwapVisitor<variant> swapper(this);
            BSLSTL_VARIANT_VISITID(void, swapper, other);
        }
        else {
            variant tmpThis(MoveUtil::move(*this));
            this->reset();
            if (!other.valueless_by_exception()) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
            }
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(BSLS_UTIL_ADDRESSOF(other));
            BSLSTL_VARIANT_VISITID(void, moveConstructor, tmpThis);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            other.d_type = tmpThis.index();
#endif
        }
    }
    else {
        if (!other.valueless_by_exception()) {
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(this);
            BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
        }
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
inline
void variant<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   BSLS_COMPILERFEATURES_FILLT( 5)>::swap(variant& other)
{
    if (!valueless_by_exception()) {
        if (index() == other.index()) {
            BloombergLP::bslstl::Variant_SwapVisitor<variant> swapper(this);
            BSLSTL_VARIANT_VISITID(void, swapper, other);
        }
        else {
            variant tmpThis(MoveUtil::move(*this));
            this->reset();
            if (!other.valueless_by_exception()) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
            }
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(BSLS_UTIL_ADDRESSOF(other));
            BSLSTL_VARIANT_VISITID(void, moveConstructor, tmpThis);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            other.d_type = tmpThis.index();
#endif
        }
    }
    else {
        if (!other.valueless_by_exception()) {
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(this);
            BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
        }
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
inline
void variant<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   BSLS_COMPILERFEATURES_FILLT( 4)>::swap(variant& other)
{
    if (!valueless_by_exception()) {
        if (index() == other.index()) {
            BloombergLP::bslstl::Variant_SwapVisitor<variant> swapper(this);
            BSLSTL_VARIANT_VISITID(void, swapper, other);
        }
        else {
            variant tmpThis(MoveUtil::move(*this));
            this->reset();
            if (!other.valueless_by_exception()) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
            }
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(BSLS_UTIL_ADDRESSOF(other));
            BSLSTL_VARIANT_VISITID(void, moveConstructor, tmpThis);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            other.d_type = tmpThis.index();
#endif
        }
    }
    else {
        if (!other.valueless_by_exception()) {
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(this);
            BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
        }
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
inline
void variant<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   BSLS_COMPILERFEATURES_FILLT( 3)>::swap(variant& other)
{
    if (!valueless_by_exception()) {
        if (index() == other.index()) {
            BloombergLP::bslstl::Variant_SwapVisitor<variant> swapper(this);
            BSLSTL_VARIANT_VISITID(void, swapper, other);
        }
        else {
            variant tmpThis(MoveUtil::move(*this));
            this->reset();
            if (!other.valueless_by_exception()) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
            }
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(BSLS_UTIL_ADDRESSOF(other));
            BSLSTL_VARIANT_VISITID(void, moveConstructor, tmpThis);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            other.d_type = tmpThis.index();
#endif
        }
    }
    else {
        if (!other.valueless_by_exception()) {
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(this);
            BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
        }
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
inline
void variant<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   BSLS_COMPILERFEATURES_FILLT( 2)>::swap(variant& other)
{
    if (!valueless_by_exception()) {
        if (index() == other.index()) {
            BloombergLP::bslstl::Variant_SwapVisitor<variant> swapper(this);
            BSLSTL_VARIANT_VISITID(void, swapper, other);
        }
        else {
            variant tmpThis(MoveUtil::move(*this));
            this->reset();
            if (!other.valueless_by_exception()) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
            }
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(BSLS_UTIL_ADDRESSOF(other));
            BSLSTL_VARIANT_VISITID(void, moveConstructor, tmpThis);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            other.d_type = tmpThis.index();
#endif
        }
    }
    else {
        if (!other.valueless_by_exception()) {
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(this);
            BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
        }
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
inline
void variant<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   BSLS_COMPILERFEATURES_FILLT( 1)>::swap(variant& other)
{
    if (!valueless_by_exception()) {
        if (index() == other.index()) {
            BloombergLP::bslstl::Variant_SwapVisitor<variant> swapper(this);
            BSLSTL_VARIANT_VISITID(void, swapper, other);
        }
        else {
            variant tmpThis(MoveUtil::move(*this));
            this->reset();
            if (!other.valueless_by_exception()) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
            }
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(BSLS_UTIL_ADDRESSOF(other));
            BSLSTL_VARIANT_VISITID(void, moveConstructor, tmpThis);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            other.d_type = tmpThis.index();
#endif
        }
    }
    else {
        if (!other.valueless_by_exception()) {
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(this);
            BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
        }
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
inline
void variant<HEAD, TAIL_01,
                   TAIL_02,
                   TAIL_03,
                   TAIL_04,
                   TAIL_05,
                   TAIL_06,
                   TAIL_07,
                   TAIL_08,
                   TAIL_09,
                   TAIL_10,
                   BSLS_COMPILERFEATURES_FILLT( 0)>::swap(variant& other)
{
    if (!valueless_by_exception()) {
        if (index() == other.index()) {
            BloombergLP::bslstl::Variant_SwapVisitor<variant> swapper(this);
            BSLSTL_VARIANT_VISITID(void, swapper, other);
        }
        else {
            variant tmpThis(MoveUtil::move(*this));
            this->reset();
            if (!other.valueless_by_exception()) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
            }
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(BSLS_UTIL_ADDRESSOF(other));
            BSLSTL_VARIANT_VISITID(void, moveConstructor, tmpThis);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            other.d_type = tmpThis.index();
#endif
        }
    }
    else {
        if (!other.valueless_by_exception()) {
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(this);
            BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
        }
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 0
template <class HEAD>
inline
size_t variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)
                     >::index() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 1
template <class HEAD, class TAIL_01>
inline
size_t variant<HEAD, TAIL_01,
                     BSLS_COMPILERFEATURES_FILLT( 9)
                     >::index() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
inline
size_t variant<HEAD, TAIL_01,
                     TAIL_02,
                     BSLS_COMPILERFEATURES_FILLT( 8)
                     >::index() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
inline
size_t variant<HEAD, TAIL_01,
                     TAIL_02,
                     TAIL_03,
                     BSLS_COMPILERFEATURES_FILLT( 7)
                     >::index() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
inline
size_t variant<HEAD, TAIL_01,
                     TAIL_02,
                     TAIL_03,
                     TAIL_04,
                     BSLS_COMPILERFEATURES_FILLT( 6)
                     >::index() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
inline
size_t variant<HEAD, TAIL_01,
                     TAIL_02,
                     TAIL_03,
                     TAIL_04,
                     TAIL_05,
                     BSLS_COMPILERFEATURES_FILLT( 5)
                     >::index() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
inline
size_t variant<HEAD, TAIL_01,
                     TAIL_02,
                     TAIL_03,
                     TAIL_04,
                     TAIL_05,
                     TAIL_06,
                     BSLS_COMPILERFEATURES_FILLT( 4)
                     >::index() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
inline
size_t variant<HEAD, TAIL_01,
                     TAIL_02,
                     TAIL_03,
                     TAIL_04,
                     TAIL_05,
                     TAIL_06,
                     TAIL_07,
                     BSLS_COMPILERFEATURES_FILLT( 3)
                     >::index() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
inline
size_t variant<HEAD, TAIL_01,
                     TAIL_02,
                     TAIL_03,
                     TAIL_04,
                     TAIL_05,
                     TAIL_06,
                     TAIL_07,
                     TAIL_08,
                     BSLS_COMPILERFEATURES_FILLT( 2)
                     >::index() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
inline
size_t variant<HEAD, TAIL_01,
                     TAIL_02,
                     TAIL_03,
                     TAIL_04,
                     TAIL_05,
                     TAIL_06,
                     TAIL_07,
                     TAIL_08,
                     TAIL_09,
                     BSLS_COMPILERFEATURES_FILLT( 1)
                     >::index() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
inline
size_t variant<HEAD, TAIL_01,
                     TAIL_02,
                     TAIL_03,
                     TAIL_04,
                     TAIL_05,
                     TAIL_06,
                     TAIL_07,
                     TAIL_08,
                     TAIL_09,
                     TAIL_10,
                     BSLS_COMPILERFEATURES_FILLT( 0)
                     >::index() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 0
template <class HEAD>
inline
bool
variant<HEAD, BSLS_COMPILERFEATURES_FILLT(10)
              >::valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type == bsl::variant_npos;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 1
template <class HEAD, class TAIL_01>
inline
bool
variant<HEAD, TAIL_01,
              BSLS_COMPILERFEATURES_FILLT( 9)
              >::valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type == bsl::variant_npos;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
inline
bool
variant<HEAD, TAIL_01,
              TAIL_02,
              BSLS_COMPILERFEATURES_FILLT( 8)
              >::valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type == bsl::variant_npos;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
inline
bool
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              BSLS_COMPILERFEATURES_FILLT( 7)
              >::valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type == bsl::variant_npos;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
inline
bool
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              BSLS_COMPILERFEATURES_FILLT( 6)
              >::valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type == bsl::variant_npos;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
inline
bool
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              BSLS_COMPILERFEATURES_FILLT( 5)
              >::valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type == bsl::variant_npos;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
inline
bool
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              BSLS_COMPILERFEATURES_FILLT( 4)
              >::valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type == bsl::variant_npos;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
inline
bool
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              BSLS_COMPILERFEATURES_FILLT( 3)
              >::valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type == bsl::variant_npos;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
inline
bool
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              BSLS_COMPILERFEATURES_FILLT( 2)
              >::valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type == bsl::variant_npos;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
inline
bool
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              BSLS_COMPILERFEATURES_FILLT( 1)
              >::valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type == bsl::variant_npos;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
inline
bool
variant<HEAD, TAIL_01,
              TAIL_02,
              TAIL_03,
              TAIL_04,
              TAIL_05,
              TAIL_06,
              TAIL_07,
              TAIL_08,
              TAIL_09,
              TAIL_10,
              BSLS_COMPILERFEATURES_FILLT( 0)
              >::valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type == bsl::variant_npos;
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_P >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
template <class HEAD, class... TAIL>
template <class TYPE>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD, TAIL...> >::value,
    TYPE&>::type
variant<HEAD, TAIL...>::emplace()
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>();

    return bsl::get<index>(*this);
}

template <class HEAD, class... TAIL>
template <class TYPE, class ARG>
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_HasUniqueType<TYPE,
                                               variant<HEAD, TAIL...> >::value,
    TYPE&>::type
variant<HEAD, TAIL...>::emplace(const ARG& arg)
{
    const size_t index = BSLSTL_VARIANT_INDEX_OF(TYPE, variant);

    Variant_Base::template baseEmplace<index>(arg);

    return bsl::get<index>(*this);
}

template <class HEAD, class... TAIL>
template <size_t INDEX>
typename variant_alternative<INDEX, variant<HEAD, TAIL...> >::type&
variant<HEAD, TAIL...>::emplace()
{
    Variant_Base::template baseEmplace<INDEX>();

    return bsl::get<INDEX>(*this);
}

template <class HEAD, class... TAIL>
template <size_t INDEX, class ARG>
typename variant_alternative<INDEX, variant<HEAD, TAIL...> >::type&
variant<HEAD, TAIL...>::emplace(const ARG& arg)
{
    Variant_Base::template baseEmplace<INDEX>(arg);

    return bsl::get<INDEX>(*this);
}
#endif

#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
template <class HEAD, class... TAIL>
inline
variant<HEAD, TAIL...>& variant<HEAD, TAIL...>::operator=(const variant& rhs)
{
    Variant_Base::operator=(static_cast<const Variant_Base&>(rhs));
    return *this;
}

template <class HEAD, class... TAIL>
inline
variant<HEAD, TAIL...>& variant<HEAD, TAIL...>::operator=(
                                   BloombergLP::bslmf::MovableRef<variant> rhs)
{
    variant<HEAD, TAIL...>& lvalue = rhs;
    Variant_Base::operator=(
                           MoveUtil::move(static_cast<Variant_Base&>(lvalue)));
    return *this;
}
template <class HEAD, class... TAIL>
template <class TYPE>
inline
typename bsl::enable_if<
    BloombergLP::bslstl::Variant_AssignsFromType<variant<HEAD, TAIL...>,
                                                 TYPE>::value,
    variant<HEAD, TAIL...>&>::type
variant<HEAD, TAIL...>::operator=(const TYPE& rhs)
{
    const size_t altIndex = BSLSTL_VARIANT_CONVERT_INDEX_OF(TYPE, variant);

    if (index() == altIndex) {
        bsl::get<altIndex>(*this) = rhs;
    } else {
        emplace<altIndex>(rhs);
    }

    return *this;
}

#endif
template <class HEAD, class... TAIL>
inline
void variant<HEAD, TAIL...>::swap(variant& other)
{
    if (!valueless_by_exception()) {
        if (index() == other.index()) {
            BloombergLP::bslstl::Variant_SwapVisitor<variant> swapper(this);
            BSLSTL_VARIANT_VISITID(void, swapper, other);
        }
        else {
            variant tmpThis(MoveUtil::move(*this));
            this->reset();
            if (!other.valueless_by_exception()) {
                BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                    moveConstructor(this);
                BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
            }
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(BSLS_UTIL_ADDRESSOF(other));
            BSLSTL_VARIANT_VISITID(void, moveConstructor, tmpThis);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            other.d_type = tmpThis.index();
#endif
        }
    }
    else {
        if (!other.valueless_by_exception()) {
            BloombergLP::bslstl::Variant_MoveConstructVisitor<Variant_Base>
                moveConstructor(this);
            BSLSTL_VARIANT_VISITID(void, moveConstructor, other);
#ifndef BSL_VARIANT_FULL_IMPLEMENTATION
            this->d_type = other.index();
#endif
            other.reset();
        }
    }
}

template <class HEAD, class... TAIL>
inline
size_t variant<HEAD, TAIL...>::index() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type;
}

template <class HEAD, class... TAIL>
inline
bool
variant<HEAD, TAIL...>::valueless_by_exception() const BSLS_KEYWORD_NOEXCEPT
{
    return this->d_type == bsl::variant_npos;
}

// }}} END GENERATED CODE
#endif
// FREE FUNCTIONS
#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
template <size_t INDEX, class HEAD, class... TAIL>
typename variant_alternative<INDEX, variant<HEAD, TAIL...> >::type& get(
                                                   variant<HEAD, TAIL...>& obj)
{
    BSLMF_ASSERT((INDEX < variant_size<variant<HEAD, TAIL...> >::value));

    typedef typename bsl::variant<HEAD, TAIL...>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    typedef typename bsl::variant_alternative<INDEX, Variant>::type Ret;

    return Var_ImpUtil::template getImpl<Ret>(bsl::in_place_index_t<INDEX>(),
                                              obj);
}

template <size_t INDEX, class HEAD, class... TAIL>
const typename variant_alternative<INDEX, variant<HEAD, TAIL...> >::type& get(
                                             const variant<HEAD, TAIL...>& obj)
{
    BSLMF_ASSERT((INDEX < variant_size<variant<HEAD, TAIL...> >::value));

    typedef typename bsl::variant<HEAD, TAIL...>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    typedef typename bsl::variant_alternative<INDEX, Variant>::type Ret;

    return Var_ImpUtil::template getImpl<const Ret>(
                                                bsl::in_place_index_t<INDEX>(),
                                                obj);
}

template <size_t INDEX, class HEAD, class... TAIL>
typename variant_alternative<INDEX, variant<HEAD, TAIL...> >::type&& get(
                                                  variant<HEAD, TAIL...>&& obj)
{
    BSLMF_ASSERT((INDEX < variant_size<variant<HEAD, TAIL...> >::value));

    typedef typename bsl::variant<HEAD, TAIL...>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    typedef typename bsl::variant_alternative<INDEX, Variant>::type Ret;

    return std::move(Var_ImpUtil::template getImpl<Ret>(
                                                bsl::in_place_index_t<INDEX>(),
                                                obj));
}

template <size_t INDEX, class HEAD, class... TAIL>
const typename variant_alternative<INDEX, variant<HEAD, TAIL...> >::type&& get(
                                            const variant<HEAD, TAIL...>&& obj)
{
    BSLMF_ASSERT((INDEX < variant_size<variant<HEAD, TAIL...> >::value));

    typedef typename bsl::variant<HEAD, TAIL...>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    typedef typename bsl::variant_alternative<INDEX, Variant>::type Ret;

    return std::move(Var_ImpUtil::template getImpl<const Ret>(
                                                bsl::in_place_index_t<INDEX>(),
                                                obj));
}
#else  // BSL_VARIANT_FULL_IMPLEMENTATION
// {{{ BEGIN GENERATED CODE
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <size_t INDEX, class VARIANT>
typename Variant_ReturnType<
    typename variant_alternative<INDEX, VARIANT>::type&,
    VARIANT>::type
get(VARIANT& obj)
{
    BSLMF_ASSERT((INDEX < variant_size<VARIANT>::value));

    typedef typename BloombergLP::bslstl::Variant_ImpUtil<VARIANT> Var_ImpUtil;

    typedef typename bsl::variant_alternative<INDEX, VARIANT>::type Ret;

    return Var_ImpUtil::template getImpl<Ret>(bsl::in_place_index_t<INDEX>(),
                                              obj);
}

template <size_t INDEX, class VARIANT>
typename Variant_ReturnType<
    const typename variant_alternative<INDEX, VARIANT>::type&,
    VARIANT>::type
get(const VARIANT& obj)
{
    BSLMF_ASSERT((INDEX < variant_size<VARIANT>::value));

    typedef typename BloombergLP::bslstl::Variant_ImpUtil<VARIANT> Var_ImpUtil;

    typedef typename bsl::variant_alternative<INDEX, VARIANT>::type Ret;

    return Var_ImpUtil::template getImpl<const Ret>(
                                                bsl::in_place_index_t<INDEX>(),
                                                obj);
}

template <size_t INDEX, class VARIANT>
typename Variant_ReturnType<
    BloombergLP::bslmf::MovableRef<
        typename variant_alternative<INDEX, VARIANT>::type>,
    VARIANT>::type
get(BloombergLP::bslmf::MovableRef<VARIANT> obj)
{
    typedef BloombergLP::bslmf::MovableRefUtil                     MoveUtil;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<VARIANT> Var_ImpUtil;

    typedef typename bsl::variant_alternative<INDEX, VARIANT>::type Ret;

    VARIANT& lvalue = obj;

    return MoveUtil::move(Var_ImpUtil::template getImpl<Ret>(
                                                bsl::in_place_index_t<INDEX>(),
                                                lvalue));
}
// }}} END GENERATED CODE
#endif  // BSL_VARIANT_FULL_IMPLEMENTATION

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
template <class TYPE, class HEAD, class... TAIL>
TYPE& get(variant<HEAD, TAIL...>& obj)
{
    BSLMF_ASSERT(
            (BloombergLP::bslstl::
                 Variant_HasUniqueType<TYPE, variant<HEAD, TAIL...> >::value));

    typedef typename bsl::variant<HEAD, TAIL...>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template getImpl<TYPE>(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(),
               obj);
}

template <class TYPE, class HEAD, class... TAIL>
const TYPE& get(const variant<HEAD, TAIL...>& obj)
{
    BSLMF_ASSERT(
            (BloombergLP::bslstl::
                 Variant_HasUniqueType<TYPE, variant<HEAD, TAIL...> >::value));

    typedef typename bsl::variant<HEAD, TAIL...>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return Var_ImpUtil::template getImpl<const TYPE>(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(),
               obj);
}

template <class TYPE, class HEAD, class... TAIL>
TYPE&& get(variant<HEAD, TAIL...>&& obj)
{
    static_assert(
               BloombergLP::bslstl::
                   Variant_HasUniqueType<TYPE, variant<HEAD, TAIL...> >::value,
               "Type is not unique in variant");

    typedef typename bsl::variant<HEAD, TAIL...>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return std::move(Var_ImpUtil::template getImpl<TYPE>(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(),
               obj));
}

template <class TYPE, class HEAD, class... TAIL>
const TYPE&& get(const variant<HEAD, TAIL...>&& obj)
{
    static_assert(
               BloombergLP::bslstl::
                   Variant_HasUniqueType<TYPE, variant<HEAD, TAIL...> >::value,
               "Type is not unique in variant");

    typedef typename bsl::variant<HEAD, TAIL...>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    return std::move(Var_ImpUtil::template getImpl<const TYPE>(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(),
               obj));
}
#else   // BSL_VARIANT_FULL_IMPLEMENTATION
// {{{ BEGIN GENERATED CODE
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class TYPE, class VARIANT>
typename Variant_ReturnType<TYPE&, VARIANT>::type get(VARIANT& obj)
{
    BSLMF_ASSERT(
           (BloombergLP::bslstl::Variant_HasUniqueType<TYPE, VARIANT>::value));

    typedef typename BloombergLP::bslstl::Variant_ImpUtil<VARIANT> Var_ImpUtil;

    return Var_ImpUtil::template getImpl<TYPE>(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, VARIANT)>(),
               obj);
}

template <class TYPE, class VARIANT>
typename Variant_ReturnType<const TYPE&, VARIANT>::type get(const VARIANT& obj)
{
    BSLMF_ASSERT(
           (BloombergLP::bslstl::Variant_HasUniqueType<TYPE, VARIANT>::value));

    typedef typename BloombergLP::bslstl::Variant_ImpUtil<VARIANT> Var_ImpUtil;

    return Var_ImpUtil::template getImpl<const TYPE>(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, VARIANT)>(),
               obj);
}

template <class TYPE, class VARIANT>
typename Variant_ReturnType<BloombergLP::bslmf::MovableRef<TYPE>,
                            VARIANT>::type
get(BloombergLP::bslmf::MovableRef<VARIANT> obj)
{
    BSLMF_ASSERT(
           (BloombergLP::bslstl::Variant_HasUniqueType<TYPE, VARIANT>::value));

    typedef BloombergLP::bslmf::MovableRefUtil                     MoveUtil;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<VARIANT> Var_ImpUtil;

    VARIANT& lvalue = obj;
    return MoveUtil::move(Var_ImpUtil::template getImpl<TYPE>(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, VARIANT)>(),
               lvalue));
}
// }}} END GENERATED CODE
#endif  // BSL_VARIANT_FULL_IMPLEMENTATION

#ifdef BSL_VARIANT_FULL_IMPLEMENTATION
template <size_t INDEX, class HEAD, class... TAIL>
typename add_pointer<
    typename variant_alternative<INDEX, variant<HEAD, TAIL...> >::type>::type
get_if(variant<HEAD, TAIL...> *ptr) BSLS_KEYWORD_NOEXCEPT
{
    BSLMF_ASSERT((INDEX < variant_size<variant<HEAD, TAIL...> >::value));

    typedef typename bsl::variant<HEAD, TAIL...>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    typedef typename bsl::variant_alternative<INDEX, Variant>::type Ret;

    if (ptr == 0 || ptr->index() != INDEX) {
        return NULL;                                                  // RETURN
    }

    return BSLS_UTIL_ADDRESSOF(Var_ImpUtil::template getImpl<Ret>(
                                                bsl::in_place_index_t<INDEX>(),
                                                *ptr));
}

template <size_t INDEX, class HEAD, class... TAIL>
typename add_pointer<
    const typename variant_alternative<INDEX,
                                       variant<HEAD, TAIL...> >::type>::type
get_if(const variant<HEAD, TAIL...> *ptr) BSLS_KEYWORD_NOEXCEPT
{
    BSLMF_ASSERT((INDEX < variant_size<variant<HEAD, TAIL...> >::value));

    typedef typename bsl::variant<HEAD, TAIL...>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    typedef typename bsl::variant_alternative<INDEX, Variant>::type Ret;

    if (ptr == 0 || ptr->index() != INDEX) {
        return NULL;                                                  // RETURN
    }
    return BSLS_UTIL_ADDRESSOF(Var_ImpUtil::template getImpl<const Ret>(
                                                bsl::in_place_index_t<INDEX>(),
                                                *ptr));
}

template <class TYPE, class HEAD, class... TAIL>
typename add_pointer<TYPE>::type
get_if(variant<HEAD, TAIL...> *ptr) BSLS_KEYWORD_NOEXCEPT
{
    BSLMF_ASSERT(
            (BloombergLP::bslstl::
                 Variant_HasUniqueType<TYPE, variant<HEAD, TAIL...> >::value));

    typedef typename bsl::variant<HEAD, TAIL...>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (ptr == 0 || ptr->index() != BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)) {
        return NULL;                                                  // RETURN
    }
    return BSLS_UTIL_ADDRESSOF(Var_ImpUtil::template getImpl<TYPE>(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(),
               *ptr));
}

template <class TYPE, class HEAD, class... TAIL>
typename add_pointer<const TYPE>::type
get_if(const variant<HEAD, TAIL...> *ptr) BSLS_KEYWORD_NOEXCEPT
{
    BSLMF_ASSERT(
            (BloombergLP::bslstl::
                 Variant_HasUniqueType<TYPE, variant<HEAD, TAIL...> >::value));

    typedef typename bsl::variant<HEAD, TAIL...>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (ptr == 0 || ptr->index() != BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)) {
        return NULL;                                                  // RETURN
    }
    return BSLS_UTIL_ADDRESSOF(Var_ImpUtil::template getImpl<const TYPE>(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, Variant)>(),
               *ptr));
}
#else
// {{{ BEGIN GENERATED CODE
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <size_t INDEX, class VARIANT>
typename Variant_ReturnType<typename variant_alternative<INDEX, VARIANT>::type,
                            VARIANT>::pointer
get_if(VARIANT *ptr) BSLS_KEYWORD_NOEXCEPT
{
    BSLMF_ASSERT((INDEX < variant_size<VARIANT>::value));

    typedef typename BloombergLP::bslstl::Variant_ImpUtil<VARIANT> Var_ImpUtil;

    typedef typename bsl::variant_alternative<INDEX, VARIANT>::type Ret;

    if (ptr == 0 || ptr->index() != INDEX) {
        return NULL;
    }

    return BSLS_UTIL_ADDRESSOF(Var_ImpUtil::template getImpl<Ret>(
                                                bsl::in_place_index_t<INDEX>(),
                                                *ptr));
}
template <size_t INDEX, class VARIANT>
typename Variant_ReturnType<
    const typename variant_alternative<INDEX, VARIANT>::type,
    VARIANT>::pointer
get_if(const VARIANT *ptr) BSLS_KEYWORD_NOEXCEPT
{
    BSLMF_ASSERT((INDEX < variant_size<VARIANT>::value));

    typedef typename BloombergLP::bslstl::Variant_ImpUtil<VARIANT> Var_ImpUtil;

    typedef typename bsl::variant_alternative<INDEX, VARIANT>::type Ret;

    if (ptr == 0 || ptr->index() != INDEX) {
        return NULL;
    }
    return BSLS_UTIL_ADDRESSOF(Var_ImpUtil::template getImpl<const Ret>(
                                                bsl::in_place_index_t<INDEX>(),
                                                *ptr));
}

template <class TYPE, class VARIANT>
typename Variant_ReturnType<TYPE, VARIANT>::pointer
get_if(VARIANT *ptr) BSLS_KEYWORD_NOEXCEPT
{
    BSLMF_ASSERT(
           (BloombergLP::bslstl::Variant_HasUniqueType<TYPE, VARIANT>::value));

    typedef typename BloombergLP::bslstl::Variant_ImpUtil<VARIANT> Var_ImpUtil;

    if (ptr == 0 || ptr->index() != BSLSTL_VARIANT_INDEX_OF(TYPE, VARIANT)) {
        return NULL;
    }
    return BSLS_UTIL_ADDRESSOF(Var_ImpUtil::template getImpl<TYPE>(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, VARIANT)>(),
               *ptr));
}

template <class TYPE, class VARIANT>
typename Variant_ReturnType<const TYPE, VARIANT>::pointer
get_if(const VARIANT *ptr) BSLS_KEYWORD_NOEXCEPT
{
    BSLMF_ASSERT(
           (BloombergLP::bslstl::Variant_HasUniqueType<TYPE, VARIANT>::value));

    typedef typename BloombergLP::bslstl::Variant_ImpUtil<VARIANT> Var_ImpUtil;

    if (ptr == 0 || ptr->index() != BSLSTL_VARIANT_INDEX_OF(TYPE, VARIANT)) {
        return NULL;
    }
    return BSLS_UTIL_ADDRESSOF(Var_ImpUtil::template getImpl<const TYPE>(
               bsl::in_place_index_t<BSLSTL_VARIANT_INDEX_OF(TYPE, VARIANT)>(),
               *ptr));
}
// }}} END GENERATED CODE
#endif  // BSL_VARIANT_FULL_IMPLEMENTATION

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_variant.h
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT
#define BSLSTL_VARIANT_VARIADIC_LIMIT 10
#endif
#ifndef BSLSTL_VARIANT_VARIADIC_LIMIT_T
#define BSLSTL_VARIANT_VARIADIC_LIMIT_T BSLSTL_VARIANT_VARIADIC_LIMIT
#endif
#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 0
template <class HASHALG, class HEAD>
void hashAppend(HASHALG& hashAlg, const variant<HEAD>& input)
{
    if (!input.valueless_by_exception()) {
        hashAppend(hashAlg, input.index());
        BloombergLP::bslstl::Variant_HashVisitor<HASHALG> hashVisitor(hashAlg);
        visit(hashVisitor, input);
    } else {
        hashAppend(hashAlg, false);
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 1
template <class HASHALG, class HEAD, class TAIL_01>
void hashAppend(HASHALG& hashAlg, const variant<HEAD, TAIL_01>& input)
{
    if (!input.valueless_by_exception()) {
        hashAppend(hashAlg, input.index());
        BloombergLP::bslstl::Variant_HashVisitor<HASHALG> hashVisitor(hashAlg);
        visit(hashVisitor, input);
    } else {
        hashAppend(hashAlg, false);
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 2
template <class HASHALG, class HEAD, class TAIL_01,
                                     class TAIL_02>
void hashAppend(HASHALG& hashAlg, const variant<HEAD, TAIL_01,
                                                      TAIL_02>& input)
{
    if (!input.valueless_by_exception()) {
        hashAppend(hashAlg, input.index());
        BloombergLP::bslstl::Variant_HashVisitor<HASHALG> hashVisitor(hashAlg);
        visit(hashVisitor, input);
    } else {
        hashAppend(hashAlg, false);
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 3
template <class HASHALG, class HEAD, class TAIL_01,
                                     class TAIL_02,
                                     class TAIL_03>
void hashAppend(HASHALG& hashAlg, const variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03>& input)
{
    if (!input.valueless_by_exception()) {
        hashAppend(hashAlg, input.index());
        BloombergLP::bslstl::Variant_HashVisitor<HASHALG> hashVisitor(hashAlg);
        visit(hashVisitor, input);
    } else {
        hashAppend(hashAlg, false);
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 4
template <class HASHALG, class HEAD, class TAIL_01,
                                     class TAIL_02,
                                     class TAIL_03,
                                     class TAIL_04>
void hashAppend(HASHALG& hashAlg, const variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04>& input)
{
    if (!input.valueless_by_exception()) {
        hashAppend(hashAlg, input.index());
        BloombergLP::bslstl::Variant_HashVisitor<HASHALG> hashVisitor(hashAlg);
        visit(hashVisitor, input);
    } else {
        hashAppend(hashAlg, false);
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 5
template <class HASHALG, class HEAD, class TAIL_01,
                                     class TAIL_02,
                                     class TAIL_03,
                                     class TAIL_04,
                                     class TAIL_05>
void hashAppend(HASHALG& hashAlg, const variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05>& input)
{
    if (!input.valueless_by_exception()) {
        hashAppend(hashAlg, input.index());
        BloombergLP::bslstl::Variant_HashVisitor<HASHALG> hashVisitor(hashAlg);
        visit(hashVisitor, input);
    } else {
        hashAppend(hashAlg, false);
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 6
template <class HASHALG, class HEAD, class TAIL_01,
                                     class TAIL_02,
                                     class TAIL_03,
                                     class TAIL_04,
                                     class TAIL_05,
                                     class TAIL_06>
void hashAppend(HASHALG& hashAlg, const variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06>& input)
{
    if (!input.valueless_by_exception()) {
        hashAppend(hashAlg, input.index());
        BloombergLP::bslstl::Variant_HashVisitor<HASHALG> hashVisitor(hashAlg);
        visit(hashVisitor, input);
    } else {
        hashAppend(hashAlg, false);
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 7
template <class HASHALG, class HEAD, class TAIL_01,
                                     class TAIL_02,
                                     class TAIL_03,
                                     class TAIL_04,
                                     class TAIL_05,
                                     class TAIL_06,
                                     class TAIL_07>
void hashAppend(HASHALG& hashAlg, const variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07>& input)
{
    if (!input.valueless_by_exception()) {
        hashAppend(hashAlg, input.index());
        BloombergLP::bslstl::Variant_HashVisitor<HASHALG> hashVisitor(hashAlg);
        visit(hashVisitor, input);
    } else {
        hashAppend(hashAlg, false);
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 8
template <class HASHALG, class HEAD, class TAIL_01,
                                     class TAIL_02,
                                     class TAIL_03,
                                     class TAIL_04,
                                     class TAIL_05,
                                     class TAIL_06,
                                     class TAIL_07,
                                     class TAIL_08>
void hashAppend(HASHALG& hashAlg, const variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08>& input)
{
    if (!input.valueless_by_exception()) {
        hashAppend(hashAlg, input.index());
        BloombergLP::bslstl::Variant_HashVisitor<HASHALG> hashVisitor(hashAlg);
        visit(hashVisitor, input);
    } else {
        hashAppend(hashAlg, false);
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 9
template <class HASHALG, class HEAD, class TAIL_01,
                                     class TAIL_02,
                                     class TAIL_03,
                                     class TAIL_04,
                                     class TAIL_05,
                                     class TAIL_06,
                                     class TAIL_07,
                                     class TAIL_08,
                                     class TAIL_09>
void hashAppend(HASHALG& hashAlg, const variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08,
                                                      TAIL_09>& input)
{
    if (!input.valueless_by_exception()) {
        hashAppend(hashAlg, input.index());
        BloombergLP::bslstl::Variant_HashVisitor<HASHALG> hashVisitor(hashAlg);
        visit(hashVisitor, input);
    } else {
        hashAppend(hashAlg, false);
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 10
template <class HASHALG, class HEAD, class TAIL_01,
                                     class TAIL_02,
                                     class TAIL_03,
                                     class TAIL_04,
                                     class TAIL_05,
                                     class TAIL_06,
                                     class TAIL_07,
                                     class TAIL_08,
                                     class TAIL_09,
                                     class TAIL_10>
void hashAppend(HASHALG& hashAlg, const variant<HEAD, TAIL_01,
                                                      TAIL_02,
                                                      TAIL_03,
                                                      TAIL_04,
                                                      TAIL_05,
                                                      TAIL_06,
                                                      TAIL_07,
                                                      TAIL_08,
                                                      TAIL_09,
                                                      TAIL_10>& input)
{
    if (!input.valueless_by_exception()) {
        hashAppend(hashAlg, input.index());
        BloombergLP::bslstl::Variant_HashVisitor<HASHALG> hashVisitor(hashAlg);
        visit(hashVisitor, input);
    } else {
        hashAppend(hashAlg, false);
    }
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 0
template <class TYPE, class HEAD>
bool holds_alternative(const variant<HEAD>& obj) BSLS_KEYWORD_NOEXCEPT
{
    BSLMF_ASSERT(
            (BloombergLP::bslstl::
                 Variant_HasUniqueType<TYPE, variant<HEAD> >::value));
    typedef typename bsl::variant<HEAD> Variant;
    return obj.index() == BSLSTL_VARIANT_INDEX_OF(TYPE, Variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 1
template <class TYPE, class HEAD, class TAIL_01>
bool holds_alternative(const variant<HEAD, TAIL_01>& obj) BSLS_KEYWORD_NOEXCEPT
{
    BSLMF_ASSERT(
            (BloombergLP::bslstl::
                 Variant_HasUniqueType<TYPE, variant<HEAD, TAIL_01> >::value));
    typedef typename bsl::variant<HEAD, TAIL_01> Variant;
    return obj.index() == BSLSTL_VARIANT_INDEX_OF(TYPE, Variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 2
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02>
bool holds_alternative(const variant<HEAD, TAIL_01,
                                           TAIL_02>& obj) BSLS_KEYWORD_NOEXCEPT
{
    BSLMF_ASSERT(
            (BloombergLP::bslstl::
                 Variant_HasUniqueType<TYPE, variant<HEAD, TAIL_01,
                                                           TAIL_02> >::value));
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02> Variant;
    return obj.index() == BSLSTL_VARIANT_INDEX_OF(TYPE, Variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 3
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03>
bool holds_alternative(const variant<HEAD, TAIL_01,
                                           TAIL_02,
                                           TAIL_03>& obj) BSLS_KEYWORD_NOEXCEPT
{
    BSLMF_ASSERT(
            (BloombergLP::bslstl::
                 Variant_HasUniqueType<TYPE, variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03> >::value));
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03> Variant;
    return obj.index() == BSLSTL_VARIANT_INDEX_OF(TYPE, Variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 4
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04>
bool holds_alternative(const variant<HEAD, TAIL_01,
                                           TAIL_02,
                                           TAIL_03,
                                           TAIL_04>& obj) BSLS_KEYWORD_NOEXCEPT
{
    BSLMF_ASSERT(
            (BloombergLP::bslstl::
                 Variant_HasUniqueType<TYPE, variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04> >::value));
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04> Variant;
    return obj.index() == BSLSTL_VARIANT_INDEX_OF(TYPE, Variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 5
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05>
bool holds_alternative(const variant<HEAD, TAIL_01,
                                           TAIL_02,
                                           TAIL_03,
                                           TAIL_04,
                                           TAIL_05>& obj) BSLS_KEYWORD_NOEXCEPT
{
    BSLMF_ASSERT(
            (BloombergLP::bslstl::
                 Variant_HasUniqueType<TYPE, variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05> >::value));
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05> Variant;
    return obj.index() == BSLSTL_VARIANT_INDEX_OF(TYPE, Variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 6
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06>
bool holds_alternative(const variant<HEAD, TAIL_01,
                                           TAIL_02,
                                           TAIL_03,
                                           TAIL_04,
                                           TAIL_05,
                                           TAIL_06>& obj) BSLS_KEYWORD_NOEXCEPT
{
    BSLMF_ASSERT(
            (BloombergLP::bslstl::
                 Variant_HasUniqueType<TYPE, variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06> >::value));
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06> Variant;
    return obj.index() == BSLSTL_VARIANT_INDEX_OF(TYPE, Variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 7
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07>
bool holds_alternative(const variant<HEAD, TAIL_01,
                                           TAIL_02,
                                           TAIL_03,
                                           TAIL_04,
                                           TAIL_05,
                                           TAIL_06,
                                           TAIL_07>& obj) BSLS_KEYWORD_NOEXCEPT
{
    BSLMF_ASSERT(
            (BloombergLP::bslstl::
                 Variant_HasUniqueType<TYPE, variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07> >::value));
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07> Variant;
    return obj.index() == BSLSTL_VARIANT_INDEX_OF(TYPE, Variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 8
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08>
bool holds_alternative(const variant<HEAD, TAIL_01,
                                           TAIL_02,
                                           TAIL_03,
                                           TAIL_04,
                                           TAIL_05,
                                           TAIL_06,
                                           TAIL_07,
                                           TAIL_08>& obj) BSLS_KEYWORD_NOEXCEPT
{
    BSLMF_ASSERT(
            (BloombergLP::bslstl::
                 Variant_HasUniqueType<TYPE, variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08> >::value));
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08> Variant;
    return obj.index() == BSLSTL_VARIANT_INDEX_OF(TYPE, Variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 9
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08,
                                  class TAIL_09>
bool holds_alternative(const variant<HEAD, TAIL_01,
                                           TAIL_02,
                                           TAIL_03,
                                           TAIL_04,
                                           TAIL_05,
                                           TAIL_06,
                                           TAIL_07,
                                           TAIL_08,
                                           TAIL_09>& obj) BSLS_KEYWORD_NOEXCEPT
{
    BSLMF_ASSERT(
            (BloombergLP::bslstl::
                 Variant_HasUniqueType<TYPE, variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08,
                                                           TAIL_09> >::value));
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08,
                                        TAIL_09> Variant;
    return obj.index() == BSLSTL_VARIANT_INDEX_OF(TYPE, Variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 10
template <class TYPE, class HEAD, class TAIL_01,
                                  class TAIL_02,
                                  class TAIL_03,
                                  class TAIL_04,
                                  class TAIL_05,
                                  class TAIL_06,
                                  class TAIL_07,
                                  class TAIL_08,
                                  class TAIL_09,
                                  class TAIL_10>
bool holds_alternative(const variant<HEAD, TAIL_01,
                                           TAIL_02,
                                           TAIL_03,
                                           TAIL_04,
                                           TAIL_05,
                                           TAIL_06,
                                           TAIL_07,
                                           TAIL_08,
                                           TAIL_09,
                                           TAIL_10>& obj) BSLS_KEYWORD_NOEXCEPT
{
    BSLMF_ASSERT(
            (BloombergLP::bslstl::
                 Variant_HasUniqueType<TYPE, variant<HEAD, TAIL_01,
                                                           TAIL_02,
                                                           TAIL_03,
                                                           TAIL_04,
                                                           TAIL_05,
                                                           TAIL_06,
                                                           TAIL_07,
                                                           TAIL_08,
                                                           TAIL_09,
                                                           TAIL_10> >::value));
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08,
                                        TAIL_09,
                                        TAIL_10> Variant;
    return obj.index() == BSLSTL_VARIANT_INDEX_OF(TYPE, Variant);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 0
template <class HEAD>
void swap(bsl::variant<HEAD>& lhs, bsl::variant<HEAD>& rhs)
{
    BloombergLP::bslstl::variant_swapImpl(
        bsl::integral_constant<
            bool,
            BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD>::
                value>(),
        lhs,
        rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 1
template <class HEAD, class TAIL_01>
void swap(bsl::variant<HEAD, TAIL_01>& lhs, bsl::variant<HEAD, TAIL_01>& rhs)
{
    BloombergLP::bslstl::variant_swapImpl(
        bsl::integral_constant<
            bool,
            BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD, TAIL_01>::
                value>(),
        lhs,
        rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
void swap(bsl::variant<HEAD, TAIL_01,
                             TAIL_02>& lhs, bsl::variant<HEAD, TAIL_01,
                                                               TAIL_02>& rhs)
{
    BloombergLP::bslstl::variant_swapImpl(
        bsl::integral_constant<
            bool,
            BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD, TAIL_01,
                                                                     TAIL_02>::
                value>(),
        lhs,
        rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
void swap(bsl::variant<HEAD, TAIL_01,
                             TAIL_02,
                             TAIL_03>& lhs, bsl::variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03>& rhs)
{
    BloombergLP::bslstl::variant_swapImpl(
        bsl::integral_constant<
            bool,
            BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD, TAIL_01,
                                                                     TAIL_02,
                                                                     TAIL_03>::
                value>(),
        lhs,
        rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
void swap(bsl::variant<HEAD, TAIL_01,
                             TAIL_02,
                             TAIL_03,
                             TAIL_04>& lhs, bsl::variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03,
                                                               TAIL_04>& rhs)
{
    BloombergLP::bslstl::variant_swapImpl(
        bsl::integral_constant<
            bool,
            BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD, TAIL_01,
                                                                     TAIL_02,
                                                                     TAIL_03,
                                                                     TAIL_04>::
                value>(),
        lhs,
        rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
void swap(bsl::variant<HEAD, TAIL_01,
                             TAIL_02,
                             TAIL_03,
                             TAIL_04,
                             TAIL_05>& lhs, bsl::variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03,
                                                               TAIL_04,
                                                               TAIL_05>& rhs)
{
    BloombergLP::bslstl::variant_swapImpl(
        bsl::integral_constant<
            bool,
            BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD, TAIL_01,
                                                                     TAIL_02,
                                                                     TAIL_03,
                                                                     TAIL_04,
                                                                     TAIL_05>::
                value>(),
        lhs,
        rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
void swap(bsl::variant<HEAD, TAIL_01,
                             TAIL_02,
                             TAIL_03,
                             TAIL_04,
                             TAIL_05,
                             TAIL_06>& lhs, bsl::variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03,
                                                               TAIL_04,
                                                               TAIL_05,
                                                               TAIL_06>& rhs)
{
    BloombergLP::bslstl::variant_swapImpl(
        bsl::integral_constant<
            bool,
            BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD, TAIL_01,
                                                                     TAIL_02,
                                                                     TAIL_03,
                                                                     TAIL_04,
                                                                     TAIL_05,
                                                                     TAIL_06>::
                value>(),
        lhs,
        rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
void swap(bsl::variant<HEAD, TAIL_01,
                             TAIL_02,
                             TAIL_03,
                             TAIL_04,
                             TAIL_05,
                             TAIL_06,
                             TAIL_07>& lhs, bsl::variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03,
                                                               TAIL_04,
                                                               TAIL_05,
                                                               TAIL_06,
                                                               TAIL_07>& rhs)
{
    BloombergLP::bslstl::variant_swapImpl(
        bsl::integral_constant<
            bool,
            BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD, TAIL_01,
                                                                     TAIL_02,
                                                                     TAIL_03,
                                                                     TAIL_04,
                                                                     TAIL_05,
                                                                     TAIL_06,
                                                                     TAIL_07>::
                value>(),
        lhs,
        rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
void swap(bsl::variant<HEAD, TAIL_01,
                             TAIL_02,
                             TAIL_03,
                             TAIL_04,
                             TAIL_05,
                             TAIL_06,
                             TAIL_07,
                             TAIL_08>& lhs, bsl::variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03,
                                                               TAIL_04,
                                                               TAIL_05,
                                                               TAIL_06,
                                                               TAIL_07,
                                                               TAIL_08>& rhs)
{
    BloombergLP::bslstl::variant_swapImpl(
        bsl::integral_constant<
            bool,
            BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD, TAIL_01,
                                                                     TAIL_02,
                                                                     TAIL_03,
                                                                     TAIL_04,
                                                                     TAIL_05,
                                                                     TAIL_06,
                                                                     TAIL_07,
                                                                     TAIL_08>::
                value>(),
        lhs,
        rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
void swap(bsl::variant<HEAD, TAIL_01,
                             TAIL_02,
                             TAIL_03,
                             TAIL_04,
                             TAIL_05,
                             TAIL_06,
                             TAIL_07,
                             TAIL_08,
                             TAIL_09>& lhs, bsl::variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03,
                                                               TAIL_04,
                                                               TAIL_05,
                                                               TAIL_06,
                                                               TAIL_07,
                                                               TAIL_08,
                                                               TAIL_09>& rhs)
{
    BloombergLP::bslstl::variant_swapImpl(
        bsl::integral_constant<
            bool,
            BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD, TAIL_01,
                                                                     TAIL_02,
                                                                     TAIL_03,
                                                                     TAIL_04,
                                                                     TAIL_05,
                                                                     TAIL_06,
                                                                     TAIL_07,
                                                                     TAIL_08,
                                                                     TAIL_09>::
                value>(),
        lhs,
        rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
void swap(bsl::variant<HEAD, TAIL_01,
                             TAIL_02,
                             TAIL_03,
                             TAIL_04,
                             TAIL_05,
                             TAIL_06,
                             TAIL_07,
                             TAIL_08,
                             TAIL_09,
                             TAIL_10>& lhs, bsl::variant<HEAD, TAIL_01,
                                                               TAIL_02,
                                                               TAIL_03,
                                                               TAIL_04,
                                                               TAIL_05,
                                                               TAIL_06,
                                                               TAIL_07,
                                                               TAIL_08,
                                                               TAIL_09,
                                                               TAIL_10>& rhs)
{
    BloombergLP::bslstl::variant_swapImpl(
        bsl::integral_constant<
            bool,
            BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD, TAIL_01,
                                                                     TAIL_02,
                                                                     TAIL_03,
                                                                     TAIL_04,
                                                                     TAIL_05,
                                                                     TAIL_06,
                                                                     TAIL_07,
                                                                     TAIL_08,
                                                                     TAIL_09,
                                                                     TAIL_10>::
                value>(),
        lhs,
        rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 0
template <class HEAD>
bool operator==(const variant<HEAD>& lhs,
                const variant<HEAD>& rhs)
{
    typedef typename bsl::variant<HEAD>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    return Var_ImpUtil::EqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 1
template <class HEAD, class TAIL_01>
bool operator==(const variant<HEAD, TAIL_01>& lhs,
                const variant<HEAD, TAIL_01>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    return Var_ImpUtil::EqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
bool operator==(const variant<HEAD, TAIL_01,
                                    TAIL_02>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    return Var_ImpUtil::EqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
bool operator==(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    return Var_ImpUtil::EqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
bool operator==(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    return Var_ImpUtil::EqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
bool operator==(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    return Var_ImpUtil::EqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
bool operator==(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    return Var_ImpUtil::EqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
bool operator==(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    return Var_ImpUtil::EqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
bool operator==(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    return Var_ImpUtil::EqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
bool operator==(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08,
                                        TAIL_09>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    return Var_ImpUtil::EqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
bool operator==(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09,
                                    TAIL_10>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09,
                                    TAIL_10>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08,
                                        TAIL_09,
                                        TAIL_10>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    return Var_ImpUtil::EqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 0
template <class HEAD>
bool operator!=(const variant<HEAD>& lhs,
                const variant<HEAD>& rhs)
{
    typedef typename bsl::variant<HEAD>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    return Var_ImpUtil::NotEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 1
template <class HEAD, class TAIL_01>
bool operator!=(const variant<HEAD, TAIL_01>& lhs,
                const variant<HEAD, TAIL_01>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    return Var_ImpUtil::NotEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
bool operator!=(const variant<HEAD, TAIL_01,
                                    TAIL_02>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    return Var_ImpUtil::NotEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
bool operator!=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    return Var_ImpUtil::NotEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
bool operator!=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    return Var_ImpUtil::NotEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
bool operator!=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    return Var_ImpUtil::NotEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
bool operator!=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    return Var_ImpUtil::NotEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
bool operator!=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    return Var_ImpUtil::NotEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
bool operator!=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    return Var_ImpUtil::NotEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
bool operator!=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08,
                                        TAIL_09>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    return Var_ImpUtil::NotEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
bool operator!=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09,
                                    TAIL_10>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09,
                                    TAIL_10>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08,
                                        TAIL_09,
                                        TAIL_10>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    return Var_ImpUtil::NotEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 0
template <class HEAD>
bool operator<(const variant<HEAD>& lhs,
               const variant<HEAD>& rhs)
{
    typedef typename bsl::variant<HEAD>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessThanImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 1
template <class HEAD, class TAIL_01>
bool operator<(const variant<HEAD, TAIL_01>& lhs,
               const variant<HEAD, TAIL_01>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessThanImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
bool operator<(const variant<HEAD, TAIL_01,
                                   TAIL_02>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessThanImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
bool operator<(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessThanImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
bool operator<(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessThanImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
bool operator<(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessThanImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
bool operator<(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessThanImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
bool operator<(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessThanImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
bool operator<(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessThanImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
bool operator<(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08,
                                   TAIL_09>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08,
                                   TAIL_09>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08,
                                        TAIL_09>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessThanImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
bool operator<(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08,
                                   TAIL_09,
                                   TAIL_10>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08,
                                   TAIL_09,
                                   TAIL_10>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08,
                                        TAIL_09,
                                        TAIL_10>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessThanImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 0
template <class HEAD>
bool operator>(const variant<HEAD>& lhs,
               const variant<HEAD>& rhs)
{
    typedef typename bsl::variant<HEAD>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }
    return Var_ImpUtil::GreaterThanImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 1
template <class HEAD, class TAIL_01>
bool operator>(const variant<HEAD, TAIL_01>& lhs,
               const variant<HEAD, TAIL_01>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }
    return Var_ImpUtil::GreaterThanImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
bool operator>(const variant<HEAD, TAIL_01,
                                   TAIL_02>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }
    return Var_ImpUtil::GreaterThanImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
bool operator>(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }
    return Var_ImpUtil::GreaterThanImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
bool operator>(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }
    return Var_ImpUtil::GreaterThanImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
bool operator>(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }
    return Var_ImpUtil::GreaterThanImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
bool operator>(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }
    return Var_ImpUtil::GreaterThanImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
bool operator>(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }
    return Var_ImpUtil::GreaterThanImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
bool operator>(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }
    return Var_ImpUtil::GreaterThanImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
bool operator>(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08,
                                   TAIL_09>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08,
                                   TAIL_09>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08,
                                        TAIL_09>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }
    return Var_ImpUtil::GreaterThanImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
bool operator>(const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08,
                                   TAIL_09,
                                   TAIL_10>& lhs,
               const variant<HEAD, TAIL_01,
                                   TAIL_02,
                                   TAIL_03,
                                   TAIL_04,
                                   TAIL_05,
                                   TAIL_06,
                                   TAIL_07,
                                   TAIL_08,
                                   TAIL_09,
                                   TAIL_10>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08,
                                        TAIL_09,
                                        TAIL_10>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }
    return Var_ImpUtil::GreaterThanImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 0
template <class HEAD>
bool operator<=(const variant<HEAD>& lhs,
                const variant<HEAD>& rhs)
{
    typedef typename bsl::variant<HEAD>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessOrEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 1
template <class HEAD, class TAIL_01>
bool operator<=(const variant<HEAD, TAIL_01>& lhs,
                const variant<HEAD, TAIL_01>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessOrEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
bool operator<=(const variant<HEAD, TAIL_01,
                                    TAIL_02>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessOrEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
bool operator<=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessOrEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
bool operator<=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessOrEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
bool operator<=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessOrEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
bool operator<=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessOrEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
bool operator<=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessOrEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
bool operator<=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessOrEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
bool operator<=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08,
                                        TAIL_09>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessOrEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
bool operator<=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09,
                                    TAIL_10>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09,
                                    TAIL_10>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08,
                                        TAIL_09,
                                        TAIL_10>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessOrEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 10


#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 0
template <class HEAD>
bool operator>=(const variant<HEAD>& lhs,
                const variant<HEAD>& rhs)
{
    typedef typename bsl::variant<HEAD>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }

    return Var_ImpUtil::GreaterOrEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 0

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 1
template <class HEAD, class TAIL_01>
bool operator>=(const variant<HEAD, TAIL_01>& lhs,
                const variant<HEAD, TAIL_01>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }

    return Var_ImpUtil::GreaterOrEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 1

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 2
template <class HEAD, class TAIL_01,
                      class TAIL_02>
bool operator>=(const variant<HEAD, TAIL_01,
                                    TAIL_02>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }

    return Var_ImpUtil::GreaterOrEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 2

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 3
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03>
bool operator>=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }

    return Var_ImpUtil::GreaterOrEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 3

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 4
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04>
bool operator>=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }

    return Var_ImpUtil::GreaterOrEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 4

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 5
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05>
bool operator>=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }

    return Var_ImpUtil::GreaterOrEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 5

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 6
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06>
bool operator>=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }

    return Var_ImpUtil::GreaterOrEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 6

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 7
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07>
bool operator>=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }

    return Var_ImpUtil::GreaterOrEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 7

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 8
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08>
bool operator>=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }

    return Var_ImpUtil::GreaterOrEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 8

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 9
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09>
bool operator>=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08,
                                        TAIL_09>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }

    return Var_ImpUtil::GreaterOrEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 9

#if BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 10
template <class HEAD, class TAIL_01,
                      class TAIL_02,
                      class TAIL_03,
                      class TAIL_04,
                      class TAIL_05,
                      class TAIL_06,
                      class TAIL_07,
                      class TAIL_08,
                      class TAIL_09,
                      class TAIL_10>
bool operator>=(const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09,
                                    TAIL_10>& lhs,
                const variant<HEAD, TAIL_01,
                                    TAIL_02,
                                    TAIL_03,
                                    TAIL_04,
                                    TAIL_05,
                                    TAIL_06,
                                    TAIL_07,
                                    TAIL_08,
                                    TAIL_09,
                                    TAIL_10>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL_01,
                                        TAIL_02,
                                        TAIL_03,
                                        TAIL_04,
                                        TAIL_05,
                                        TAIL_06,
                                        TAIL_07,
                                        TAIL_08,
                                        TAIL_09,
                                        TAIL_10>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }

    return Var_ImpUtil::GreaterOrEqualImpl(lhs, rhs);
}
#endif  // BSLSTL_VARIANT_VARIADIC_LIMIT_T >= 10

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class HASHALG, class HEAD, class... TAIL>
void hashAppend(HASHALG& hashAlg, const variant<HEAD, TAIL...>& input)
{
    if (!input.valueless_by_exception()) {
        hashAppend(hashAlg, input.index());
        BloombergLP::bslstl::Variant_HashVisitor<HASHALG> hashVisitor(hashAlg);
        visit(hashVisitor, input);
    } else {
        hashAppend(hashAlg, false);
    }
}

template <class TYPE, class HEAD, class... TAIL>
bool holds_alternative(const variant<HEAD, TAIL...>& obj) BSLS_KEYWORD_NOEXCEPT
{
    BSLMF_ASSERT(
            (BloombergLP::bslstl::
                 Variant_HasUniqueType<TYPE, variant<HEAD, TAIL...> >::value));
    typedef typename bsl::variant<HEAD, TAIL...> Variant;
    return obj.index() == BSLSTL_VARIANT_INDEX_OF(TYPE, Variant);
}

template <class HEAD, class... TAIL>
void swap(bsl::variant<HEAD, TAIL...>& lhs, bsl::variant<HEAD, TAIL...>& rhs)
{
    BloombergLP::bslstl::variant_swapImpl(
        bsl::integral_constant<
            bool,
            BloombergLP::bslstl::Variant_UsesBslmaAllocatorAny<HEAD, TAIL...>::
                value>(),
        lhs,
        rhs);
}

template <class HEAD, class... TAIL>
bool operator==(const variant<HEAD, TAIL...>& lhs,
                const variant<HEAD, TAIL...>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL...>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    return Var_ImpUtil::EqualImpl(lhs, rhs);
}

template <class HEAD, class... TAIL>
bool operator!=(const variant<HEAD, TAIL...>& lhs,
                const variant<HEAD, TAIL...>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL...>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.index() != rhs.index()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    return Var_ImpUtil::NotEqualImpl(lhs, rhs);
}

template <class HEAD, class... TAIL>
bool operator<(const variant<HEAD, TAIL...>& lhs,
               const variant<HEAD, TAIL...>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL...>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessThanImpl(lhs, rhs);
}

template <class HEAD, class... TAIL>
bool operator>(const variant<HEAD, TAIL...>& lhs,
               const variant<HEAD, TAIL...>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL...>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }
    return Var_ImpUtil::GreaterThanImpl(lhs, rhs);
}

template <class HEAD, class... TAIL>
bool operator<=(const variant<HEAD, TAIL...>& lhs,
                const variant<HEAD, TAIL...>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL...>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (lhs.valueless_by_exception()) {
        return true;
    }
    else if (rhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() < rhs.index();
    }
    return Var_ImpUtil::LessOrEqualImpl(lhs, rhs);
}

template <class HEAD, class... TAIL>
bool operator>=(const variant<HEAD, TAIL...>& lhs,
                const variant<HEAD, TAIL...>& rhs)
{
    typedef typename bsl::variant<HEAD, TAIL...>                   Variant;
    typedef typename BloombergLP::bslstl::Variant_ImpUtil<Variant> Var_ImpUtil;

    if (rhs.valueless_by_exception()) {
        return true;
    }
    else if (lhs.valueless_by_exception()) {
        return false;
    }
    else if (lhs.index() != rhs.index()) {
        return lhs.index() > rhs.index();
    }

    return Var_ImpUtil::GreaterOrEqualImpl(lhs, rhs);
}
// }}} END GENERATED CODE
#endif
}  // close namespace bsl

#else // if ! defined(DEFINED_BSLSTL_VARIANT_H)
# error Not valid except when included from bslstl_variant.h
#endif // ! defined(COMPILING_BSLSTL_VARIANT_H)

#endif // ! defined(INCLUDED_BSLSTL_VARIANT_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2023 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
