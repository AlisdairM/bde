// bslstl_function_invokerutil_cpp03.h                                -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BSLSTL_FUNCTION_INVOKERUTIL_CPP03
#define INCLUDED_BSLSTL_FUNCTION_INVOKERUTIL_CPP03

//@PURPOSE: Provide C++03 implementation for bslstl_function_invokerutil.h
//
//@CLASSES: See bslstl_function_invokerutil.h for list of classes
//
//@SEE_ALSO: bslstl_function_invokerutil
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the the original
// header contains any specially delimited regions of C++11 code, then this
// generated file contains the C++03 equivelent, i.e., with variadic templates
// expanded and rvalue-references replaced by 'bslmf::MovableRef' objects.
// The header code in this file is designed to be '#include'd into the
// original header when compiling with a C++03 compiler.  If there are no
// specially delimited regions of C++11 code, then this header contains no
// code and is not '#include'd in the original header.
//
// Generated on Tue Dec 15 15:06:38 2020
// Command line: sim_cpp11_features.pl bslstl_function_invokerutil.h

#ifdef COMPILING_BSLSTL_FUNCTION_INVOKERUTIL_H

namespace BloombergLP {

namespace bslstl {

                        // ===========================
                        // struct Function_InvokerUtil
                        // ===========================

struct Function_InvokerUtil {
    // This struct is a namespace containing a single function template,
    // 'invokerForFunc', that returns a pointer to a function that is used to
    // invoke a callable object of a particular type.

    // TYPES
    enum {
        // Enumeration of the different types of callable objects.

        e_Null,
        e_FunctionPtr,
        e_MemFunctionPtr,
        e_MemDataPtr,
        e_InplaceFunctor,
        e_OutofplaceFunctor
    };

    typedef Function_Rep::GenericInvoker GenericInvoker;
        // Generic function pointer.  This type is as close as we can get to
        // 'void *' for function pointers.

    // CLASS METHODS
    template <class PROTOTYPE>
    static GenericInvoker *invokerForFunc(const bsl::nullptr_t&);
        // Return a null pointer.  Note that template argument 'PROTOTYPE' must
        // be supplied excplicitly, as there is no way to deduce it from the
        // function arguments.

    template <class PROTOTYPE, class FUNC>
    static GenericInvoker *invokerForFunc(const FUNC& f);
        // Return a pointer to the invoker for a callable object of (template
        // paramter) type 'FUNC'.  If the specified 'f' object is a null
        // pointer or null pointer-to-member, return a null pointer.  Note that
        // template argument 'PROTOTYPE' must be supplied excplicitly, as there
        // is no way to deduce it from the function arguments.
};

               // =============================================
               // template struct Function_InvokerUtil_Dispatch
               // =============================================

template <int INVOCATION_TYPE, class PROTOTYPE, class FUNC>
struct Function_InvokerUtil_Dispatch;
    // Specializations of this class contain a static 'invoke' method that can
    // invoke a callable object of type 'FUNC', converting each argument in
    // 'PROTOTYPE' (a function prototype) to the corresponding argument in the
    // invocation of the callable object and converting the return value of the
    // invocation to the return type of 'PROTOTYPE'.  The 'INVOCATION_TYPE'
    // specifies the category of callable object: pointer to function, pointer
    // to member function, pointer to data member, inplace functor (i.e., one
    // that qualifies for the small-object optimization) and out-of-place
    // functor (i.e., one that is not stored in the small-object buffer).
    // Specializations also contain a static 'isNull' method that identifies if
    // an instance of 'FUNC' should be treated as null.  The primary template
    // is never instantiated and has no body.  Compilation will fail unless
    // 'FUNC' is invokable with the arguments in 'PROTOTYPE' and the return
    // type of 'PROTOTYPE' is 'void' or the return type of that invokation is
    // convertible to the return type of 'PROTOTYPE'.

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_function_invokerutil.h
#ifndef BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT
#define BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT 13
#endif
#ifndef BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A
#define BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT
#endif

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0
template <class FUNC, class RET>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(), FUNC> {

    static RET invoke(const Function_Rep                            *rep);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1
template <class FUNC, class RET, class ARGS_01>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10,
                                         ARGS_11), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10,
                                         ARGS_11,
                                         ARGS_12), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                      typename bslmf::ForwardingType<ARGS_12>::Type args_12);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 13
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10,
                                         ARGS_11,
                                         ARGS_12,
                                         ARGS_13), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                      typename bslmf::ForwardingType<ARGS_12>::Type args_12,
                      typename bslmf::ForwardingType<ARGS_13>::Type args_13);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 13


#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0
template <class FUNC, class RET, class ARG0>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0), FUNC> {

  private:
    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj);

  public:
    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1
template <class FUNC, class RET, class ARG0, class ARGS_01>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01), FUNC> {

  private:
    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01);

  public:
    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02), FUNC> {

  private:
    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02);

  public:
    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02,
                                               ARGS_03), FUNC> {

  private:
    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03);

  public:
    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02,
                                               ARGS_03,
                                               ARGS_04), FUNC> {

  private:
    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04);

  public:
    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02,
                                               ARGS_03,
                                               ARGS_04,
                                               ARGS_05), FUNC> {

  private:
    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05);

  public:
    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02,
                                               ARGS_03,
                                               ARGS_04,
                                               ARGS_05,
                                               ARGS_06), FUNC> {

  private:
    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06);

  public:
    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02,
                                               ARGS_03,
                                               ARGS_04,
                                               ARGS_05,
                                               ARGS_06,
                                               ARGS_07), FUNC> {

  private:
    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07);

  public:
    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02,
                                               ARGS_03,
                                               ARGS_04,
                                               ARGS_05,
                                               ARGS_06,
                                               ARGS_07,
                                               ARGS_08), FUNC> {

  private:
    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08);

  public:
    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02,
                                               ARGS_03,
                                               ARGS_04,
                                               ARGS_05,
                                               ARGS_06,
                                               ARGS_07,
                                               ARGS_08,
                                               ARGS_09), FUNC> {

  private:
    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                        typename bslmf::ForwardingType<ARGS_09>::Type args_09);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                        typename bslmf::ForwardingType<ARGS_09>::Type args_09);

  public:
    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02,
                                               ARGS_03,
                                               ARGS_04,
                                               ARGS_05,
                                               ARGS_06,
                                               ARGS_07,
                                               ARGS_08,
                                               ARGS_09,
                                               ARGS_10), FUNC> {

  private:
    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                        typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                        typename bslmf::ForwardingType<ARGS_10>::Type args_10);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                        typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                        typename bslmf::ForwardingType<ARGS_10>::Type args_10);

  public:
    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02,
                                               ARGS_03,
                                               ARGS_04,
                                               ARGS_05,
                                               ARGS_06,
                                               ARGS_07,
                                               ARGS_08,
                                               ARGS_09,
                                               ARGS_10,
                                               ARGS_11), FUNC> {

  private:
    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                        typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                        typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                        typename bslmf::ForwardingType<ARGS_11>::Type args_11);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                        typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                        typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                        typename bslmf::ForwardingType<ARGS_11>::Type args_11);

  public:
    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02,
                                               ARGS_03,
                                               ARGS_04,
                                               ARGS_05,
                                               ARGS_06,
                                               ARGS_07,
                                               ARGS_08,
                                               ARGS_09,
                                               ARGS_10,
                                               ARGS_11,
                                               ARGS_12), FUNC> {

  private:
    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                        typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                        typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                        typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                        typename bslmf::ForwardingType<ARGS_12>::Type args_12);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                        typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                        typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                        typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                        typename bslmf::ForwardingType<ARGS_12>::Type args_12);

  public:
    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                      typename bslmf::ForwardingType<ARGS_12>::Type args_12);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 13
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12,
                                             class ARGS_13>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS_01,
                                               ARGS_02,
                                               ARGS_03,
                                               ARGS_04,
                                               ARGS_05,
                                               ARGS_06,
                                               ARGS_07,
                                               ARGS_08,
                                               ARGS_09,
                                               ARGS_10,
                                               ARGS_11,
                                               ARGS_12,
                                               ARGS_13), FUNC> {

  private:
    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                        typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                        typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                        typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                        typename bslmf::ForwardingType<ARGS_12>::Type args_12,
                        typename bslmf::ForwardingType<ARGS_13>::Type args_13);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                        typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                        typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                        typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                        typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                        typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                        typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                        typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                        typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                        typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                        typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                        typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                        typename bslmf::ForwardingType<ARGS_12>::Type args_12,
                        typename bslmf::ForwardingType<ARGS_13>::Type args_13);

  public:
    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                      typename bslmf::ForwardingType<ARGS_12>::Type args_12,
                      typename bslmf::ForwardingType<ARGS_13>::Type args_13);

    static bool isNull(FUNC f);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 13


template <class MEMBER_TYPE, class CLASS_TYPE, class RET, class ARG0>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemDataPtr,
                                     RET(ARG0), MEMBER_TYPE CLASS_TYPE::*> {
  private:
    typedef MEMBER_TYPE CLASS_TYPE::* Func;

    static RET invokeImp(bsl::true_type ,
                         Func                                        f,
                         typename bslmf::ForwardingType<ARG0>::Type  obj);

    static RET invokeImp(bsl::false_type ,
                         Func                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj);

  public:
    static RET invoke(const Function_Rep                         *rep,
                      typename bslmf::ForwardingType<ARG0>::Type  obj);

    static bool isNull(Func f);
};

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0
template <class FUNC, class RET>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(), FUNC> {

    static RET invoke(const Function_Rep                            *rep);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1
template <class FUNC, class RET, class ARGS_01>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10,
                                         ARGS_11), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10,
                                         ARGS_11,
                                         ARGS_12), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                      typename bslmf::ForwardingType<ARGS_12>::Type args_12);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 13
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10,
                                         ARGS_11,
                                         ARGS_12,
                                         ARGS_13), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                      typename bslmf::ForwardingType<ARGS_12>::Type args_12,
                      typename bslmf::ForwardingType<ARGS_13>::Type args_13);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 13


#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0
template <class FUNC, class RET>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(), FUNC> {

    static RET invoke(const Function_Rep                            *rep);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1
template <class FUNC, class RET, class ARGS_01>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10,
                                         ARGS_11), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10,
                                         ARGS_11,
                                         ARGS_12), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                      typename bslmf::ForwardingType<ARGS_12>::Type args_12);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 13
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS_01,
                                         ARGS_02,
                                         ARGS_03,
                                         ARGS_04,
                                         ARGS_05,
                                         ARGS_06,
                                         ARGS_07,
                                         ARGS_08,
                                         ARGS_09,
                                         ARGS_10,
                                         ARGS_11,
                                         ARGS_12,
                                         ARGS_13), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS_01>::Type args_01,
                      typename bslmf::ForwardingType<ARGS_02>::Type args_02,
                      typename bslmf::ForwardingType<ARGS_03>::Type args_03,
                      typename bslmf::ForwardingType<ARGS_04>::Type args_04,
                      typename bslmf::ForwardingType<ARGS_05>::Type args_05,
                      typename bslmf::ForwardingType<ARGS_06>::Type args_06,
                      typename bslmf::ForwardingType<ARGS_07>::Type args_07,
                      typename bslmf::ForwardingType<ARGS_08>::Type args_08,
                      typename bslmf::ForwardingType<ARGS_09>::Type args_09,
                      typename bslmf::ForwardingType<ARGS_10>::Type args_10,
                      typename bslmf::ForwardingType<ARGS_11>::Type args_11,
                      typename bslmf::ForwardingType<ARGS_12>::Type args_12,
                      typename bslmf::ForwardingType<ARGS_13>::Type args_13);

    static bool isNull(const FUNC&);
};
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_A >= 13

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.

template <class FUNC, class RET, class... ARGS>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                     RET(ARGS...), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS>::Type...  args);

    static bool isNull(FUNC f);
};

template <class FUNC, class RET, class ARG0, class... ARGS>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                     RET(ARG0, ARGS...), FUNC> {

  private:
    static RET invokeImp(bsl::true_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                         typename bslmf::ForwardingType<ARGS>::Type...  args);

    static RET invokeImp(bsl::false_type ,
                         FUNC                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj,
                         typename bslmf::ForwardingType<ARGS>::Type...  args);

  public:
    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARG0>::Type     obj,
                      typename bslmf::ForwardingType<ARGS>::Type...  args);

    static bool isNull(FUNC f);
};

template <class MEMBER_TYPE, class CLASS_TYPE, class RET, class ARG0>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemDataPtr,
                                     RET(ARG0), MEMBER_TYPE CLASS_TYPE::*> {
  private:
    typedef MEMBER_TYPE CLASS_TYPE::* Func;

    static RET invokeImp(bsl::true_type ,
                         Func                                        f,
                         typename bslmf::ForwardingType<ARG0>::Type  obj);

    static RET invokeImp(bsl::false_type ,
                         Func                                           f,
                         typename bslmf::ForwardingType<ARG0>::Type     obj);

  public:
    static RET invoke(const Function_Rep                         *rep,
                      typename bslmf::ForwardingType<ARG0>::Type  obj);

    static bool isNull(Func f);
};

template <class FUNC, class RET, class... ARGS>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                     RET(ARGS...), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS>::Type...  args);

    static bool isNull(const FUNC&);
};

template <class FUNC, class RET, class... ARGS>
struct Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                     RET(ARGS...), FUNC> {

    static RET invoke(const Function_Rep                            *rep,
                      typename bslmf::ForwardingType<ARGS>::Type...  args);

    static bool isNull(const FUNC&);
};

// }}} END GENERATED CODE
#endif

// ===========================================================================
//                TEMPLATE AND INLINE FUNCTION IMPLEMENTATIONS
// ===========================================================================

                        // ---------------------------
                        // struct Function_InvokerUtil
                        // ---------------------------

template <class PROTOTYPE>
inline
bslstl::Function_InvokerUtil::GenericInvoker *
bslstl::Function_InvokerUtil::invokerForFunc(const bsl::nullptr_t&)
{
    return 0;
}

template <class PROTOTYPE, class FUNC>
bslstl::Function_InvokerUtil::GenericInvoker *
bslstl::Function_InvokerUtil::invokerForFunc(const FUNC& f)
{
    typedef bslstl::Function_SmallObjectOptimization Soo;

    // Strip 'NothrowMovableWrapper' (if any) off of 'FUNC' type.
    typedef typename
        bslalg::NothrowMovableUtil::UnwrappedType<FUNC>::type UwFuncType;

    // Categorize the type of invocable corresponding to 'FUNC'.  Note that the
    // parameter to 'Soo::Inplace' is 'FUNC', not 'UwFuncType'.  That is
    // because 'Soo::Inplace' takes the wrapper into account when determining
    // whether the type should be inplace or not.
    static const int k_INVOCATION_TYPE =
        bslmf::IsFunctionPointer<UwFuncType>::value       ? e_FunctionPtr    :
        bslmf::IsMemberFunctionPointer<UwFuncType>::value ? e_MemFunctionPtr :
        bsl::is_member_pointer<UwFuncType>::value         ? e_MemDataPtr     :
        Soo::IsInplaceFunc<FUNC>::value                   ? e_InplaceFunctor :
        e_OutofplaceFunctor;

    // Instantiate the class for dispatching the invoker
    typedef Function_InvokerUtil_Dispatch<k_INVOCATION_TYPE,
                                          PROTOTYPE,
                                          UwFuncType> DispatcherClass;

    // If a pointer-to-function or pointer-to-member-function is null, then
    // return null.
    if (DispatcherClass::isNull(bslalg::NothrowMovableUtil::unwrap(f)))
    {
        return 0;                                                     // RETURN
    }

    // Verify the assumption that all function pointers are the same size.
    BSLMF_ASSERT(sizeof(&DispatcherClass::invoke) ==
                 sizeof(Function_Rep::GenericInvoker *));

    // Return a pointer to the actual invoker function
    return reinterpret_cast<Function_Rep::GenericInvoker *>(
                                                 &DispatcherClass::invoke);
}

               // ---------------------------------------------
               // struct template Function_InvokerUtil_Dispatch
               // ---------------------------------------------

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bslstl_function_invokerutil.h
#ifndef BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT
#define BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT 13
#endif
#ifndef BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B
#define BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT
#endif

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0
template <class FUNC, class RET>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(), FUNC>::
invoke(const Function_Rep                            *rep)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f());
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1
template <class FUNC, class RET, class ARGS_01>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10,
                                  ARGS_11), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
          bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10,
                                  ARGS_11,
                                  ARGS_12), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11,
       typename bslmf::ForwardingType<ARGS_12>::Type args_12)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
          bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11),
          bslmf::ForwardingTypeUtil<ARGS_12>::forwardToTarget(args_12)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10,
                                  ARGS_11,
                                  ARGS_12,
                                  ARGS_13), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11,
       typename bslmf::ForwardingType<ARGS_12>::Type args_12,
       typename bslmf::ForwardingType<ARGS_13>::Type args_13)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
          bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11),
          bslmf::ForwardingTypeUtil<ARGS_12>::forwardToTarget(args_12),
          bslmf::ForwardingTypeUtil<ARGS_13>::forwardToTarget(args_13)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13


#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0
template <class FUNC, class RET>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                   RET(), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1
template <class FUNC, class RET, class ARGS_01>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                   RET(ARGS_01), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                   RET(ARGS_01,
                                       ARGS_02), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06,
                                       ARGS_07), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06,
                                       ARGS_07,
                                       ARGS_08), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06,
                                       ARGS_07,
                                       ARGS_08,
                                       ARGS_09), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06,
                                       ARGS_07,
                                       ARGS_08,
                                       ARGS_09,
                                       ARGS_10), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06,
                                       ARGS_07,
                                       ARGS_08,
                                       ARGS_09,
                                       ARGS_10,
                                       ARGS_11), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06,
                                       ARGS_07,
                                       ARGS_08,
                                       ARGS_09,
                                       ARGS_10,
                                       ARGS_11,
                                       ARGS_12), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06,
                                       ARGS_07,
                                       ARGS_08,
                                       ARGS_09,
                                       ARGS_10,
                                       ARGS_11,
                                       ARGS_12,
                                       ARGS_13), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13



#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0
template <class FUNC, class RET, class ARG0>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            ));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1
template <class FUNC, class RET, class ARG0, class ARGS_01>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08,
          typename bslmf::ForwardingType<ARGS_09>::Type args_09)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
            bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08,
          typename bslmf::ForwardingType<ARGS_09>::Type args_09,
          typename bslmf::ForwardingType<ARGS_10>::Type args_10)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
            bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
            bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10,
                                        ARGS_11), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08,
          typename bslmf::ForwardingType<ARGS_09>::Type args_09,
          typename bslmf::ForwardingType<ARGS_10>::Type args_10,
          typename bslmf::ForwardingType<ARGS_11>::Type args_11)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
            bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
            bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
            bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10,
                                        ARGS_11,
                                        ARGS_12), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08,
          typename bslmf::ForwardingType<ARGS_09>::Type args_09,
          typename bslmf::ForwardingType<ARGS_10>::Type args_10,
          typename bslmf::ForwardingType<ARGS_11>::Type args_11,
          typename bslmf::ForwardingType<ARGS_12>::Type args_12)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
            bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
            bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
            bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11),
            bslmf::ForwardingTypeUtil<ARGS_12>::forwardToTarget(args_12)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12,
                                             class ARGS_13>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10,
                                        ARGS_11,
                                        ARGS_12,
                                        ARGS_13), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08,
          typename bslmf::ForwardingType<ARGS_09>::Type args_09,
          typename bslmf::ForwardingType<ARGS_10>::Type args_10,
          typename bslmf::ForwardingType<ARGS_11>::Type args_11,
          typename bslmf::ForwardingType<ARGS_12>::Type args_12,
          typename bslmf::ForwardingType<ARGS_13>::Type args_13)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
            bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
            bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
            bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11),
            bslmf::ForwardingTypeUtil<ARGS_12>::forwardToTarget(args_12),
            bslmf::ForwardingTypeUtil<ARGS_13>::forwardToTarget(args_13)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13


#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0
template <class FUNC, class RET, class ARG0>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            ));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1
template <class FUNC, class RET, class ARG0, class ARGS_01>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08,
          typename bslmf::ForwardingType<ARGS_09>::Type args_09)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
            bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08,
          typename bslmf::ForwardingType<ARGS_09>::Type args_09,
          typename bslmf::ForwardingType<ARGS_10>::Type args_10)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
            bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
            bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10,
                                        ARGS_11), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08,
          typename bslmf::ForwardingType<ARGS_09>::Type args_09,
          typename bslmf::ForwardingType<ARGS_10>::Type args_10,
          typename bslmf::ForwardingType<ARGS_11>::Type args_11)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
            bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
            bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
            bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10,
                                        ARGS_11,
                                        ARGS_12), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08,
          typename bslmf::ForwardingType<ARGS_09>::Type args_09,
          typename bslmf::ForwardingType<ARGS_10>::Type args_10,
          typename bslmf::ForwardingType<ARGS_11>::Type args_11,
          typename bslmf::ForwardingType<ARGS_12>::Type args_12)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
            bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
            bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
            bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11),
            bslmf::ForwardingTypeUtil<ARGS_12>::forwardToTarget(args_12)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12,
                                             class ARGS_13>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10,
                                        ARGS_11,
                                        ARGS_12,
                                        ARGS_13), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS_01>::Type args_01,
          typename bslmf::ForwardingType<ARGS_02>::Type args_02,
          typename bslmf::ForwardingType<ARGS_03>::Type args_03,
          typename bslmf::ForwardingType<ARGS_04>::Type args_04,
          typename bslmf::ForwardingType<ARGS_05>::Type args_05,
          typename bslmf::ForwardingType<ARGS_06>::Type args_06,
          typename bslmf::ForwardingType<ARGS_07>::Type args_07,
          typename bslmf::ForwardingType<ARGS_08>::Type args_08,
          typename bslmf::ForwardingType<ARGS_09>::Type args_09,
          typename bslmf::ForwardingType<ARGS_10>::Type args_10,
          typename bslmf::ForwardingType<ARGS_11>::Type args_11,
          typename bslmf::ForwardingType<ARGS_12>::Type args_12,
          typename bslmf::ForwardingType<ARGS_13>::Type args_13)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
            bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
            bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
            bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
            bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
            bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
            bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
            bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
            bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
            bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
            bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11),
            bslmf::ForwardingTypeUtil<ARGS_12>::forwardToTarget(args_12),
            bslmf::ForwardingTypeUtil<ARGS_13>::forwardToTarget(args_13)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13


#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0
template <class FUNC, class RET, class ARG0>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1
template <class FUNC, class RET, class ARG0, class ARGS_01>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02,
                                                            args_03));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02,
                                                            args_03,
                                                            args_04));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02,
                                                            args_03,
                                                            args_04,
                                                            args_05));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02,
                                                            args_03,
                                                            args_04,
                                                            args_05,
                                                            args_06));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02,
                                                            args_03,
                                                            args_04,
                                                            args_05,
                                                            args_06,
                                                            args_07));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02,
                                                            args_03,
                                                            args_04,
                                                            args_05,
                                                            args_06,
                                                            args_07,
                                                            args_08));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02,
                                                            args_03,
                                                            args_04,
                                                            args_05,
                                                            args_06,
                                                            args_07,
                                                            args_08,
                                                            args_09));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02,
                                                            args_03,
                                                            args_04,
                                                            args_05,
                                                            args_06,
                                                            args_07,
                                                            args_08,
                                                            args_09,
                                                            args_10));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10,
                                        ARGS_11), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02,
                                                            args_03,
                                                            args_04,
                                                            args_05,
                                                            args_06,
                                                            args_07,
                                                            args_08,
                                                            args_09,
                                                            args_10,
                                                            args_11));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10,
                                        ARGS_11,
                                        ARGS_12), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11,
       typename bslmf::ForwardingType<ARGS_12>::Type args_12)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02,
                                                            args_03,
                                                            args_04,
                                                            args_05,
                                                            args_06,
                                                            args_07,
                                                            args_08,
                                                            args_09,
                                                            args_10,
                                                            args_11,
                                                            args_12));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12,
                                             class ARGS_13>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS_01,
                                        ARGS_02,
                                        ARGS_03,
                                        ARGS_04,
                                        ARGS_05,
                                        ARGS_06,
                                        ARGS_07,
                                        ARGS_08,
                                        ARGS_09,
                                        ARGS_10,
                                        ARGS_11,
                                        ARGS_12,
                                        ARGS_13), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11,
       typename bslmf::ForwardingType<ARGS_12>::Type args_12,
       typename bslmf::ForwardingType<ARGS_13>::Type args_13)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args_01,
                                                            args_02,
                                                            args_03,
                                                            args_04,
                                                            args_05,
                                                            args_06,
                                                            args_07,
                                                            args_08,
                                                            args_09,
                                                            args_10,
                                                            args_11,
                                                            args_12,
                                                            args_13));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13


#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0
template <class FUNC, class RET, class ARG0>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                   RET(ARG0), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1
template <class FUNC, class RET, class ARG0, class ARGS_01>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                   RET(ARG0, ARGS_01), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                   RET(ARG0, ARGS_01,
                                             ARGS_02), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                   RET(ARG0, ARGS_01,
                                             ARGS_02,
                                             ARGS_03), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                   RET(ARG0, ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                   RET(ARG0, ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                   RET(ARG0, ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                   RET(ARG0, ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                   RET(ARG0, ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                   RET(ARG0, ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                   RET(ARG0, ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                   RET(ARG0, ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10,
                                             ARGS_11), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                   RET(ARG0, ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10,
                                             ARGS_11,
                                             ARGS_12), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13
template <class FUNC, class RET, class ARG0, class ARGS_01,
                                             class ARGS_02,
                                             class ARGS_03,
                                             class ARGS_04,
                                             class ARGS_05,
                                             class ARGS_06,
                                             class ARGS_07,
                                             class ARGS_08,
                                             class ARGS_09,
                                             class ARGS_10,
                                             class ARGS_11,
                                             class ARGS_12,
                                             class ARGS_13>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                   RET(ARG0, ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10,
                                             ARGS_11,
                                             ARGS_12,
                                             ARGS_13), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13


template <class MEMBER_TYPE, class CLASS_TYPE, class RET, class ARG0>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemDataPtr,
                              RET(ARG0), MEMBER_TYPE CLASS_TYPE::*>::
invokeImp(bsl::true_type ,
          Func                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f));
}

template <class MEMBER_TYPE, class CLASS_TYPE, class RET, class ARG0>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemDataPtr,
                              RET(ARG0), MEMBER_TYPE CLASS_TYPE::*>::
invokeImp(bsl::false_type ,
          Func                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f));
}

template <class MEMBER_TYPE, class CLASS_TYPE, class RET, class ARG0>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemDataPtr,
                              RET(ARG0), MEMBER_TYPE CLASS_TYPE::*>::
invoke(const Function_Rep                         *rep,
       typename bslmf::ForwardingType<ARG0>::Type  obj)
{
    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            const volatile CLASS_TYPE *
        >::type IsDirect;

    Func f = *rep->targetRaw<Func, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, invokeImp(IsDirect(), f, obj));
}

template <class MEMBER_TYPE, class CLASS_TYPE, class RET, class ARG0>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemDataPtr,
                                   RET(ARG0), MEMBER_TYPE CLASS_TYPE::*>::
isNull(Func f)
{
    return 0 == f;
}

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0
template <class FUNC, class RET>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(), FUNC>::
invoke(const Function_Rep                            *rep)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f());
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1
template <class FUNC, class RET, class ARGS_01>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10,
                                  ARGS_11), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
          bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10,
                                  ARGS_11,
                                  ARGS_12), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11,
       typename bslmf::ForwardingType<ARGS_12>::Type args_12)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
          bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11),
          bslmf::ForwardingTypeUtil<ARGS_12>::forwardToTarget(args_12)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10,
                                  ARGS_11,
                                  ARGS_12,
                                  ARGS_13), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11,
       typename bslmf::ForwardingType<ARGS_12>::Type args_12,
       typename bslmf::ForwardingType<ARGS_13>::Type args_13)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
          bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11),
          bslmf::ForwardingTypeUtil<ARGS_12>::forwardToTarget(args_12),
          bslmf::ForwardingTypeUtil<ARGS_13>::forwardToTarget(args_13)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13


#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0
template <class FUNC, class RET>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                   RET(), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1
template <class FUNC, class RET, class ARGS_01>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                   RET(ARGS_01), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06,
                                       ARGS_07), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06,
                                       ARGS_07,
                                       ARGS_08), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06,
                                       ARGS_07,
                                       ARGS_08,
                                       ARGS_09), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06,
                                       ARGS_07,
                                       ARGS_08,
                                       ARGS_09,
                                       ARGS_10), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06,
                                       ARGS_07,
                                       ARGS_08,
                                       ARGS_09,
                                       ARGS_10,
                                       ARGS_11), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06,
                                       ARGS_07,
                                       ARGS_08,
                                       ARGS_09,
                                       ARGS_10,
                                       ARGS_11,
                                       ARGS_12), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06,
                                       ARGS_07,
                                       ARGS_08,
                                       ARGS_09,
                                       ARGS_10,
                                       ARGS_11,
                                       ARGS_12,
                                       ARGS_13), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13


#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0
template <class FUNC, class RET>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(), FUNC>::
invoke(const Function_Rep                            *rep)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f());
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1
template <class FUNC, class RET, class ARGS_01>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10,
                                  ARGS_11), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
          bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10,
                                  ARGS_11,
                                  ARGS_12), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11,
       typename bslmf::ForwardingType<ARGS_12>::Type args_12)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
          bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11),
          bslmf::ForwardingTypeUtil<ARGS_12>::forwardToTarget(args_12)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS_01,
                                  ARGS_02,
                                  ARGS_03,
                                  ARGS_04,
                                  ARGS_05,
                                  ARGS_06,
                                  ARGS_07,
                                  ARGS_08,
                                  ARGS_09,
                                  ARGS_10,
                                  ARGS_11,
                                  ARGS_12,
                                  ARGS_13), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS_01>::Type args_01,
       typename bslmf::ForwardingType<ARGS_02>::Type args_02,
       typename bslmf::ForwardingType<ARGS_03>::Type args_03,
       typename bslmf::ForwardingType<ARGS_04>::Type args_04,
       typename bslmf::ForwardingType<ARGS_05>::Type args_05,
       typename bslmf::ForwardingType<ARGS_06>::Type args_06,
       typename bslmf::ForwardingType<ARGS_07>::Type args_07,
       typename bslmf::ForwardingType<ARGS_08>::Type args_08,
       typename bslmf::ForwardingType<ARGS_09>::Type args_09,
       typename bslmf::ForwardingType<ARGS_10>::Type args_10,
       typename bslmf::ForwardingType<ARGS_11>::Type args_11,
       typename bslmf::ForwardingType<ARGS_12>::Type args_12,
       typename bslmf::ForwardingType<ARGS_13>::Type args_13)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS_01>::forwardToTarget(args_01),
          bslmf::ForwardingTypeUtil<ARGS_02>::forwardToTarget(args_02),
          bslmf::ForwardingTypeUtil<ARGS_03>::forwardToTarget(args_03),
          bslmf::ForwardingTypeUtil<ARGS_04>::forwardToTarget(args_04),
          bslmf::ForwardingTypeUtil<ARGS_05>::forwardToTarget(args_05),
          bslmf::ForwardingTypeUtil<ARGS_06>::forwardToTarget(args_06),
          bslmf::ForwardingTypeUtil<ARGS_07>::forwardToTarget(args_07),
          bslmf::ForwardingTypeUtil<ARGS_08>::forwardToTarget(args_08),
          bslmf::ForwardingTypeUtil<ARGS_09>::forwardToTarget(args_09),
          bslmf::ForwardingTypeUtil<ARGS_10>::forwardToTarget(args_10),
          bslmf::ForwardingTypeUtil<ARGS_11>::forwardToTarget(args_11),
          bslmf::ForwardingTypeUtil<ARGS_12>::forwardToTarget(args_12),
          bslmf::ForwardingTypeUtil<ARGS_13>::forwardToTarget(args_13)));
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13


#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0
template <class FUNC, class RET>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                   RET(), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 0

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1
template <class FUNC, class RET, class ARGS_01>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                   RET(ARGS_01), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 1

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 2

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 3

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 4

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 5

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 6

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06,
                                       ARGS_07), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 7

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06,
                                       ARGS_07,
                                       ARGS_08), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 8

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06,
                                       ARGS_07,
                                       ARGS_08,
                                       ARGS_09), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 9

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06,
                                       ARGS_07,
                                       ARGS_08,
                                       ARGS_09,
                                       ARGS_10), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 10

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06,
                                       ARGS_07,
                                       ARGS_08,
                                       ARGS_09,
                                       ARGS_10,
                                       ARGS_11), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 11

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06,
                                       ARGS_07,
                                       ARGS_08,
                                       ARGS_09,
                                       ARGS_10,
                                       ARGS_11,
                                       ARGS_12), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 12

#if BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13
template <class FUNC, class RET, class ARGS_01,
                                 class ARGS_02,
                                 class ARGS_03,
                                 class ARGS_04,
                                 class ARGS_05,
                                 class ARGS_06,
                                 class ARGS_07,
                                 class ARGS_08,
                                 class ARGS_09,
                                 class ARGS_10,
                                 class ARGS_11,
                                 class ARGS_12,
                                 class ARGS_13>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                   RET(ARGS_01,
                                       ARGS_02,
                                       ARGS_03,
                                       ARGS_04,
                                       ARGS_05,
                                       ARGS_06,
                                       ARGS_07,
                                       ARGS_08,
                                       ARGS_09,
                                       ARGS_10,
                                       ARGS_11,
                                       ARGS_12,
                                       ARGS_13), FUNC>::isNull(const FUNC&)
{
    return false;
}
#endif  // BSLSTL_FUNCTION_INVOKERUTIL_VARIADIC_LIMIT_B >= 13

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.

template <class FUNC, class RET, class... ARGS>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                              RET(ARGS...), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS>::Type...  args)
{
    FUNC f = *rep->targetRaw<FUNC, true>();


    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS>::forwardToTarget(args)...));
}

template <class FUNC, class RET, class... ARGS>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_FunctionPtr,
                                   RET(ARGS...), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}


template <class FUNC, class RET, class ARG0, class... ARGS>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS...), FUNC>::
invokeImp(bsl::true_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS>::Type...  args)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f)(
            bslmf::ForwardingTypeUtil<ARGS>::forwardToTarget(args)...));
}

template <class FUNC, class RET, class ARG0, class... ARGS>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS...), FUNC>::
invokeImp(bsl::false_type ,
          FUNC                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj,
          typename bslmf::ForwardingType<ARGS>::Type...  args)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f)(
            bslmf::ForwardingTypeUtil<ARGS>::forwardToTarget(args)...));
}

template <class FUNC, class RET, class ARG0, class... ARGS>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                              RET(ARG0, ARGS...), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARG0>::Type     obj,
       typename bslmf::ForwardingType<ARGS>::Type...  args)
{
    typedef typename
        bslmf::MemberFunctionPointerTraits<FUNC>::ClassType ClassType;

    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            ClassType *
        >::type IsDirect;

    FUNC f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(RET,
                                                  invokeImp(IsDirect(), f, obj,
                                                            args...));
}

template <class FUNC, class RET, class ARG0, class... ARGS>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemFunctionPtr,
                                   RET(ARG0, ARGS...), FUNC>::isNull(FUNC f)
{
    return 0 == f;
}

template <class MEMBER_TYPE, class CLASS_TYPE, class RET, class ARG0>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemDataPtr,
                              RET(ARG0), MEMBER_TYPE CLASS_TYPE::*>::
invokeImp(bsl::true_type ,
          Func                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, (const_cast<Arg0Ref>(obj).*f));
}

template <class MEMBER_TYPE, class CLASS_TYPE, class RET, class ARG0>
inline
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemDataPtr,
                              RET(ARG0), MEMBER_TYPE CLASS_TYPE::*>::
invokeImp(bsl::false_type ,
          Func                                           f,
          typename bslmf::ForwardingType<ARG0>::Type     obj)
{
    typedef typename
        bslmf::MovableRefUtil::RemoveReference<ARG0>::type& Arg0Ref;

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, ((*const_cast<Arg0Ref>(obj)).*f));
}

template <class MEMBER_TYPE, class CLASS_TYPE, class RET, class ARG0>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemDataPtr,
                              RET(ARG0), MEMBER_TYPE CLASS_TYPE::*>::
invoke(const Function_Rep                         *rep,
       typename bslmf::ForwardingType<ARG0>::Type  obj)
{
    typedef typename bsl::is_convertible<
            typename bslmf::MovableRefUtil::RemoveReference<ARG0>::type *,
            const volatile CLASS_TYPE *
        >::type IsDirect;

    Func f = *rep->targetRaw<Func, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET, invokeImp(IsDirect(), f, obj));
}

template <class MEMBER_TYPE, class CLASS_TYPE, class RET, class ARG0>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_MemDataPtr,
                                   RET(ARG0), MEMBER_TYPE CLASS_TYPE::*>::
isNull(Func f)
{
    return 0 == f;
}

template <class FUNC, class RET, class... ARGS>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                              RET(ARGS...), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS>::Type...  args)
{
    FUNC& f = *rep->targetRaw<FUNC, true>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS>::forwardToTarget(args)...));
}

template <class FUNC, class RET, class... ARGS>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_InplaceFunctor,
                                   RET(ARGS...), FUNC>::isNull(const FUNC&)
{
    return false;
}

template <class FUNC, class RET, class... ARGS>
RET
Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                              RET(ARGS...), FUNC>::
invoke(const Function_Rep                            *rep,
       typename bslmf::ForwardingType<ARGS>::Type...  args)
{
    FUNC& f = *rep->targetRaw<FUNC, false>();

    return BSLSTL_FUNCTION_INVOKERUTIL_CAST_RESULT(
        RET,
        f(bslmf::ForwardingTypeUtil<ARGS>::forwardToTarget(args)...));
}

template <class FUNC, class RET, class... ARGS>
inline
bool Function_InvokerUtil_Dispatch<Function_InvokerUtil::e_OutofplaceFunctor,
                                   RET(ARGS...), FUNC>::isNull(const FUNC&)
{
    return false;
}

// }}} END GENERATED CODE
#endif

}  // close package namespace

}  // close enterprise namespace

#else // if ! defined(DEFINED_BSLSTL_FUNCTION_INVOKERUTIL_H)
# error Not valid except when included from bslstl_function_invokerutil.h
#endif // ! defined(COMPILING_BSLSTL_FUNCTION_INVOKERUTIL_H)

#endif // ! defined(INCLUDED_BSLSTL_FUNCTION_INVOKERUTIL_CPP03)

// ----------------------------------------------------------------------------
// Copyright 2020 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
