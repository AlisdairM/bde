// bdlsb_fixedmeminput.h                                              -*-C++-*-
#ifndef INCLUDED_BDLSB_FIXEDMEMINPUT
#define INCLUDED_BDLSB_FIXEDMEMINPUT

#ifndef INCLUDED_BSLS_IDENT
#include <bsls_ident.h>
#endif
BSLS_IDENT("$Id: $")

//@PURPOSE: Provide a basic input stream buffer using a client buffer.
//
//@CLASSES:
//   bdlsb::FixedMemInput: basic input stream buffer using client memory
//
//@AUTHOR: Herve Bronnimann (hbronnimann)
//
//@SEE_ALSO: bdlsb_fixedmeminstreambuf
//
//@DESCRIPTION: This component implements the input portion of the
// 'bsl::basic_streambuf' protocol using a client-supplied memory buffer.
// Method names necessarily correspond to the protocol-specified method names.
// Clients supply the character buffer at stream buffer construction, and can
// later reinitialize the stream buffer with a different character buffer by
// calling the 'pubsetbuf' method.  The only difference between this component
// and 'bdlsb_fixedmeminstreambuf' is that the class 'bdlsb::FixedMemInput'
// does *not* derive from a 'bsl::streambuf', and is generally more efficient
// (at initialization and due to the lack of virtual functions).
//
///Usage
///-----
// See the 'bdlsb_fixedmeminstreambuf' component for an identical usage
// example, where every occurrence of 'bdlsb::FixedMemInStreamBuf' can be
// substituted for 'bdlsb::FixedMemInput'.

#ifndef INCLUDED_BDLSCM_VERSION
#include <bdlscm_version.h>
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include <bsls_assert.h>
#endif

#ifndef INCLUDED_BSLS_PERFORMANCEHINT
#include <bsls_performancehint.h>
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include <bsls_platform.h>
#endif

#ifndef INCLUDED_BSLS_TYPES
#include <bsls_types.h>
#endif

#ifndef INCLUDED_BSL_ALGORITHM
#include <bsl_algorithm.h>
#endif

#ifndef INCLUDED_BSL_CSTDLIB
#include <bsl_cstdlib.h>
#endif

#ifndef INCLUDED_BSL_CSTRING
#include <bsl_cstring.h>
#endif

#ifndef INCLUDED_BSL_IOS
#include <bsl_ios.h>
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include <bsl_iosfwd.h>
#endif

namespace BloombergLP {
namespace bdlsb {

                            // ===================
                            // class FixedMemInput
                            // ===================

class FixedMemInput {
    // This class, like 'FixedMemInStreamBuf', implements the input
    // functionality of the 'basic_streambuf' interface, using client-supplied
    // 'char *' memory.  It has an interface identical to 'FixedMemInStreamBuf'
    // but does *not* inherit from 'bsl::streambuf'.  Thus, it is suitable for
    // use as template parameter to 'bslx::GenericInStream' (but not to
    // 'bslx::StreamBufInStream').  This usage is advantageous for performance
    // reasons, as the overhead of the initialization and virtual function
    // calls of a 'bsl::streambuf' can be undesirable.  It is especially
    // designed for streaming a very small amount of information from a
    // fixed-length buffer using a 'bslx::GenericInStream' when the number of
    // characters read from the input is guaranteed not to exceed the length of
    // the buffer.  Note that this class is not designed to be derived from.

  public:
    // TYPES
    typedef char                             char_type;
    typedef bsl::char_traits<char>::int_type int_type;
    typedef bsl::char_traits<char>::pos_type pos_type;
    typedef bsl::char_traits<char>::off_type off_type;
    typedef bsl::char_traits<char>           traits_type;

  private:
    // PRIVATE TYPES
    typedef bsls::Types::IntPtr              IntPtr;

    // PRIVATE DATA MEMBERS
    const char      *d_buffer_p;      // buffer (held, not owned)
    bsl::streamsize  d_bufferLength;  // buffer length (not length of stream)
    pos_type         d_pos;           // current read position

  private:
    // NOT IMPLEMENTED
    FixedMemInput(const FixedMemInput&);
    FixedMemInput& operator=(const FixedMemInput&);

  public:
    // CREATORS
    FixedMemInput(const char *buffer, bsl::streamsize length);
        // Create a 'FixedMemInput' using the specified 'buffer' of the
        // specified 'length'.  The behavior is undefined unless '0 < length'.

    //! ~FixedMemInput();
        // Destroy this stream buffer.  Note that this trivial destructor is
        // generated by the compiler.

    // MANIPULATORS

                             // *** 27.5.2.2.2 buffer and positioning: ***

    FixedMemInput *pubsetbuf(char *buffer, bsl::streamsize length);
    FixedMemInput *pubsetbuf(const char *buffer, bsl::streamsize length);
        // Reinitialize this stream buffer to use the specified character
        // 'buffer' having the specified 'length'.  Return the address of this
        // modifiable stream buffer.  Upon reinitialization for use of the new
        // buffer, neither the content nor the next input location is
        // preserved.  Note that 'buffer' is held but not owned.

    pos_type pubseekoff(
       off_type                offset,
       bsl::ios_base::seekdir  fixedPosition,
       bsl::ios_base::openmode which = bsl::ios_base::in | bsl::ios_base::out);
        // Move the current write cursor position by the specified 'offset'.

    pos_type pubseekpos(
       pos_type                position,
       bsl::ios_base::openmode which = bsl::ios_base::in | bsl::ios_base::out);
        // Move the current write cursor position to the specified 'position'.

                             // *** 27.5.2.2.3 Get area: ***

    bsl::streamsize in_avail();
        // Return the number of characters available from the current read
        // position in this stream buffer.

    int_type sbumpc();
        // Return the character at the current read position from this buffer,
        // or 'traits_type::eof()' if the end of the buffer is reached.

    int_type sgetc();
        // Return the character at the current read position from this buffer,
        // or 'traits_type::eof()' if the end of the buffer is reached.

    int_type snextc();
        // Advance the current read position and return the character at the
        // resulting position from this buffer, or 'traits_type::eof()' if the
        // end of the buffer is reached.

    bsl::streamsize sgetn(char_type *destination, bsl::streamsize length);
        // Write up to the specified 'n' characters from the current position
        // of this buffer, to the specified address 's', as if by calling the
        // 'sbumpc' method repeatedly 'n' times.  Return the number of
        // characters read from this buffer, which is either equal to the
        // 'length' parameter or equal to the distance from the current read
        // position to the end of the input buffer, whichever is smaller, and
        // move the read cursor position by this amount.

                             // *** 27.5.2.2.4 Putback: ***

    int_type sputbackc(char c);
        // Move the current read position back one character if the current
        // read position is not at the beginning of the buffer and the previous
        // position contains the character 'c', and return that character.
        // Otherwise, return 'traits_type::eof()' and do not move the current
        // read position.

    int_type sungetc();
        // Move the current read position back one character if the current
        // read position is not at the beginning of the buffer, and return the
        // character at the resulting current read position from this buffer.
        // Return 'traits_type::eof()' otherwise.

    // ACCESSORS
    bsl::streamsize capacity() const;
        // Return the size for the buffer held by this buffer, in bytes,
        // supplied at construction.

    const char *data() const;
        // Return the address of the non-modifiable character buffer held by
        // this stream buffer.

    bsl::streamsize length() const;
        // Return the number of characters that can be successfully read from
        // this stream buffer before reading 'traits_type::eof()' -- i.e., the
        // number of characters between the current read position and the end
        // of this buffer.
};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                            // -------------------
                            // class FixedMemInput
                            // -------------------

// CREATORS
inline
FixedMemInput::FixedMemInput(const char      *buffer,
                                         bsl::streamsize  length)
: d_buffer_p(const_cast<char *>(buffer))
, d_bufferLength(length)
, d_pos(0)
{
    BSLS_ASSERT_SAFE(buffer || 0 == length);
    BSLS_ASSERT_SAFE(0 <= length);
}

// MANIPULATORS
inline
FixedMemInput *FixedMemInput::pubsetbuf(char            *buffer,
                                                    bsl::streamsize  length)
{
    BSLS_ASSERT_SAFE(buffer || 0 == length);
    BSLS_ASSERT_SAFE(0 <= length);

    d_buffer_p     = const_cast<const char *>(buffer);
    d_bufferLength = length;
    d_pos          = 0;
    return this;
}

inline
FixedMemInput *FixedMemInput::pubsetbuf(const char      *buffer,
                                                    bsl::streamsize  length)

{
    BSLS_ASSERT_SAFE(buffer || 0 == length);
    BSLS_ASSERT_SAFE(0 <= length);

    d_buffer_p     = buffer;
    d_bufferLength = length;
    d_pos          = 0;
    return this;
}

inline
bsl::streamsize FixedMemInput::in_avail()
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(
                                   bsl::streamsize(d_pos) == d_bufferLength)) {
        return bsl::streamsize(-1);                                   // RETURN
    }
    return static_cast<bsl::streamsize>(d_bufferLength - d_pos);
}

inline
FixedMemInput::int_type FixedMemInput::sbumpc()
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(d_pos >= d_bufferLength)) {
        return traits_type::eof();                                    // RETURN
    }
    const int_type i = traits_type::to_int_type(d_buffer_p[
                                                  static_cast<IntPtr>(d_pos)]);
    d_pos += 1;
    return i;
}

inline
FixedMemInput::int_type FixedMemInput::sgetc()
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(d_pos >= d_bufferLength)) {
        return traits_type::eof();                                    // RETURN
    }
    return traits_type::to_int_type(d_buffer_p[static_cast<IntPtr>(d_pos)]);
}

inline
FixedMemInput::int_type FixedMemInput::snextc()
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(sbumpc() == traits_type::eof())){
        return traits_type::eof();                                    // RETURN
    }
    return traits_type::to_int_type(d_buffer_p[static_cast<IntPtr>(d_pos)]);
}

inline
bsl::streamsize
FixedMemInput::sgetn(char *destination, bsl::streamsize length)
{
    const pos_type current = d_pos;
    d_pos += length;
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(d_pos > d_bufferLength)) {
        d_pos  = d_bufferLength;
        length = static_cast<bsl::streamsize>(d_bufferLength - current);
    }
    bsl::memcpy(destination, d_buffer_p+static_cast<IntPtr>(current), length);
    return length;
}

inline
FixedMemInput::int_type FixedMemInput::sputbackc(char c)
{
    d_pos -= 1;
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(-1 == d_pos)
     || BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(c != d_buffer_p[
                                                static_cast<IntPtr>(d_pos)])) {
        d_pos += 1;
        return traits_type::eof();                                    // RETURN
    }
    return traits_type::to_int_type(c);
}

inline
FixedMemInput::int_type FixedMemInput::sungetc()
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(0 == d_pos)) {
        return traits_type::eof();                                    // RETURN
    }
    d_pos -= 1;
    return traits_type::to_int_type(d_buffer_p[static_cast<IntPtr>(d_pos)]);
}

// ACCESSORS
inline
bsl::streamsize FixedMemInput::capacity() const
{
    return d_bufferLength;
}

inline
const char *FixedMemInput::data() const
{
    return d_buffer_p;
}

inline
bsl::streamsize FixedMemInput::length() const
{
    return static_cast<bsl::streamsize>(d_bufferLength - d_pos);
}
}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
