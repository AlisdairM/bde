// bdlqq_xxxatomictypes.h                                             -*-C++-*-
#ifndef INCLUDED_BDLQQ_XXXATOMICTYPES
#define INCLUDED_BDLQQ_XXXATOMICTYPES

#ifndef INCLUDED_BSLS_IDENT
#include <bsls_ident.h>
#endif
BSLS_IDENT("$Id: $")

//@PURPOSE: Provide wrappers for atomic operations.
//
//@CLASSES:
//       bdlqq::AtomicInt: atomic 32-bit integer wrapper
//     bdlqq::AtomicInt64: atomic 64-bit integer wrapper
//   bdlqq::AtomicPointer: parameterized atomic pointer wrapper
//        bdlqq::SpinLock: spin lock wrapper
//
//@AUTHOR: Ilougino Rocha (irocha), Alexei Zakharov (azakhar1)
//
//@SEE_ALSO: bsls_atomic, bsls_atomicoperations
//
//@DESCRIPTION: This component provides convenient wrappers for the types and
// operations provided by the 'bdlqq_xxxatomicutil' component.  Classes
// 'bdlqq::AtomicInt' and 'bdlqq::AtomicInt64' wrap the corresponding atomic
// integers, and provide overloaded operators and functions for common
// arithmetic operations.  The class 'bdlqq::AtomicPointer' provides atomic
// operations to manipulate and dereference a pointer.  The class
// 'bdlqq::SpinLock' provides an object wrapper for a spin lock.
//
//@DEPRECATED: Use bsls_atomic components instead of bdlqq_xxxatomictypes,
// except for 'bdlqq::SpinLock'.

#ifndef INCLUDED_BDLSCM_VERSION
#include <bdlscm_version.h>
#endif

#ifndef INCLUDED_BDLQQ_XXXATOMICUTIL
#include <bdlqq_xxxatomicutil.h>
#endif

#ifndef INCLUDED_BSLS_ATOMICS
#include <bsls_atomic.h>
#endif

#ifndef INCLUDED_BSLS_TYPES
#include <bsls_types.h>
#endif

namespace BloombergLP {
namespace bdlqq {
                            // ===============
                            // class AtomicInt
                            // ===============

class AtomicInt : private bsls::AtomicInt {
    // This class is a wrapper for an integer, supporting common integer
    // operations in a way that is guaranteed to be atomic.

  public:
    // CREATORS
    AtomicInt();
        // Construct an atomic integer object and initialize it to 0.

    AtomicInt(int value);
        // Construct an atomic integer object and initialize it to the
        // specified 'value'.

    AtomicInt(const AtomicInt& original);
        // Construct an atomic integer object and initialize it to the
        // value of the specified 'original' object.

    // ~AtomicInt();
        // Destroy this atomic integer object.  Note that this trivial
        // destructor is generated by the compiler.

    // MANIPULATORS
    AtomicInt& operator=(const AtomicInt& rhs);
        // Atomically assign to this atomic integer object the value of the
        // specified 'rhs' object.

    AtomicInt& operator=(int value);
        // Atomically assign to this atomic integer object the specified
        // 'value'.

    void operator+=(int value);
        // Atomically add to this atomic integer the specified 'value'.

    void operator-=(int value);
        // Atomically subtract from this atomic integer the specified 'value'.

    int operator++();
        // Atomically increment the value of this atomic integer by 1 and
        // return the resulting value.

    int operator++(int);
        // Atomically increment the value of this atomic integer by 1 and
        // return the value prior to being incremented.

    int operator--();
        // Atomically decrement the value of this atomic integer by 1 and
        // return the resulting value.

    int operator--(int);
        // Atomically decrement the value of this atomic integer by 1 and
        // return the value prior to being decremented.

    int add(int value);
        // Atomically add to this atomic integer the specified 'value' and
        // return the resulting value.

    int relaxedAdd(int value);
        // Atomically add to this atomic integer the specified 'value' and
        // return the resulting value, without additional ordering
        // constraints.

    void relaxedStore(int value);
        // Atomically assign to this atomic integer object the specified
        // 'value', without additional ordering constraints.

    int swap(int swapValue);
        // Atomically set the value of this atomic integer to the specified
        // 'swapValue' and return its previous value.

    int testAndSwap(int compareValue, int swapValue);
        // Compare the value of this atomic integer to the specified
        // 'compareValue'.  If they are equal, set the value of this atomic
        // integer to the specified 'swapValue', otherwise leave this value
        // unchanged.  Return the previous value of this atomic integer,
        // whether or not the swap occurred.  Note that the entire
        // test-and-swap operation is performed atomically.

    // ACCESSORS
    operator int() const;
        // Return the current value of this atomic integer.

    int relaxedLoad() const;
        // Return the current value of this atomic integer without a memory
        // barrier.
};

                            // =================
                            // class AtomicInt64
                            // =================

class AtomicInt64 : private bsls::AtomicInt64 {
    // This class is a wrapper for a 64-bit integer, supporting common integer
    // operations in a way that is guaranteed to be atomic.

  public:
    // CREATORS
    AtomicInt64();
        // Construct an atomic 64-bit integer object and initialize it to 0.

    AtomicInt64(bsls::Types::Int64 value);
        // Construct an atomic 64-bit integer object and initialize it to the
        // specified 'value'.

    AtomicInt64(const AtomicInt64& original);
        // Construct an atomic 64-bit integer object and initialize it to the
        // value of the specified 'original' object.

    // ~AtomicInt64();
        // Destroy this atomic 64-bit integer object.  Note that this trivial
        // destructor is generated by the compiler.

    // MANIPULATORS
    AtomicInt64& operator=(const AtomicInt64& rhs);
        // Atomically assign to this atomic 64-bit integer object the value of
        // the specified 'rhs' object.

    AtomicInt64& operator=(bsls::Types::Int64 value);
        // Atomically assign to this atomic 64-bit integer object the
        // specified 'value'.

    void operator+=(bsls::Types::Int64 value);
        // Atomically add to this atomic 64-bit integer the specified 'value'.

    void operator-=(bsls::Types::Int64 value);
        // Atomically subtract from this atomic 64-bit integer the specified
        // 'value'.

    bsls::Types::Int64 operator++();
        // Atomically increment the value of this atomic 64-bit integer by 1
        // and return the resulting value.

    bsls::Types::Int64 operator++(int);
        // Atomically increment the value of this atomic 64-bit integer by 1
        // and return the value prior to being incremented.

    bsls::Types::Int64 operator--();
        // Atomically decrement the value of this atomic 64-bit integer by 1
        // and return the resulting value.

    bsls::Types::Int64 operator--(int);
        // Atomically decrement the value of this atomic 64-bit integer by 1
        // and return the value prior to being decremented.

    bsls::Types::Int64 add(bsls::Types::Int64 value);
        // Atomically add to this atomic 64-bit integer the specified 'value'
        // and return the result value.

    bsls::Types::Int64 relaxedAdd(bsls::Types::Int64 value);
        // Atomically add to this atomic 64-bit integer the specified 'value'
        // and return the result value, without additional ordering
        // constraints.

    void relaxedStore(bsls::Types::Int64 value);
        // Atomically assign to this atomic 64-bit integer object the
        // specified 'value', without additional ordering constraints.

    bsls::Types::Int64 swap(bsls::Types::Int64 swapValue);
        // Atomically set the value of this atomic 64-bit integer to the
        // specified 'swapValue' and return its previous value.

    bsls::Types::Int64 testAndSwap(bsls::Types::Int64 compareValue,
                                   bsls::Types::Int64 swapValue);
        // Compare the value of this atomic 64-bit integer to the specified
        // 'compareValue'.  If they are equal, set the value of this atomic
        // 64-bit integer to the specified 'swapValue', otherwise leave this
        // value unchanged.  Return the previous value of this atomic 64-bit
        // integer, whether or not the swap occurred.  Note that the entire
        // test-and-swap operation is performed atomically.

    // ACCESSORS
    operator bsls::Types::Int64() const;
        // Return the value of this atomic 64-bit integer.

    bsls::Types::Int64 relaxedLoad() const;
        // Return the current value of this atomic 64-bit integer without
        // additional ordering constraints.
};

                            // ===================
                            // class AtomicPointer
                            // ===================

template <class TYPE>
class AtomicPointer : private bsls::AtomicPointer<TYPE> {
    // This class provides a wrapper for pointers to a parameterized 'TYPE',
    // supporting pointer operations in a way that is guaranteed to be atomic.

    // TYPES
    typedef bsls::AtomicPointer<TYPE> AtomicPointerImp;

  public:
    // CREATORS
    AtomicPointer();
        // Construct an atomic pointer to an object of the parameterized
        // 'TYPE' and initialize it to null.

    AtomicPointer(TYPE *value);
        // Construct an atomic pointer to an object of the parameterized 'TYPE'
        // and initialize it to the specified pointer 'value'.

    AtomicPointer(const AtomicPointer<TYPE>& original);
        // Construct an atomic pointer and initialize it to point to the
        // same 'TYPE' instance as the specified 'original' object.

    // ~AtomicPointer();
        // Destroy this atomic pointer.  Note that this trivial destructor is
        // generated by the compiler.

    // MANIPULATORS
    AtomicPointer<TYPE>& operator=(const AtomicPointer<TYPE>& rhs);
        // Atomically assign to this atomic pointer the value of the specified
        // 'rhs' object.

    AtomicPointer<TYPE>& operator=(TYPE *value);
        // Atomically assign to this atomic pointer the specified pointer
        // 'value'.

    void relaxedStore(TYPE *value);
        // Atomically assign to this atomic pointer the specified 'value',
        // without additional ordering constraints.

    TYPE *swap(TYPE *swapValue);
        // Atomically set the value of this atomic pointer to the specified
        // 'swapValue' and return the previous value of this atomic pointer.

    TYPE *testAndSwap(const TYPE *compareValue, TYPE *swapValue);
        // Compare the value of this atomic pointer to the specified
        // 'compareValue'.  If they are equal, set the value of this atomic
        // pointer to the specified 'swapValue', otherwise leave this value
        // unchanged.  Return the previous value of this atomic pointer,
        // whether or not the swap occurred.  Note that the entire
        // test-and-swap operation is performed atomically.

    // ACCESSORS
    TYPE& operator*() const;
        // Return a reference to the object currently pointed to by this atomic
        // pointer.  The behavior is undefined if this pointer has a value of
        // 0.

    TYPE *operator->() const;
        // Return the value of this atomic pointer.

    operator TYPE*() const;
        // Return the value of this atomic pointer.  Note that this method can
        // be used to determine if this pointer is null.

    TYPE *relaxedLoad() const;
        // Return the value of this atomic pointer without additional
        // ordering constraints.

};

                            // ====================
                            // class AtomicSpinLock
                            // ====================

class SpinLock {
    // This class is a wrapper to an atomic spin lock, supporting the 'lock',
    // 'tryLock' and 'unlock' methods.

    // DATA
    AtomicUtil::SpinLock d_spin;

    // NOT IMPLEMENTED
    SpinLock(const SpinLock&);
    SpinLock& operator=(const SpinLock&);

  public:
    // CREATORS
    SpinLock();
        // Construct a spin lock and initialize it to the unlock state.

    // ~SpinLock();
        // Destroy this spin lock.  Note that this trivial destructor is
        // generated by the compiler.

    // MANIPULATORS
    void lock();
        // Lock this spinlock.

    int tryLock(int numRetries = 100);
        // Try to lock this spin lock.  Optionally specify 'numRetries'
        // indicating the maximum number of subsequent attempts to lock this
        // spin lock if the first attempt fails.  If 'numRetries' is not
        // specified, attempt to lock this spin-lock 100 times after the
        // initial attempt.  Return 0 on success, and a non-zero value if the
        // lock could not be acquired.

    void unlock();
        // Unlock this spinlock which was previously locked by a successful
        // call to either 'lock' or 'tryLock'.
};
}  // close package namespace

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

            // ---------------------------------------------
            // inlined methods used by other inlined methods
            // ---------------------------------------------

inline
bdlqq::AtomicInt::operator int() const
{
    return bsls::AtomicInt::operator int();
}

inline
bdlqq::AtomicInt64::operator bsls::Types::Int64() const
{
    return bsls::AtomicInt64::operator bsls::Types::Int64();
}

template <class TYPE>
inline
bdlqq::AtomicPointer<TYPE>::operator TYPE*() const
{
    return bsls::AtomicPointer<TYPE>::operator TYPE*();
}

                            // ---------------
                            // class AtomicInt
                            // ---------------

// CREATORS
inline
bdlqq::AtomicInt::AtomicInt()
{
}

inline
bdlqq::AtomicInt::AtomicInt(int value)
    : bsls::AtomicInt(value)
{
}

inline
bdlqq::AtomicInt::AtomicInt(const AtomicInt& original)
    : bsls::AtomicInt(original.loadRelaxed())
{
}

// MANIPULATORS
inline
bdlqq::AtomicInt& bdlqq::AtomicInt::operator=(const AtomicInt& rhs)
{
    bsls::AtomicInt::operator=(rhs.loadRelaxed());
    return *this;
}

inline
bdlqq::AtomicInt& bdlqq::AtomicInt::operator=(int value)
{
    bsls::AtomicInt::operator=(value);
    return *this;
}

inline
void bdlqq::AtomicInt::operator+=(int value)
{
    bsls::AtomicInt::operator+=(value);
}

inline
void bdlqq::AtomicInt::operator-=(int value)
{
    bsls::AtomicInt::operator-=(value);
}

inline
int bdlqq::AtomicInt::operator++()
{
    return bsls::AtomicInt::operator++();
}

inline
int bdlqq::AtomicInt::operator++(int)
{
    return bsls::AtomicInt::operator++(int());
}

inline
int bdlqq::AtomicInt::operator--()
{
    return bsls::AtomicInt::operator--();
}

inline
int bdlqq::AtomicInt::operator--(int)
{
    return bsls::AtomicInt::operator--(int());
}

inline
int bdlqq::AtomicInt::add(int value)
{
    return bsls::AtomicInt::add(value);
}

inline
int bdlqq::AtomicInt::relaxedAdd(int value)
{
    return bsls::AtomicInt::addRelaxed(value);
}

inline
void bdlqq::AtomicInt::relaxedStore(int value)
{
    bsls::AtomicInt::storeRelaxed(value);
}

inline
int bdlqq::AtomicInt::swap(int value)
{
    return bsls::AtomicInt::swap(value);
}

inline
int bdlqq::AtomicInt::testAndSwap(int compareValue, int swapValue)
{
    return bsls::AtomicInt::testAndSwap(compareValue, swapValue);
}

// ACCESSORS
inline
int bdlqq::AtomicInt::relaxedLoad() const
{
    return bsls::AtomicInt::loadRelaxed();
}

                            // -----------------
                            // class AtomicInt64
                            // -----------------

// CREATORS
inline
bdlqq::AtomicInt64::AtomicInt64()
{
}

inline
bdlqq::AtomicInt64::AtomicInt64(bsls::Types::Int64 value)
    : bsls::AtomicInt64(value)
{
}

inline
bdlqq::AtomicInt64::AtomicInt64(const AtomicInt64& original)
    : bsls::AtomicInt64(original.loadRelaxed())
{
}

// MANIPULATORS
inline
bdlqq::AtomicInt64& bdlqq::AtomicInt64::operator=(const AtomicInt64& rhs)
{
    bsls::AtomicInt64::operator=(rhs.loadRelaxed());
    return *this;
}

inline
bdlqq::AtomicInt64& bdlqq::AtomicInt64::operator=(bsls::Types::Int64 value)
{
    bsls::AtomicInt64::operator=(value);
    return *this;
}

inline
void bdlqq::AtomicInt64::operator+=(bsls::Types::Int64 value)
{
    bsls::AtomicInt64::operator+=(value);
}

inline
void bdlqq::AtomicInt64::operator-=(bsls::Types::Int64 value)
{
    bsls::AtomicInt64::operator-=(value);
}

inline
bsls::Types::Int64 bdlqq::AtomicInt64::operator++()
{
    return bsls::AtomicInt64::operator++();
}

inline
bsls::Types::Int64 bdlqq::AtomicInt64::operator++(int)
{
    return bsls::AtomicInt64::operator++(int());
}

inline
bsls::Types::Int64 bdlqq::AtomicInt64::operator--()
{
    return bsls::AtomicInt64::operator--();
}

inline
bsls::Types::Int64 bdlqq::AtomicInt64::operator--(int)
{
    return bsls::AtomicInt64::operator--(int());
}

inline
bsls::Types::Int64 bdlqq::AtomicInt64::add(bsls::Types::Int64 value)
{
    return bsls::AtomicInt64::add(value);
}

inline
bsls::Types::Int64 bdlqq::AtomicInt64::relaxedAdd(bsls::Types::Int64 value)
{
    return bsls::AtomicInt64::addRelaxed(value);
}

inline
void bdlqq::AtomicInt64::relaxedStore(bsls::Types::Int64 value)
{
    bsls::AtomicInt64::storeRelaxed(value);
}

inline
bsls::Types::Int64 bdlqq::AtomicInt64::swap(bsls::Types::Int64 value)
{
    return bsls::AtomicInt64::swap(value);
}

inline
bsls::Types::Int64
bdlqq::AtomicInt64::testAndSwap(bsls::Types::Int64 compareValue,
                                bsls::Types::Int64 swapValue)
{
    return bsls::AtomicInt64::testAndSwap(compareValue, swapValue);
}

// ACCESSORS
inline
bsls::Types::Int64 bdlqq::AtomicInt64::relaxedLoad() const
{
    return bsls::AtomicInt64::loadRelaxed();
}

                            // -------------------
                            // class AtomicPointer
                            // -------------------

// CREATORS
template <class TYPE>
inline
bdlqq::AtomicPointer<TYPE>::AtomicPointer()
{
}

template <class TYPE>
inline
bdlqq::AtomicPointer<TYPE>::AtomicPointer(TYPE *value)
    : AtomicPointerImp(value)
{
}

template <class TYPE>
inline
bdlqq::AtomicPointer<TYPE>::AtomicPointer(const AtomicPointer<TYPE>& original)
    : AtomicPointerImp(original.loadRelaxed())
{
}

// MANIPULATORS
template <class TYPE>
inline
bdlqq::AtomicPointer<TYPE>&
bdlqq::AtomicPointer<TYPE>::operator=(const AtomicPointer<TYPE>& rhs)
{
    bsls::AtomicPointer<TYPE>::operator=(rhs.loadRelaxed());
    return *this;
}

template <class TYPE>
inline
bdlqq::AtomicPointer<TYPE>&
bdlqq::AtomicPointer<TYPE>::operator=(TYPE *value)
{
    bsls::AtomicPointer<TYPE>::operator=(value);
    return *this;
}

template <class TYPE>
inline
TYPE *bdlqq::AtomicPointer<TYPE>::swap(TYPE *swapValue)
{
    return bsls::AtomicPointer<TYPE>::swap(swapValue);
}

template <class TYPE>
inline
TYPE *bdlqq::AtomicPointer<TYPE>::testAndSwap(const TYPE *compareValue,
                                              TYPE       *swapValue)
{
    return bsls::AtomicPointer<TYPE>::testAndSwap(compareValue, swapValue);
}

template <class TYPE>
inline
void bdlqq::AtomicPointer<TYPE>::relaxedStore(TYPE *value)
{
    bsls::AtomicPointer<TYPE>::storeRelaxed(value);
}

// ACCESSORS
template <class TYPE>
inline
TYPE& bdlqq::AtomicPointer<TYPE>::operator*() const
{
    return bsls::AtomicPointer<TYPE>::operator*();
}

template <class TYPE>
inline
TYPE *bdlqq::AtomicPointer<TYPE>::operator->() const
{
    return bsls::AtomicPointer<TYPE>::operator->();
}

template <class TYPE>
inline
TYPE *bdlqq::AtomicPointer<TYPE>::relaxedLoad() const
{
    return bsls::AtomicPointer<TYPE>::loadRelaxed();
}

                            // --------------
                            // class SpinLock
                            // --------------

// CREATORS
inline
bdlqq::SpinLock::SpinLock()
{
    AtomicUtil::initSpinLock(&d_spin);
}

// MANIPULATORS
inline
void bdlqq::SpinLock::lock()
{
    AtomicUtil::spinLock(&d_spin);
}

inline
int bdlqq::SpinLock::tryLock(int numRetries)
{
    return AtomicUtil::spinTryLock(&d_spin, numRetries);
}

inline
void bdlqq::SpinLock::unlock()
{
    AtomicUtil::spinUnlock(&d_spin);
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
